<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Extended CUDA Library (ecuda): ecuda::cube&lt; T, Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Extended CUDA Library (ecuda)
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceecuda.html">ecuda</a></li><li class="navelem"><a class="el" href="classecuda_1_1cube.html">cube</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classecuda_1_1cube-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ecuda::cube&lt; T, Alloc &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A resizable cube stored in device memory.  
 <a href="classecuda_1_1cube.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cube_8hpp_source.html">cube.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a747369f4d695d7e8599613c8ad485d70"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a></td></tr>
<tr class="memdesc:a747369f4d695d7e8599613c8ad485d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell data type  <a href="#a747369f4d695d7e8599613c8ad485d70">More...</a><br/></td></tr>
<tr class="separator:a747369f4d695d7e8599613c8ad485d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fd5d2090375a276a34100a5ff6b569"><td class="memItemLeft" align="right" valign="top">typedef Alloc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#ab9fd5d2090375a276a34100a5ff6b569">allocator_type</a></td></tr>
<tr class="memdesc:ab9fd5d2090375a276a34100a5ff6b569"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type  <a href="#ab9fd5d2090375a276a34100a5ff6b569">More...</a><br/></td></tr>
<tr class="separator:ab9fd5d2090375a276a34100a5ff6b569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47447398c7ecbc3693da769c6e24a702"><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a></td></tr>
<tr class="memdesc:a47447398c7ecbc3693da769c6e24a702"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned integral type  <a href="#a47447398c7ecbc3693da769c6e24a702">More...</a><br/></td></tr>
<tr class="separator:a47447398c7ecbc3693da769c6e24a702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb7c4e0468ea8e1b261e8b4b55fb010"><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a5cb7c4e0468ea8e1b261e8b4b55fb010">difference_type</a></td></tr>
<tr class="memdesc:a5cb7c4e0468ea8e1b261e8b4b55fb010"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed integral type  <a href="#a5cb7c4e0468ea8e1b261e8b4b55fb010">More...</a><br/></td></tr>
<tr class="separator:a5cb7c4e0468ea8e1b261e8b4b55fb010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb8e15fd3ca600bccddbccdee798ba2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a7cb8e15fd3ca600bccddbccdee798ba2">reference</a></td></tr>
<tr class="memdesc:a7cb8e15fd3ca600bccddbccdee798ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell reference type  <a href="#a7cb8e15fd3ca600bccddbccdee798ba2">More...</a><br/></td></tr>
<tr class="separator:a7cb8e15fd3ca600bccddbccdee798ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973f3786e01a747ca08be57d5ca75982"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a973f3786e01a747ca08be57d5ca75982">const_reference</a></td></tr>
<tr class="memdesc:a973f3786e01a747ca08be57d5ca75982"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell const reference type  <a href="#a973f3786e01a747ca08be57d5ca75982">More...</a><br/></td></tr>
<tr class="separator:a973f3786e01a747ca08be57d5ca75982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756f95d7699ab7042cfce1f8180d458a"><td class="memItemLeft" align="right" valign="top">typedef std::allocator_traits<br class="typebreak"/>
&lt; Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#a756f95d7699ab7042cfce1f8180d458a">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a756f95d7699ab7042cfce1f8180d458a">pointer</a></td></tr>
<tr class="memdesc:a756f95d7699ab7042cfce1f8180d458a"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell pointer type  <a href="#a756f95d7699ab7042cfce1f8180d458a">More...</a><br/></td></tr>
<tr class="separator:a756f95d7699ab7042cfce1f8180d458a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bea65a1cd741917a39d8747f3ecc90"><td class="memItemLeft" align="right" valign="top">typedef std::allocator_traits<br class="typebreak"/>
&lt; Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#ac8bea65a1cd741917a39d8747f3ecc90">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#ac8bea65a1cd741917a39d8747f3ecc90">const_pointer</a></td></tr>
<tr class="memdesc:ac8bea65a1cd741917a39d8747f3ecc90"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell const pointer type  <a href="#ac8bea65a1cd741917a39d8747f3ecc90">More...</a><br/></td></tr>
<tr class="separator:ac8bea65a1cd741917a39d8747f3ecc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e12110faad1f3bb2d7cf62f18382843"><td class="memItemLeft" align="right" valign="top">typedef Alloc::reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a7e12110faad1f3bb2d7cf62f18382843">reference</a></td></tr>
<tr class="memdesc:a7e12110faad1f3bb2d7cf62f18382843"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell reference type  <a href="#a7e12110faad1f3bb2d7cf62f18382843">More...</a><br/></td></tr>
<tr class="separator:a7e12110faad1f3bb2d7cf62f18382843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0b509678ac25148b9dace46af87d1f"><td class="memItemLeft" align="right" valign="top">typedef Alloc::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a7b0b509678ac25148b9dace46af87d1f">const_reference</a></td></tr>
<tr class="memdesc:a7b0b509678ac25148b9dace46af87d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell const reference type  <a href="#a7b0b509678ac25148b9dace46af87d1f">More...</a><br/></td></tr>
<tr class="separator:a7b0b509678ac25148b9dace46af87d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a95c1a078e5a50d7bd00f0b21c3903"><td class="memItemLeft" align="right" valign="top">typedef Alloc::pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a15a95c1a078e5a50d7bd00f0b21c3903">pointer</a></td></tr>
<tr class="memdesc:a15a95c1a078e5a50d7bd00f0b21c3903"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell pointer type  <a href="#a15a95c1a078e5a50d7bd00f0b21c3903">More...</a><br/></td></tr>
<tr class="separator:a15a95c1a078e5a50d7bd00f0b21c3903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14614ba6b9f01b1a42759469f6e541c"><td class="memItemLeft" align="right" valign="top">typedef Alloc::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#ac14614ba6b9f01b1a42759469f6e541c">const_pointer</a></td></tr>
<tr class="memdesc:ac14614ba6b9f01b1a42759469f6e541c"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell const pointer type  <a href="#ac14614ba6b9f01b1a42759469f6e541c">More...</a><br/></td></tr>
<tr class="separator:ac14614ba6b9f01b1a42759469f6e541c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3520e150168f356d5e37cfc3053936"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classecuda_1_1sequence__view.html">sequence_view</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1striding__ptr.html">striding_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1padded__ptr.html">padded_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1cube.html#a756f95d7699ab7042cfce1f8180d458a">pointer</a>, 1 &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a7b3520e150168f356d5e37cfc3053936">row_type</a></td></tr>
<tr class="memdesc:a7b3520e150168f356d5e37cfc3053936"><td class="mdescLeft">&#160;</td><td class="mdescRight">cube row type  <a href="#a7b3520e150168f356d5e37cfc3053936">More...</a><br/></td></tr>
<tr class="separator:a7b3520e150168f356d5e37cfc3053936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b64cbec179e0349ea8488c6fa4d5c0e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classecuda_1_1sequence__view.html">sequence_view</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1striding__ptr.html">striding_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1padded__ptr.html">padded_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1cube.html#a756f95d7699ab7042cfce1f8180d458a">pointer</a>, 1 &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a4b64cbec179e0349ea8488c6fa4d5c0e">column_type</a></td></tr>
<tr class="memdesc:a4b64cbec179e0349ea8488c6fa4d5c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">cube column type  <a href="#a4b64cbec179e0349ea8488c6fa4d5c0e">More...</a><br/></td></tr>
<tr class="separator:a4b64cbec179e0349ea8488c6fa4d5c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e22368e7920b81f3065dd06ba5c5ea3"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classecuda_1_1contiguous__sequence__view.html">contiguous_sequence_view</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a7e22368e7920b81f3065dd06ba5c5ea3">depth_type</a></td></tr>
<tr class="memdesc:a7e22368e7920b81f3065dd06ba5c5ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">cube depth type  <a href="#a7e22368e7920b81f3065dd06ba5c5ea3">More...</a><br/></td></tr>
<tr class="separator:a7e22368e7920b81f3065dd06ba5c5ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc9d96b2a9d9f50c1b3a010ca7e8d84"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classecuda_1_1sequence__view.html">sequence_view</a>&lt; const <br class="typebreak"/>
<a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1striding__ptr.html">striding_ptr</a><br class="typebreak"/>
&lt; const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1padded__ptr.html">padded_ptr</a><br class="typebreak"/>
&lt; const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <br class="typebreak"/>
<a class="el" href="classecuda_1_1cube.html#ac8bea65a1cd741917a39d8747f3ecc90">const_pointer</a>, 1 &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a6cc9d96b2a9d9f50c1b3a010ca7e8d84">const_row_type</a></td></tr>
<tr class="memdesc:a6cc9d96b2a9d9f50c1b3a010ca7e8d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">const cube row type  <a href="#a6cc9d96b2a9d9f50c1b3a010ca7e8d84">More...</a><br/></td></tr>
<tr class="separator:a6cc9d96b2a9d9f50c1b3a010ca7e8d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18450869c816e907bc1894a80be1585d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classecuda_1_1sequence__view.html">sequence_view</a>&lt; const <br class="typebreak"/>
<a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1striding__ptr.html">striding_ptr</a><br class="typebreak"/>
&lt; const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1padded__ptr.html">padded_ptr</a><br class="typebreak"/>
&lt; const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <br class="typebreak"/>
<a class="el" href="classecuda_1_1cube.html#ac8bea65a1cd741917a39d8747f3ecc90">const_pointer</a>, 1 &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a18450869c816e907bc1894a80be1585d">const_column_type</a></td></tr>
<tr class="memdesc:a18450869c816e907bc1894a80be1585d"><td class="mdescLeft">&#160;</td><td class="mdescRight">const cube column type  <a href="#a18450869c816e907bc1894a80be1585d">More...</a><br/></td></tr>
<tr class="separator:a18450869c816e907bc1894a80be1585d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d86ebc98056b2b09e8d8a7196e879e8"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classecuda_1_1contiguous__sequence__view.html">contiguous_sequence_view</a><br class="typebreak"/>
&lt; const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a1d86ebc98056b2b09e8d8a7196e879e8">const_depth_type</a></td></tr>
<tr class="memdesc:a1d86ebc98056b2b09e8d8a7196e879e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">const cube depth type  <a href="#a1d86ebc98056b2b09e8d8a7196e879e8">More...</a><br/></td></tr>
<tr class="separator:a1d86ebc98056b2b09e8d8a7196e879e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad814d2bd72552fee50cb6ba5c0b53f16"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classecuda_1_1matrix__view.html">matrix_view</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1striding__ptr.html">striding_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1padded__ptr.html">padded_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1cube.html#a756f95d7699ab7042cfce1f8180d458a">pointer</a>, 1 &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#ad814d2bd72552fee50cb6ba5c0b53f16">slice_xy_type</a></td></tr>
<tr class="memdesc:ad814d2bd72552fee50cb6ba5c0b53f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">cube xy-slice type  <a href="#ad814d2bd72552fee50cb6ba5c0b53f16">More...</a><br/></td></tr>
<tr class="separator:ad814d2bd72552fee50cb6ba5c0b53f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fc6d988b7e624c0d69a567b4c7693e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classecuda_1_1contiguous__matrix__view.html">contiguous_matrix_view</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a44fc6d988b7e624c0d69a567b4c7693e">slice_xz_type</a></td></tr>
<tr class="memdesc:a44fc6d988b7e624c0d69a567b4c7693e"><td class="mdescLeft">&#160;</td><td class="mdescRight">cube xz-slice type  <a href="#a44fc6d988b7e624c0d69a567b4c7693e">More...</a><br/></td></tr>
<tr class="separator:a44fc6d988b7e624c0d69a567b4c7693e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1f21cec2ee81d4a636dcc991dc4708"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classecuda_1_1contiguous__matrix__view.html">contiguous_matrix_view</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#abd1f21cec2ee81d4a636dcc991dc4708">slice_yz_type</a></td></tr>
<tr class="memdesc:abd1f21cec2ee81d4a636dcc991dc4708"><td class="mdescLeft">&#160;</td><td class="mdescRight">cube yz-slice type  <a href="#abd1f21cec2ee81d4a636dcc991dc4708">More...</a><br/></td></tr>
<tr class="separator:abd1f21cec2ee81d4a636dcc991dc4708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472facf4366cc02ea057f42488d376be"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classecuda_1_1matrix__view.html">matrix_view</a>&lt; const <br class="typebreak"/>
<a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1striding__ptr.html">striding_ptr</a><br class="typebreak"/>
&lt; const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1padded__ptr.html">padded_ptr</a><br class="typebreak"/>
&lt; const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <br class="typebreak"/>
<a class="el" href="classecuda_1_1cube.html#ac8bea65a1cd741917a39d8747f3ecc90">const_pointer</a>, 1 &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a472facf4366cc02ea057f42488d376be">const_slice_xy_type</a></td></tr>
<tr class="memdesc:a472facf4366cc02ea057f42488d376be"><td class="mdescLeft">&#160;</td><td class="mdescRight">const cube xy-slice type  <a href="#a472facf4366cc02ea057f42488d376be">More...</a><br/></td></tr>
<tr class="separator:a472facf4366cc02ea057f42488d376be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51de63c9d384b9bee551c8e968068bc1"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classecuda_1_1contiguous__matrix__view.html">contiguous_matrix_view</a><br class="typebreak"/>
&lt; const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a51de63c9d384b9bee551c8e968068bc1">const_slice_xz_type</a></td></tr>
<tr class="memdesc:a51de63c9d384b9bee551c8e968068bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">const cube xz-slice type  <a href="#a51de63c9d384b9bee551c8e968068bc1">More...</a><br/></td></tr>
<tr class="separator:a51de63c9d384b9bee551c8e968068bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec37bcb890dc91045cb46925428f6c8d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classecuda_1_1contiguous__matrix__view.html">contiguous_matrix_view</a><br class="typebreak"/>
&lt; const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#aec37bcb890dc91045cb46925428f6c8d">const_slice_yz_type</a></td></tr>
<tr class="memdesc:aec37bcb890dc91045cb46925428f6c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">const cube yz-slice type  <a href="#aec37bcb890dc91045cb46925428f6c8d">More...</a><br/></td></tr>
<tr class="separator:aec37bcb890dc91045cb46925428f6c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30dd3c20d6d80da6fb989da2b6c5ddfd"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classecuda_1_1device__iterator.html">device_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1padded__ptr.html">padded_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1cube.html#a756f95d7699ab7042cfce1f8180d458a">pointer</a>, 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a30dd3c20d6d80da6fb989da2b6c5ddfd">iterator</a></td></tr>
<tr class="memdesc:a30dd3c20d6d80da6fb989da2b6c5ddfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator type  <a href="#a30dd3c20d6d80da6fb989da2b6c5ddfd">More...</a><br/></td></tr>
<tr class="separator:a30dd3c20d6d80da6fb989da2b6c5ddfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f0bc799d53f83d07c491d3d0715a0e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classecuda_1_1device__iterator.html">device_iterator</a>&lt; const <br class="typebreak"/>
<a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1padded__ptr.html">padded_ptr</a>&lt; const <br class="typebreak"/>
<a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1cube.html#ac8bea65a1cd741917a39d8747f3ecc90">const_pointer</a>, 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a77f0bc799d53f83d07c491d3d0715a0e">const_iterator</a></td></tr>
<tr class="memdesc:a77f0bc799d53f83d07c491d3d0715a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">const iterator type  <a href="#a77f0bc799d53f83d07c491d3d0715a0e">More...</a><br/></td></tr>
<tr class="separator:a77f0bc799d53f83d07c491d3d0715a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cf00ae6fc0b0d63beb56c7269f07f8"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classecuda_1_1reverse__device__iterator.html">reverse_device_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1cube.html#a30dd3c20d6d80da6fb989da2b6c5ddfd">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a80cf00ae6fc0b0d63beb56c7269f07f8">reverse_iterator</a></td></tr>
<tr class="memdesc:a80cf00ae6fc0b0d63beb56c7269f07f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">reverse iterator type  <a href="#a80cf00ae6fc0b0d63beb56c7269f07f8">More...</a><br/></td></tr>
<tr class="separator:a80cf00ae6fc0b0d63beb56c7269f07f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed231c16fab0956acac9d32b990d6939"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classecuda_1_1reverse__device__iterator.html">reverse_device_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1cube.html#a77f0bc799d53f83d07c491d3d0715a0e">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#aed231c16fab0956acac9d32b990d6939">const_reverse_iterator</a></td></tr>
<tr class="memdesc:aed231c16fab0956acac9d32b990d6939"><td class="mdescLeft">&#160;</td><td class="mdescRight">const reverse iterator type  <a href="#aed231c16fab0956acac9d32b990d6939">More...</a><br/></td></tr>
<tr class="separator:aed231c16fab0956acac9d32b990d6939"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a22c5e980d9568b3dd76c3aa394b27b3d"><td class="memItemLeft" align="right" valign="top">HOST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a22c5e980d9568b3dd76c3aa394b27b3d">cube</a> (const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> numberRows=0, const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> numberColumns=0, const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> numberDepths=0, const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a> &amp;value=<a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>(), const Alloc &amp;allocator=Alloc())</td></tr>
<tr class="memdesc:a22c5e980d9568b3dd76c3aa394b27b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a cube with dimensions numberRows x numberColumns x numberDepths filled with copies of elements with value value.  <a href="#a22c5e980d9568b3dd76c3aa394b27b3d">More...</a><br/></td></tr>
<tr class="separator:a22c5e980d9568b3dd76c3aa394b27b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4514c0768e96473e97234ed9da779e"><td class="memItemLeft" align="right" valign="top">HOST DEVICE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#aed4514c0768e96473e97234ed9da779e">cube</a> (const <a class="el" href="classecuda_1_1cube.html">cube</a>&lt; T &gt; &amp;src)</td></tr>
<tr class="memdesc:aed4514c0768e96473e97234ed9da779e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a cube with a shallow copy of each of the elements in src.  <a href="#aed4514c0768e96473e97234ed9da779e">More...</a><br/></td></tr>
<tr class="separator:aed4514c0768e96473e97234ed9da779e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b01b8b130e000c2e0f9fb820f256728"><td class="memItemLeft" align="right" valign="top">HOST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a0b01b8b130e000c2e0f9fb820f256728">cube</a> (<a class="el" href="classecuda_1_1cube.html">cube</a>&lt; T &gt; &amp;&amp;src)</td></tr>
<tr class="memdesc:a0b01b8b130e000c2e0f9fb820f256728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Constructs the container with the contents of the other using move semantics.  <a href="#a0b01b8b130e000c2e0f9fb820f256728">More...</a><br/></td></tr>
<tr class="separator:a0b01b8b130e000c2e0f9fb820f256728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0579654b140b42cfccd7759b9847f2a1"><td class="memItemLeft" align="right" valign="top">HOST <a class="el" href="classecuda_1_1cube.html#ab9fd5d2090375a276a34100a5ff6b569">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a0579654b140b42cfccd7759b9847f2a1">get_allocator</a> () const </td></tr>
<tr class="memdesc:a0579654b140b42cfccd7759b9847f2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the container.  <a href="#a0579654b140b42cfccd7759b9847f2a1">More...</a><br/></td></tr>
<tr class="separator:a0579654b140b42cfccd7759b9847f2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249f285eacd3debf2762f96c42341eff"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:a249f285eacd3debf2762f96c42341eff"><td class="memTemplItemLeft" align="right" valign="top">HOST DEVICE void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a249f285eacd3debf2762f96c42341eff">assign</a> (Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a249f285eacd3debf2762f96c42341eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the container with copies of those in the range [begin,end).  <a href="#a249f285eacd3debf2762f96c42341eff">More...</a><br/></td></tr>
<tr class="separator:a249f285eacd3debf2762f96c42341eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb41dbfe61d0e7f64246666b0b1deb5e"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#aeb41dbfe61d0e7f64246666b0b1deb5e">number_rows</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:aeb41dbfe61d0e7f64246666b0b1deb5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rows in the container.  <a href="#aeb41dbfe61d0e7f64246666b0b1deb5e">More...</a><br/></td></tr>
<tr class="separator:aeb41dbfe61d0e7f64246666b0b1deb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49089875fb75f213b7c31111ee47c7d6"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a49089875fb75f213b7c31111ee47c7d6">number_columns</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:a49089875fb75f213b7c31111ee47c7d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in the container.  <a href="#a49089875fb75f213b7c31111ee47c7d6">More...</a><br/></td></tr>
<tr class="separator:a49089875fb75f213b7c31111ee47c7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1241af45c113c8d971bb4389ef6abc61"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a1241af45c113c8d971bb4389ef6abc61">number_depths</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:a1241af45c113c8d971bb4389ef6abc61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of depths in the container.  <a href="#a1241af45c113c8d971bb4389ef6abc61">More...</a><br/></td></tr>
<tr class="separator:a1241af45c113c8d971bb4389ef6abc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ce411605ddb8cbb3165f91f6ae6330"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a60ce411605ddb8cbb3165f91f6ae6330">get_pitch</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:a60ce411605ddb8cbb3165f91f6ae6330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pitch of the underlying 2D device memory.  <a href="#a60ce411605ddb8cbb3165f91f6ae6330">More...</a><br/></td></tr>
<tr class="separator:a60ce411605ddb8cbb3165f91f6ae6330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2f66e91a910a41cebb5eb866979a49"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#aac2f66e91a910a41cebb5eb866979a49">size</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:aac2f66e91a910a41cebb5eb866979a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container.  <a href="#aac2f66e91a910a41cebb5eb866979a49">More...</a><br/></td></tr>
<tr class="separator:aac2f66e91a910a41cebb5eb866979a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff1209e705b17b60216a3505aa42ed0"><td class="memItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a4ff1209e705b17b60216a3505aa42ed0">empty</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:a4ff1209e705b17b60216a3505aa42ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container has no elements.  <a href="#a4ff1209e705b17b60216a3505aa42ed0">More...</a><br/></td></tr>
<tr class="separator:a4ff1209e705b17b60216a3505aa42ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef238e8b4803190e9b1ac541d5b822e4"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a756f95d7699ab7042cfce1f8180d458a">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#aef238e8b4803190e9b1ac541d5b822e4">data</a> () __NOEXCEPT__</td></tr>
<tr class="memdesc:aef238e8b4803190e9b1ac541d5b822e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying 2D memory serving as element storage.  <a href="#aef238e8b4803190e9b1ac541d5b822e4">More...</a><br/></td></tr>
<tr class="separator:aef238e8b4803190e9b1ac541d5b822e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed0e5aae7e3b34d571431e7f4f128e5"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#ac8bea65a1cd741917a39d8747f3ecc90">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#afed0e5aae7e3b34d571431e7f4f128e5">data</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:afed0e5aae7e3b34d571431e7f4f128e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying 2D memory serving as element storage.  <a href="#afed0e5aae7e3b34d571431e7f4f128e5">More...</a><br/></td></tr>
<tr class="separator:afed0e5aae7e3b34d571431e7f4f128e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6908d44374a5941fb6db1dc0323a7a23"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a30dd3c20d6d80da6fb989da2b6c5ddfd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a6908d44374a5941fb6db1dc0323a7a23">begin</a> () __NOEXCEPT__</td></tr>
<tr class="memdesc:a6908d44374a5941fb6db1dc0323a7a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="#a6908d44374a5941fb6db1dc0323a7a23">More...</a><br/></td></tr>
<tr class="separator:a6908d44374a5941fb6db1dc0323a7a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7e8fdb5823128df624ce7c46b949c8"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a30dd3c20d6d80da6fb989da2b6c5ddfd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#adb7e8fdb5823128df624ce7c46b949c8">end</a> () __NOEXCEPT__</td></tr>
<tr class="memdesc:adb7e8fdb5823128df624ce7c46b949c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="#adb7e8fdb5823128df624ce7c46b949c8">More...</a><br/></td></tr>
<tr class="separator:adb7e8fdb5823128df624ce7c46b949c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd2246a6646e9d1a60e07a2126eed5e"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a77f0bc799d53f83d07c491d3d0715a0e">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#afbd2246a6646e9d1a60e07a2126eed5e">begin</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:afbd2246a6646e9d1a60e07a2126eed5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="#afbd2246a6646e9d1a60e07a2126eed5e">More...</a><br/></td></tr>
<tr class="separator:afbd2246a6646e9d1a60e07a2126eed5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1afce992287f18d1a2703811b531c6b1"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a77f0bc799d53f83d07c491d3d0715a0e">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a1afce992287f18d1a2703811b531c6b1">end</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:a1afce992287f18d1a2703811b531c6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="#a1afce992287f18d1a2703811b531c6b1">More...</a><br/></td></tr>
<tr class="separator:a1afce992287f18d1a2703811b531c6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4a90295e8099c7adf55c5fe576225a"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a80cf00ae6fc0b0d63beb56c7269f07f8">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a0c4a90295e8099c7adf55c5fe576225a">rbegin</a> () __NOEXCEPT__</td></tr>
<tr class="memdesc:a0c4a90295e8099c7adf55c5fe576225a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed container.  <a href="#a0c4a90295e8099c7adf55c5fe576225a">More...</a><br/></td></tr>
<tr class="separator:a0c4a90295e8099c7adf55c5fe576225a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bbd8716da2be49a7467cc71de78100"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a80cf00ae6fc0b0d63beb56c7269f07f8">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a70bbd8716da2be49a7467cc71de78100">rend</a> () __NOEXCEPT__</td></tr>
<tr class="memdesc:a70bbd8716da2be49a7467cc71de78100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed container.  <a href="#a70bbd8716da2be49a7467cc71de78100">More...</a><br/></td></tr>
<tr class="separator:a70bbd8716da2be49a7467cc71de78100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dcc250efd704802ce1beeb9fc3823de"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#aed231c16fab0956acac9d32b990d6939">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a7dcc250efd704802ce1beeb9fc3823de">rbegin</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:a7dcc250efd704802ce1beeb9fc3823de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed container.  <a href="#a7dcc250efd704802ce1beeb9fc3823de">More...</a><br/></td></tr>
<tr class="separator:a7dcc250efd704802ce1beeb9fc3823de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e67dd94885bd60d9f853102cc6e332"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#aed231c16fab0956acac9d32b990d6939">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a69e67dd94885bd60d9f853102cc6e332">rend</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:a69e67dd94885bd60d9f853102cc6e332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed container.  <a href="#a69e67dd94885bd60d9f853102cc6e332">More...</a><br/></td></tr>
<tr class="separator:a69e67dd94885bd60d9f853102cc6e332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e023c7f68911a4355d20a395905fa5c"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a77f0bc799d53f83d07c491d3d0715a0e">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a6e023c7f68911a4355d20a395905fa5c">cbegin</a> () const __NOEXCEPT__</td></tr>
<tr class="separator:a6e023c7f68911a4355d20a395905fa5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b98c790077d52b4691a1ba368c77f8"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a77f0bc799d53f83d07c491d3d0715a0e">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a37b98c790077d52b4691a1ba368c77f8">cend</a> () const __NOEXCEPT__</td></tr>
<tr class="separator:a37b98c790077d52b4691a1ba368c77f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48af0f0c4f0211b41e09995110006588"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#aed231c16fab0956acac9d32b990d6939">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a48af0f0c4f0211b41e09995110006588">crbegin</a> () __NOEXCEPT__</td></tr>
<tr class="separator:a48af0f0c4f0211b41e09995110006588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf54de02487f0da91cb3eb101a7568f"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#aed231c16fab0956acac9d32b990d6939">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a2cf54de02487f0da91cb3eb101a7568f">crend</a> () __NOEXCEPT__</td></tr>
<tr class="separator:a2cf54de02487f0da91cb3eb101a7568f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13129db8997e5750f4f845b897ab36dc"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a7b3520e150168f356d5e37cfc3053936">row_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a13129db8997e5750f4f845b897ab36dc">get_row</a> (const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> columnIndex, const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> depthIndex)</td></tr>
<tr class="memdesc:a13129db8997e5750f4f845b897ab36dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a view of the sequence of elements forming a single row.  <a href="#a13129db8997e5750f4f845b897ab36dc">More...</a><br/></td></tr>
<tr class="separator:a13129db8997e5750f4f845b897ab36dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c6ab161bbf6e75895e168a578e4ee6"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a4b64cbec179e0349ea8488c6fa4d5c0e">column_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a15c6ab161bbf6e75895e168a578e4ee6">get_column</a> (const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> rowIndex, const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> depthIndex)</td></tr>
<tr class="memdesc:a15c6ab161bbf6e75895e168a578e4ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a view of the sequence of elements forming a single column.  <a href="#a15c6ab161bbf6e75895e168a578e4ee6">More...</a><br/></td></tr>
<tr class="separator:a15c6ab161bbf6e75895e168a578e4ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b1939e5a6c20681e71e7499a661e51"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a7e22368e7920b81f3065dd06ba5c5ea3">depth_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#ac8b1939e5a6c20681e71e7499a661e51">get_depth</a> (const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> rowIndex, const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> columnIndex)</td></tr>
<tr class="memdesc:ac8b1939e5a6c20681e71e7499a661e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a view of the sequence of elements forming a single depth.  <a href="#ac8b1939e5a6c20681e71e7499a661e51">More...</a><br/></td></tr>
<tr class="separator:ac8b1939e5a6c20681e71e7499a661e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeafc558fd3e56ef4c32d00112bd035e"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a6cc9d96b2a9d9f50c1b3a010ca7e8d84">const_row_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#abeafc558fd3e56ef4c32d00112bd035e">get_row</a> (const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> columnIndex, const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> depthIndex) const </td></tr>
<tr class="memdesc:abeafc558fd3e56ef4c32d00112bd035e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a view of the sequence of elements forming a single row.  <a href="#abeafc558fd3e56ef4c32d00112bd035e">More...</a><br/></td></tr>
<tr class="separator:abeafc558fd3e56ef4c32d00112bd035e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0307b4e9dd372d45929ae3602f7b10c"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a18450869c816e907bc1894a80be1585d">const_column_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#aa0307b4e9dd372d45929ae3602f7b10c">get_column</a> (const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> rowIndex, const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> depthIndex) const </td></tr>
<tr class="memdesc:aa0307b4e9dd372d45929ae3602f7b10c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a view of the sequence of elements forming a single column.  <a href="#aa0307b4e9dd372d45929ae3602f7b10c">More...</a><br/></td></tr>
<tr class="separator:aa0307b4e9dd372d45929ae3602f7b10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad002115525042166ffa028f7a0c26c74"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a1d86ebc98056b2b09e8d8a7196e879e8">const_depth_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#ad002115525042166ffa028f7a0c26c74">get_depth</a> (const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> rowIndex, const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> columnIndex) const </td></tr>
<tr class="memdesc:ad002115525042166ffa028f7a0c26c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a view of the sequence of elements forming a single depth.  <a href="#ad002115525042166ffa028f7a0c26c74">More...</a><br/></td></tr>
<tr class="separator:ad002115525042166ffa028f7a0c26c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ab0320a90aa26aff4b83d34416dcea"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#abd1f21cec2ee81d4a636dcc991dc4708">slice_yz_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a32ab0320a90aa26aff4b83d34416dcea">get_yz</a> (const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> rowIndex)</td></tr>
<tr class="memdesc:a32ab0320a90aa26aff4b83d34416dcea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a view of the matrix of elements at a single row.  <a href="#a32ab0320a90aa26aff4b83d34416dcea">More...</a><br/></td></tr>
<tr class="separator:a32ab0320a90aa26aff4b83d34416dcea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e189ceeadbd59198ca9a9a3226ecaf1"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#ad814d2bd72552fee50cb6ba5c0b53f16">slice_xy_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a0e189ceeadbd59198ca9a9a3226ecaf1">get_xy</a> (const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> depthIndex)</td></tr>
<tr class="memdesc:a0e189ceeadbd59198ca9a9a3226ecaf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a view of the matrix of elements at a single depth.  <a href="#a0e189ceeadbd59198ca9a9a3226ecaf1">More...</a><br/></td></tr>
<tr class="separator:a0e189ceeadbd59198ca9a9a3226ecaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1510dbddd3c14156e714067460be0fa1"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a44fc6d988b7e624c0d69a567b4c7693e">slice_xz_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a1510dbddd3c14156e714067460be0fa1">get_xz</a> (const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> columnIndex)</td></tr>
<tr class="memdesc:a1510dbddd3c14156e714067460be0fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a view of the matrix of elements at a single column.  <a href="#a1510dbddd3c14156e714067460be0fa1">More...</a><br/></td></tr>
<tr class="separator:a1510dbddd3c14156e714067460be0fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ffa306ea45b1de6f689706f9348821"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#aec37bcb890dc91045cb46925428f6c8d">const_slice_yz_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a64ffa306ea45b1de6f689706f9348821">get_yz</a> (const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> rowIndex) const </td></tr>
<tr class="memdesc:a64ffa306ea45b1de6f689706f9348821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a view of the matrix of elements at a single row.  <a href="#a64ffa306ea45b1de6f689706f9348821">More...</a><br/></td></tr>
<tr class="separator:a64ffa306ea45b1de6f689706f9348821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253bd714141da6541c54fb9e2cc58d53"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a472facf4366cc02ea057f42488d376be">const_slice_xy_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a253bd714141da6541c54fb9e2cc58d53">get_xy</a> (const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> depthIndex) const </td></tr>
<tr class="memdesc:a253bd714141da6541c54fb9e2cc58d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a view of the matrix of elements at a single depth.  <a href="#a253bd714141da6541c54fb9e2cc58d53">More...</a><br/></td></tr>
<tr class="separator:a253bd714141da6541c54fb9e2cc58d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b0ad90f55f1b3f15ac26f1d558bcb0"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a51de63c9d384b9bee551c8e968068bc1">const_slice_xz_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#ad3b0ad90f55f1b3f15ac26f1d558bcb0">get_xz</a> (const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> columnIndex) const </td></tr>
<tr class="memdesc:ad3b0ad90f55f1b3f15ac26f1d558bcb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a view of the matrix of elements at a single column.  <a href="#ad3b0ad90f55f1b3f15ac26f1d558bcb0">More...</a><br/></td></tr>
<tr class="separator:ad3b0ad90f55f1b3f15ac26f1d558bcb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2097655e3676d048aba4b155d947807"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#abd1f21cec2ee81d4a636dcc991dc4708">slice_yz_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#af2097655e3676d048aba4b155d947807">operator[]</a> (const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> rowIndex)</td></tr>
<tr class="memdesc:af2097655e3676d048aba4b155d947807"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator[](rowIndex) alias for get_yz(rowIndex)  <a href="#af2097655e3676d048aba4b155d947807">More...</a><br/></td></tr>
<tr class="separator:af2097655e3676d048aba4b155d947807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616eb1bcb24195295c145544528bd6b0"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#aec37bcb890dc91045cb46925428f6c8d">const_slice_yz_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a616eb1bcb24195295c145544528bd6b0">operator[]</a> (const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> rowIndex) const </td></tr>
<tr class="memdesc:a616eb1bcb24195295c145544528bd6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator[](rowIndex) alias for get_yz(rowIndex)  <a href="#a616eb1bcb24195295c145544528bd6b0">More...</a><br/></td></tr>
<tr class="separator:a616eb1bcb24195295c145544528bd6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c2b1d7960459e053d2bfaf2b3bb8fd"><td class="memItemLeft" align="right" valign="top">DEVICE T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#af4c2b1d7960459e053d2bfaf2b3bb8fd">at</a> (const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> rowIndex, const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> columnIndex, const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> depthIndex)</td></tr>
<tr class="memdesc:af4c2b1d7960459e053d2bfaf2b3bb8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at the specified cube location.  <a href="#af4c2b1d7960459e053d2bfaf2b3bb8fd">More...</a><br/></td></tr>
<tr class="separator:af4c2b1d7960459e053d2bfaf2b3bb8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9c237642e721fa2d23e4fb1b0678c7"><td class="memItemLeft" align="right" valign="top">DEVICE const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a4f9c237642e721fa2d23e4fb1b0678c7">at</a> (const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> rowIndex, const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> columnIndex, const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> depthIndex) const </td></tr>
<tr class="separator:a4f9c237642e721fa2d23e4fb1b0678c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d5aa4f139d9fb02191bda689f93d4b"><td class="memItemLeft" align="right" valign="top">HOST void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#af2d5aa4f139d9fb02191bda689f93d4b">resize</a> (const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> newNumberRows, const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> newNumberColumns, const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> newNumberDepths, const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a> &amp;value=<a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>())</td></tr>
<tr class="memdesc:af2d5aa4f139d9fb02191bda689f93d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to have dimensions newNumberRows x newNumberColumns x newNumberDepths.  <a href="#af2d5aa4f139d9fb02191bda689f93d4b">More...</a><br/></td></tr>
<tr class="separator:af2d5aa4f139d9fb02191bda689f93d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe6e7362e47412696f20a1076ce1037"><td class="memItemLeft" align="right" valign="top">HOST DEVICE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#afbe6e7362e47412696f20a1076ce1037">fill</a> (const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:afbe6e7362e47412696f20a1076ce1037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a given value to all elements in the container.  <a href="#afbe6e7362e47412696f20a1076ce1037">More...</a><br/></td></tr>
<tr class="separator:afbe6e7362e47412696f20a1076ce1037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5544b0438e825babe46adf4bf8cb6f99"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a5544b0438e825babe46adf4bf8cb6f99"><td class="memTemplItemLeft" align="right" valign="top">HOST Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a5544b0438e825babe46adf4bf8cb6f99">operator&gt;&gt;</a> (Container &amp;dest) const </td></tr>
<tr class="memdesc:a5544b0438e825babe46adf4bf8cb6f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the contents of this device cube to another container.  <a href="#a5544b0438e825babe46adf4bf8cb6f99">More...</a><br/></td></tr>
<tr class="separator:a5544b0438e825babe46adf4bf8cb6f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8f19a639ee02e2cffb34c64d581981"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a0e8f19a639ee02e2cffb34c64d581981"><td class="memTemplItemLeft" align="right" valign="top">HOST <a class="el" href="classecuda_1_1cube.html">cube</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html#a0e8f19a639ee02e2cffb34c64d581981">operator&lt;&lt;</a> (const Container &amp;src)</td></tr>
<tr class="memdesc:a0e8f19a639ee02e2cffb34c64d581981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the contents of another container to this device matrix.  <a href="#a0e8f19a639ee02e2cffb34c64d581981">More...</a><br/></td></tr>
<tr class="separator:a0e8f19a639ee02e2cffb34c64d581981"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt;<br/>
class ecuda::cube&lt; T, Alloc &gt;</h3>

<p>A resizable cube stored in device memory. </p>
<p>A cube is defined as a 3D structure of dimensions rows*columns*depths. The default implementation uses pitched memory where a 2D block of video memory is allocated with width=depths and height=rows*columns. Pitched memory is aligned in a device-dependent manner so that calls to individual elements can be threaded more efficiently (i.e. minimizing the number of read operations required to supply data to multiple threads). Consult the CUDA API documentation for a more verbose explanation.</p>
<p>Methods are prefaced with appropriate keywords to declare them as host and/or device capable. In general: operations requiring memory allocation/deallocation are host only, operations to access the values of specific elements are device only, and copy operations on ranges of data and accessors of general information can be performed on both the host and device.</p>
<p>Memory use can be conceptualized as: </p>
<div class="fragment"><div class="line">            |- depths -|</div>
<div class="line">            |---- pitch ----|</div>
<div class="line">  _     _   +----------+----+</div>
<div class="line"> |     |    |          |xxxx|</div>
<div class="line"> |  columns |          |xxxx| x = allocated but not used, just padding to</div>
<div class="line"> |     |_   |          |xxxx|     enforce an efficient memory alignment</div>
<div class="line">rows        |          |xxxx|</div>
<div class="line"> |          |          |xxxx|</div>
<div class="line"> |          |          |xxxx|</div>
<div class="line"> |_         +----------+----+</div>
</div><!-- fragment --><p>As a result, it is highly desirable for threading to utilize a depth-wise orientation. For example, a good kernel to perform an operation on the elements of a cube might be:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; __global__ <span class="keywordtype">void</span> doCubeOperation( <a class="code" href="classecuda_1_1cube.html">ecuda::cube&lt;T&gt;</a> <a class="code" href="classecuda_1_1cube.html#a22c5e980d9568b3dd76c3aa394b27b3d">cube</a> ) {</div>
<div class="line">   <span class="keyword">const</span> <span class="keywordtype">int</span> dep = blockDim.x*gridDim.x; <span class="comment">// each thread gets a different depth value</span></div>
<div class="line">   <span class="keyword">const</span> <span class="keywordtype">int</span> row = blockIdx.y;</div>
<div class="line">   <span class="keyword">const</span> <span class="keywordtype">int</span> col = blockIdx.z;</div>
<div class="line">   <span class="keywordflow">if</span>( row &lt; cube.<a class="code" href="classecuda_1_1cube.html#aeb41dbfe61d0e7f64246666b0b1deb5e">number_rows</a>() and col &lt; cube.<a class="code" href="classecuda_1_1cube.html#a49089875fb75f213b7c31111ee47c7d6">number_columns</a>() and dep &lt; cube.<a class="code" href="classecuda_1_1cube.html#a1241af45c113c8d971bb4389ef6abc61">number_depths</a>() ) {</div>
<div class="line">      T&amp; value = cube[row][col][dep];</div>
<div class="line">      <span class="comment">// ... do work on value</span></div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p>This could be called from host code like: </p>
<div class="fragment"><div class="line"><a class="code" href="classecuda_1_1cube.html">ecuda::cube&lt;double&gt;</a> <a class="code" href="classecuda_1_1cube.html#a22c5e980d9568b3dd76c3aa394b27b3d">cube</a>( 10, 20, 1000 );</div>
<div class="line"><span class="comment">// ... fill cube with data</span></div>
<div class="line">dim3 grid( 1, 10, 20 ), block( 1000, 1, 1 );</div>
<div class="line">doCubeOperation&lt;&lt;&lt;grid,block&gt;&gt;&gt;( <a class="code" href="classecuda_1_1cube.html#a22c5e980d9568b3dd76c3aa394b27b3d">cube</a> );</div>
</div><!-- fragment --><p>Unfortunately, CUDA solutions are very problem specific, so there is no generally applicable example for specifying how thread blocks should be defined. The size of the cube, hardware limitations, CUDA API limitations, etc. all play a part. For example, the above implementation won't work in earlier versions of CUDA when blockDim.x was limited to 512 (at the time of this writing it was 1024 in the newer versions of CUDA).</p>
<p>Just keep in mind that the depth dimension lies in contiguous memory, the column dimension is contiguous blocks of depth blocks, and the row dimension is contiguous blocks of column blocks; thus, an implementation that aims to have concurrently running threads accessing depth &gt;&gt;&gt; column &gt; row will run much more efficiently. </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00117">117</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ab9fd5d2090375a276a34100a5ff6b569"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Alloc <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#ab9fd5d2090375a276a34100a5ff6b569">allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocator type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00121">121</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4b64cbec179e0349ea8488c6fa4d5c0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1sequence__view.html">sequence_view</a>&lt; <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1striding__ptr.html">striding_ptr</a>&lt; <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1padded__ptr.html">padded_ptr</a>&lt;<a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>,<a class="el" href="classecuda_1_1cube.html#a756f95d7699ab7042cfce1f8180d458a">pointer</a>,1&gt; &gt; &gt; <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#a4b64cbec179e0349ea8488c6fa4d5c0e">column_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cube column type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00137">137</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a18450869c816e907bc1894a80be1585d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1sequence__view.html">sequence_view</a>&lt; const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1striding__ptr.html">striding_ptr</a>&lt; const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1padded__ptr.html">padded_ptr</a>&lt;const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>,<a class="el" href="classecuda_1_1cube.html#ac8bea65a1cd741917a39d8747f3ecc90">const_pointer</a>,1&gt; &gt; &gt; <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#a18450869c816e907bc1894a80be1585d">const_column_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const cube column type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00140">140</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1d86ebc98056b2b09e8d8a7196e879e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1contiguous__sequence__view.html">contiguous_sequence_view</a>&lt;const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>&gt; <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#a1d86ebc98056b2b09e8d8a7196e879e8">const_depth_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const cube depth type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00141">141</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a77f0bc799d53f83d07c491d3d0715a0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1device__iterator.html">device_iterator</a>&lt; const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1padded__ptr.html">padded_ptr</a>&lt;const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>,<a class="el" href="classecuda_1_1cube.html#ac8bea65a1cd741917a39d8747f3ecc90">const_pointer</a>,1&gt; &gt; <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#a77f0bc799d53f83d07c491d3d0715a0e">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const iterator type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00151">151</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac8bea65a1cd741917a39d8747f3ecc90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::allocator_traits&lt;Alloc&gt;::<a class="el" href="classecuda_1_1cube.html#ac8bea65a1cd741917a39d8747f3ecc90">const_pointer</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#ac8bea65a1cd741917a39d8747f3ecc90">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell const pointer type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00128">128</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac14614ba6b9f01b1a42759469f6e541c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Alloc::const_pointer <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#ac8bea65a1cd741917a39d8747f3ecc90">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell const pointer type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00133">133</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a973f3786e01a747ca08be57d5ca75982"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>&amp; <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#a973f3786e01a747ca08be57d5ca75982">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell const reference type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00126">126</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7b0b509678ac25148b9dace46af87d1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Alloc::const_reference <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#a973f3786e01a747ca08be57d5ca75982">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell const reference type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00131">131</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aed231c16fab0956acac9d32b990d6939"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1reverse__device__iterator.html">reverse_device_iterator</a>&lt;<a class="el" href="classecuda_1_1cube.html#a77f0bc799d53f83d07c491d3d0715a0e">const_iterator</a>&gt; <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#aed231c16fab0956acac9d32b990d6939">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const reverse iterator type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00153">153</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6cc9d96b2a9d9f50c1b3a010ca7e8d84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1sequence__view.html">sequence_view</a>&lt; const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1striding__ptr.html">striding_ptr</a>&lt; const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1padded__ptr.html">padded_ptr</a>&lt;const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>,<a class="el" href="classecuda_1_1cube.html#ac8bea65a1cd741917a39d8747f3ecc90">const_pointer</a>,1&gt; &gt; &gt; <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#a6cc9d96b2a9d9f50c1b3a010ca7e8d84">const_row_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const cube row type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00139">139</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a472facf4366cc02ea057f42488d376be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1matrix__view.html">matrix_view</a>&lt; const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1striding__ptr.html">striding_ptr</a>&lt; const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1padded__ptr.html">padded_ptr</a>&lt;const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>,<a class="el" href="classecuda_1_1cube.html#ac8bea65a1cd741917a39d8747f3ecc90">const_pointer</a>,1&gt; &gt; &gt; <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#a472facf4366cc02ea057f42488d376be">const_slice_xy_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const cube xy-slice type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00146">146</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a51de63c9d384b9bee551c8e968068bc1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1contiguous__matrix__view.html">contiguous_matrix_view</a>&lt;const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>&gt; <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#a51de63c9d384b9bee551c8e968068bc1">const_slice_xz_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const cube xz-slice type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00147">147</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aec37bcb890dc91045cb46925428f6c8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1contiguous__matrix__view.html">contiguous_matrix_view</a>&lt;const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>&gt; <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#aec37bcb890dc91045cb46925428f6c8d">const_slice_yz_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const cube yz-slice type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00148">148</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7e22368e7920b81f3065dd06ba5c5ea3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1contiguous__sequence__view.html">contiguous_sequence_view</a>&lt;<a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>&gt; <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#a7e22368e7920b81f3065dd06ba5c5ea3">depth_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cube depth type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00138">138</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5cb7c4e0468ea8e1b261e8b4b55fb010"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::ptrdiff_t <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#a5cb7c4e0468ea8e1b261e8b4b55fb010">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>signed integral type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00123">123</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a30dd3c20d6d80da6fb989da2b6c5ddfd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1device__iterator.html">device_iterator</a>&lt; <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1padded__ptr.html">padded_ptr</a>&lt;<a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>,<a class="el" href="classecuda_1_1cube.html#a756f95d7699ab7042cfce1f8180d458a">pointer</a>,1&gt; &gt; <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#a30dd3c20d6d80da6fb989da2b6c5ddfd">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iterator type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00150">150</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a756f95d7699ab7042cfce1f8180d458a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::allocator_traits&lt;Alloc&gt;::<a class="el" href="classecuda_1_1cube.html#a756f95d7699ab7042cfce1f8180d458a">pointer</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#a756f95d7699ab7042cfce1f8180d458a">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell pointer type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00127">127</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a15a95c1a078e5a50d7bd00f0b21c3903"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Alloc::pointer <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#a756f95d7699ab7042cfce1f8180d458a">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell pointer type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00132">132</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7cb8e15fd3ca600bccddbccdee798ba2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>&amp; <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#a7cb8e15fd3ca600bccddbccdee798ba2">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell reference type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00125">125</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7e12110faad1f3bb2d7cf62f18382843"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Alloc::reference <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#a7cb8e15fd3ca600bccddbccdee798ba2">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell reference type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00130">130</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80cf00ae6fc0b0d63beb56c7269f07f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1reverse__device__iterator.html">reverse_device_iterator</a>&lt;<a class="el" href="classecuda_1_1cube.html#a30dd3c20d6d80da6fb989da2b6c5ddfd">iterator</a>&gt; <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#a80cf00ae6fc0b0d63beb56c7269f07f8">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reverse iterator type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00152">152</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7b3520e150168f356d5e37cfc3053936"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1sequence__view.html">sequence_view</a>&lt; <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1striding__ptr.html">striding_ptr</a>&lt; <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1padded__ptr.html">padded_ptr</a>&lt;<a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>,<a class="el" href="classecuda_1_1cube.html#a756f95d7699ab7042cfce1f8180d458a">pointer</a>,1&gt; &gt; &gt; <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#a7b3520e150168f356d5e37cfc3053936">row_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cube row type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00136">136</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a47447398c7ecbc3693da769c6e24a702"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unsigned integral type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00122">122</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad814d2bd72552fee50cb6ba5c0b53f16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1matrix__view.html">matrix_view</a>&lt; <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1striding__ptr.html">striding_ptr</a>&lt; <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>, <a class="el" href="classecuda_1_1padded__ptr.html">padded_ptr</a>&lt;<a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>,<a class="el" href="classecuda_1_1cube.html#a756f95d7699ab7042cfce1f8180d458a">pointer</a>,1&gt; &gt; &gt; <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#ad814d2bd72552fee50cb6ba5c0b53f16">slice_xy_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cube xy-slice type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00143">143</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a44fc6d988b7e624c0d69a567b4c7693e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1contiguous__matrix__view.html">contiguous_matrix_view</a>&lt;<a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>&gt; <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#a44fc6d988b7e624c0d69a567b4c7693e">slice_xz_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cube xz-slice type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00144">144</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abd1f21cec2ee81d4a636dcc991dc4708"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1contiguous__matrix__view.html">contiguous_matrix_view</a>&lt;<a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>&gt; <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#abd1f21cec2ee81d4a636dcc991dc4708">slice_yz_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cube yz-slice type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00145">145</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a747369f4d695d7e8599613c8ad485d70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell data type </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00120">120</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a22c5e980d9568b3dd76c3aa394b27b3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html">cube</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>numberRows</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>numberColumns</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>numberDepths</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code><a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a cube with dimensions numberRows x numberColumns x numberDepths filled with copies of elements with value value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numberRows</td><td>number of rows (default=0) </td></tr>
    <tr><td class="paramname">numberColumns</td><td>number of columns (default=0) </td></tr>
    <tr><td class="paramname">numberDepths</td><td>number of depths (default=0) </td></tr>
    <tr><td class="paramname">value</td><td>value that cube elements should initially be set to (default=<a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70" title="cell data type ">value_type()</a>) </td></tr>
    <tr><td class="paramname">allocator</td><td>allocator to use for all memory allocations of this container (does not normally need to be specified, by default the internal ecuda pitched memory allocator) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00176">176</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aed4514c0768e96473e97234ed9da779e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html">cube</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html">cube</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a cube with a shallow copy of each of the elements in src. </p>
<p>Be careful to note that a shallow copy means that only the pointer to the device memory that holds the elements is copied in the newly constructed container. This allows containers to be passed-by-value to kernel functions with minimal overhead. If a deep copy of the container is required in host code, use the &lt;&lt; or &gt;&gt; operators, or use iterators. For example:</p>
<div class="fragment"><div class="line"><a class="code" href="classecuda_1_1cube.html">ecuda::cube&lt;int&gt;</a> <a class="code" href="classecuda_1_1cube.html#a22c5e980d9568b3dd76c3aa394b27b3d">cube</a>( 5, 10, 15 ); <span class="comment">// create a cube of dimensions 5x10x15 filled with zeroes</span></div>
<div class="line"><a class="code" href="classecuda_1_1cube.html">ecuda::cube&lt;int&gt;</a> newCube( cube ); <span class="comment">// shallow copy (changes to newCube reflected in cube)</span></div>
<div class="line"><a class="code" href="classecuda_1_1cube.html">ecuda::cube&lt;int&gt;</a> newCube( 5, 10, 15 );</div>
<div class="line">newCube &lt;&lt; <a class="code" href="classecuda_1_1cube.html#a22c5e980d9568b3dd76c3aa394b27b3d">cube</a>; <span class="comment">// deep copy</span></div>
<div class="line">cube &gt;&gt; newCube; <span class="comment">// deep copy</span></div>
<div class="line">newCube.assign( cube.begin(), cube.end() ); <span class="comment">// deep copy</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Another cube object of the same type, whose contents are copied. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00203">203</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0b01b8b130e000c2e0f9fb820f256728"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1cube.html">cube</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1cube.html">cube</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. Constructs the container with the contents of the other using move semantics. </p>
<p>This constructor is only available if the compiler is configured to allow C++11.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00225">225</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a249f285eacd3debf2762f96c42341eff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE void <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents of the container with copies of those in the range [begin,end). </p>
<p>The number of elements in [begin,end) must equal the size of this cube (i.e. rows*columns*depths). In addition, the orientation of the elements is assumed to be ordered depth-&gt;column-&gt;row (the same orientation as the elements stored in this container).</p>
<p>Note that a potentially more clear way of assigning values is to use the <a class="el" href="classecuda_1_1cube.html#ac8b1939e5a6c20681e71e7499a661e51" title="Gets a view of the sequence of elements forming a single depth. ">get_depth()</a> method, which returns a structure that also has an assign() method. For example:</p>
<div class="fragment"><div class="line">estd::cube&lt;int&gt; <a class="code" href="classecuda_1_1cube.html#a22c5e980d9568b3dd76c3aa394b27b3d">cube</a>( 3, 4, 5 ); <span class="comment">// cube of dimension 3x4x5 and filled with zeroes</span></div>
<div class="line">std::vector&lt;int&gt; vec( { 66, 18, 96, 49, 58 } ); <span class="comment">// vector initialized with a C++11 initializer list</span></div>
<div class="line"><span class="keywordflow">for</span>( estd::cube&lt;int&gt;::size_type i = 0; i &lt; cube.number_rows(); ++i )</div>
<div class="line">   <span class="keywordflow">for</span>( estd::cube&lt;int&gt;::size_type j = 0; j &lt; cube.number_columns(); ++j )</div>
<div class="line">      cube[i][j].assign( vec.begin(), vec.end() );</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,last</td><td>the range to copy the elements from </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if number of elements doesn't match the size of the cube </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00273">273</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af4c2b1d7960459e053d2bfaf2b3bb8fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEVICE T&amp; <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>rowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>columnIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>depthIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at the specified cube location. </p>
<p>This method in STL containers like vector is differentiated from operator[] because it includes range checking. In this case, no range checking is performed, but if a thread only accesses a single element, this accessor may be slightly faster. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// host code</span></div>
<div class="line"><a class="code" href="classecuda_1_1cube.html">ecuda::cube&lt;double&gt;</a> deviceCube( 100, 100, 100 );</div>
<div class="line"><span class="comment">// within kernel</span></div>
<div class="line"><span class="keywordtype">double</span>&amp; value = deviceCube.at( 10, 10, 10 ); <span class="comment">// slightly faster</span></div>
<div class="line"><span class="keywordtype">double</span>&amp; value = deviceCube[10][10][10]; <span class="comment">// slightly slower</span></div>
</div><!-- fragment --><p>This is due to the operator[] first creating a YZ-slice view, then the second operator[] creating a view of a single row within the slice, and then finally a third access to a single column within it. Modern compilers can be pretty crafty at seeing through these these types of situations, and it may resolve to an identical set of instructions, but the direct accessor method is included here for completeness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowIndex</td><td>index of the row to get an element reference from </td></tr>
    <tr><td class="paramname">columnIndex</td><td>index of the column to get an element reference from </td></tr>
    <tr><td class="paramname">depthIndex</td><td>index of the depth to get an element reference from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the specified element </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00632">632</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f9c237642e721fa2d23e4fb1b0678c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEVICE const T&amp; <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>rowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>columnIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>depthIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method in STL containers like vector is differentiated from operator[] because it includes range checking. In this case, no range checking is performed, but if a thread only accesses a single element, this accessor may be slightly faster. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// host code</span></div>
<div class="line"><a class="code" href="classecuda_1_1cube.html">ecuda::cube&lt;double&gt;</a> deviceCube( 100, 100, 100 );</div>
<div class="line"><span class="comment">// within kernel</span></div>
<div class="line"><span class="keywordtype">double</span>&amp; value = deviceCube.at( 10, 10, 10 ); <span class="comment">// slightly faster</span></div>
<div class="line"><span class="keywordtype">double</span>&amp; value = deviceCube[10][10][10]; <span class="comment">// slightly slower</span></div>
</div><!-- fragment --><p>This is due to the operator[] first creating a YZ-slice view, then the second operator[] creating a view of a single row within the slice, and then finally a third access to a single column within it. Modern compilers can be pretty crafty at seeing through these these types of situations, and it may resolve to an identical set of instructions, but the direct accessor method is included here for completeness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowIndex</td><td>index of the row to get an element reference from </td></tr>
    <tr><td class="paramname">columnIndex</td><td>index of the column to get an element reference from </td></tr>
    <tr><td class="paramname">depthIndex</td><td>index of the depth to get an element reference from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the specified element </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00660">660</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6908d44374a5941fb6db1dc0323a7a23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a30dd3c20d6d80da6fb989da2b6c5ddfd">iterator</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classecuda_1_1cube.html#adb7e8fdb5823128df624ce7c46b949c8" title="Returns an iterator to the element following the last element of the container. ">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00356">356</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afbd2246a6646e9d1a60e07a2126eed5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a77f0bc799d53f83d07c491d3d0715a0e">const_iterator</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classecuda_1_1cube.html#adb7e8fdb5823128df624ce7c46b949c8" title="Returns an iterator to the element following the last element of the container. ">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00374">374</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6e023c7f68911a4355d20a395905fa5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a77f0bc799d53f83d07c491d3d0715a0e">const_iterator</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00424">424</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a37b98c790077d52b4691a1ba368c77f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a77f0bc799d53f83d07c491d3d0715a0e">const_iterator</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00425">425</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a48af0f0c4f0211b41e09995110006588"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#aed231c16fab0956acac9d32b990d6939">const_reverse_iterator</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00426">426</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2cf54de02487f0da91cb3eb101a7568f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#aed231c16fab0956acac9d32b990d6939">const_reverse_iterator</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00427">427</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef238e8b4803190e9b1ac541d5b822e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a756f95d7699ab7042cfce1f8180d458a">pointer</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying 2D memory serving as element storage. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00340">340</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afed0e5aae7e3b34d571431e7f4f128e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#ac8bea65a1cd741917a39d8747f3ecc90">const_pointer</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying 2D memory serving as element storage. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00347">347</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4ff1209e705b17b60216a3505aa42ed0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container has no elements. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the container is empty, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00333">333</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adb7e8fdb5823128df624ce7c46b949c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a30dd3c20d6d80da6fb989da2b6c5ddfd">iterator</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>
<p>The element acts as a placeholder; attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00365">365</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1afce992287f18d1a2703811b531c6b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a77f0bc799d53f83d07c491d3d0715a0e">const_iterator</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>
<p>The element acts as a placeholder; attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00383">383</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afbe6e7362e47412696f20a1076ce1037"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE void <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a given value to all elements in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to assign to the elements </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00700">700</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0579654b140b42cfccd7759b9847f2a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST <a class="el" href="classecuda_1_1cube.html#ab9fd5d2090375a276a34100a5ff6b569">allocator_type</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator associated with the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The associated allocator. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00234">234</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a15c6ab161bbf6e75895e168a578e4ee6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a4b64cbec179e0349ea8488c6fa4d5c0e">column_type</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::get_column </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>rowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>depthIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a view of the sequence of elements forming a single column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowIndex</td><td>the row to fix the view on </td></tr>
    <tr><td class="paramname">depthIndex</td><td>the depth to fix the view on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A view of the elements with the specified row and depth indices. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00451">451</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa0307b4e9dd372d45929ae3602f7b10c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a18450869c816e907bc1894a80be1585d">const_column_type</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::get_column </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>rowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>depthIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a view of the sequence of elements forming a single column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowIndex</td><td>the row to fix the view on </td></tr>
    <tr><td class="paramname">depthIndex</td><td>the depth to fix the view on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A view of the elements with the specified row and depth indices. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00491">491</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac8b1939e5a6c20681e71e7499a661e51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a7e22368e7920b81f3065dd06ba5c5ea3">depth_type</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::get_depth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>rowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>columnIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a view of the sequence of elements forming a single depth. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowIndex</td><td>the row to fix the view on </td></tr>
    <tr><td class="paramname">columnIndex</td><td>the column to fix the view on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A view of the elements with the specified row and column indices. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00465">465</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad002115525042166ffa028f7a0c26c74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a1d86ebc98056b2b09e8d8a7196e879e8">const_depth_type</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::get_depth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>rowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>columnIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a view of the sequence of elements forming a single depth. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowIndex</td><td>the row to fix the view on </td></tr>
    <tr><td class="paramname">columnIndex</td><td>the column to fix the view on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A view of the elements with the specified row and column indices. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00505">505</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a60ce411605ddb8cbb3165f91f6ae6330"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::get_pitch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the pitch of the underlying 2D device memory. </p>
<dl class="section return"><dt>Returns</dt><dd>The pitch (in bytes) of the underlying 2D device memory. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00318">318</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a13129db8997e5750f4f845b897ab36dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a7b3520e150168f356d5e37cfc3053936">row_type</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::get_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>columnIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>depthIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a view of the sequence of elements forming a single row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">columnIndex</td><td>the column to fix the view on </td></tr>
    <tr><td class="paramname">depthIndex</td><td>the depth to fix the view on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A view of the elements with the specified column and depth indices. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00437">437</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abeafc558fd3e56ef4c32d00112bd035e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a6cc9d96b2a9d9f50c1b3a010ca7e8d84">const_row_type</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::get_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>columnIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>depthIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a view of the sequence of elements forming a single row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">columnIndex</td><td>the column to fix the view on </td></tr>
    <tr><td class="paramname">depthIndex</td><td>the depth to fix the view on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A view of the elements with the specified column and depth indices. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00477">477</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0e189ceeadbd59198ca9a9a3226ecaf1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#ad814d2bd72552fee50cb6ba5c0b53f16">slice_xy_type</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::get_xy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>depthIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a view of the matrix of elements at a single depth. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthIndex</td><td>the depth to fix the view on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A view of the elements at the specified depth. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00530">530</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a253bd714141da6541c54fb9e2cc58d53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a472facf4366cc02ea057f42488d376be">const_slice_xy_type</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::get_xy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>depthIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a view of the matrix of elements at a single depth. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depthIndex</td><td>the depth to fix the view on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A view of the elements at the specified depth. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00570">570</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1510dbddd3c14156e714067460be0fa1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a44fc6d988b7e624c0d69a567b4c7693e">slice_xz_type</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::get_xz </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>columnIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a view of the matrix of elements at a single column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">columnIndex</td><td>the column to fix the view on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A view of the elements at the specified column. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00543">543</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad3b0ad90f55f1b3f15ac26f1d558bcb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a51de63c9d384b9bee551c8e968068bc1">const_slice_xz_type</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::get_xz </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>columnIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a view of the matrix of elements at a single column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">columnIndex</td><td>the column to fix the view on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A view of the elements at the specified column. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00583">583</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a32ab0320a90aa26aff4b83d34416dcea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#abd1f21cec2ee81d4a636dcc991dc4708">slice_yz_type</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::get_yz </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>rowIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a view of the matrix of elements at a single row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowIndex</td><td>the row to fix the view on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A view of the elements at the specified row. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00516">516</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a64ffa306ea45b1de6f689706f9348821"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#aec37bcb890dc91045cb46925428f6c8d">const_slice_yz_type</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::get_yz </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>rowIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a view of the matrix of elements at a single row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowIndex</td><td>the row to fix the view on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A view of the elements at the specified row. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00556">556</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a49089875fb75f213b7c31111ee47c7d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::number_columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of columns in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of columns in the container. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00304">304</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1241af45c113c8d971bb4389ef6abc61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::number_depths </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of depths in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of depths in the container. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00311">311</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeb41dbfe61d0e7f64246666b0b1deb5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::number_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of rows in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of rows in the container. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00297">297</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0e8f19a639ee02e2cffb34c64d581981"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST <a class="el" href="classecuda_1_1cube.html">cube</a>&amp; <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the contents of another container to this device matrix. </p>
<p>The size of the container must match the number of elements in this cube (<a class="el" href="classecuda_1_1cube.html#aeb41dbfe61d0e7f64246666b0b1deb5e" title="Returns the number of rows in the container. ">number_rows()</a>*number_columns()*number_depths()). The source container is assumed to be in row,column-major linear form (all depths of the first column of the first row, then the second column of the first row, ...).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>container to copy data from </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if number of elements in src does not match the size of this matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00782">782</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5544b0438e825babe46adf4bf8cb6f99"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST Container&amp; <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the contents of this device cube to another container. </p>
<p>The cube is converted into a row,column-major linearized form (all depths of the first column of the first row, then the second column of the first row, ...). </p>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00758">758</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af2097655e3676d048aba4b155d947807"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#abd1f21cec2ee81d4a636dcc991dc4708">slice_yz_type</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>rowIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator[](rowIndex) alias for get_yz(rowIndex) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowIndex</td><td>index of the YZ-slice to isolate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>view object for the specified row </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00595">595</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a616eb1bcb24195295c145544528bd6b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#aec37bcb890dc91045cb46925428f6c8d">const_slice_yz_type</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>rowIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator[](rowIndex) alias for get_yz(rowIndex) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowIndex</td><td>index of the YZ-slice to isolate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>view object for the specified row </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00602">602</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0c4a90295e8099c7adf55c5fe576225a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a80cf00ae6fc0b0d63beb56c7269f07f8">reverse_iterator</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed container. </p>
<p>It corresponds to the last element of the non-reversed container.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00392">392</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7dcc250efd704802ce1beeb9fc3823de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#aed231c16fab0956acac9d32b990d6939">const_reverse_iterator</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed container. </p>
<p>It corresponds to the last element of the non-reversed container.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00411">411</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a70bbd8716da2be49a7467cc71de78100"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a80cf00ae6fc0b0d63beb56c7269f07f8">reverse_iterator</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed container. </p>
<p>It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00402">402</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a69e67dd94885bd60d9f853102cc6e332"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#aed231c16fab0956acac9d32b990d6939">const_reverse_iterator</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed container. </p>
<p>It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00421">421</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af2d5aa4f139d9fb02191bda689f93d4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST void <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>newNumberRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>newNumberColumns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a>&#160;</td>
          <td class="paramname"><em>newNumberDepths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code><a class="el" href="classecuda_1_1cube.html#a747369f4d695d7e8599613c8ad485d70">value_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to have dimensions newNumberRows x newNumberColumns x newNumberDepths. </p>
<p>If the current size is greater in any dimension, the existing elements are truncated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newNumberRows</td><td>new number of rows </td></tr>
    <tr><td class="paramname">newNumberColumns</td><td>new number of columns </td></tr>
    <tr><td class="paramname">newNumberDepths</td><td>new number of depths </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize the new elements with (default constructed if not specified) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00672">672</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aac2f66e91a910a41cebb5eb866979a49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1cube.html#a47447398c7ecbc3693da769c6e24a702">size_type</a> <a class="el" href="classecuda_1_1cube.html">ecuda::cube</a>&lt; T, Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the container. </p>
<p>This is the rows x columns x depths.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container. </dd></dl>

<p>Definition at line <a class="el" href="cube_8hpp_source.html#l00327">327</a> of file <a class="el" href="cube_8hpp_source.html">cube.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/ecuda/<a class="el" href="cube_8hpp_source.html">cube.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 17 2015 00:25:39 for Extended CUDA Library (ecuda) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
