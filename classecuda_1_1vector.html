<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Extended CUDA Library (ecuda): ecuda::vector&lt; T, Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Extended CUDA Library (ecuda)
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceecuda.html">ecuda</a></li><li class="navelem"><a class="el" href="classecuda_1_1vector.html">vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classecuda_1_1vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ecuda::vector&lt; T, Alloc &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A resizable vector stored in device memory.  
 <a href="classecuda_1_1vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vector_8hpp_source.html">vector.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae56bbcd61835f36a582c289667f9ac00"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a></td></tr>
<tr class="memdesc:ae56bbcd61835f36a582c289667f9ac00"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell data type  <a href="#ae56bbcd61835f36a582c289667f9ac00">More...</a><br/></td></tr>
<tr class="separator:ae56bbcd61835f36a582c289667f9ac00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b94fcad8e25670029d3892edc53f124"><td class="memItemLeft" align="right" valign="top">typedef Alloc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a7b94fcad8e25670029d3892edc53f124">allocator_type</a></td></tr>
<tr class="memdesc:a7b94fcad8e25670029d3892edc53f124"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type  <a href="#a7b94fcad8e25670029d3892edc53f124">More...</a><br/></td></tr>
<tr class="separator:a7b94fcad8e25670029d3892edc53f124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4360b100af6758b359fe4d62a5399d1f"><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a4360b100af6758b359fe4d62a5399d1f">size_type</a></td></tr>
<tr class="memdesc:a4360b100af6758b359fe4d62a5399d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned integral type  <a href="#a4360b100af6758b359fe4d62a5399d1f">More...</a><br/></td></tr>
<tr class="separator:a4360b100af6758b359fe4d62a5399d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c8e2dd45f49db350ceca8e3e63e78a"><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a76c8e2dd45f49db350ceca8e3e63e78a">difference_type</a></td></tr>
<tr class="memdesc:a76c8e2dd45f49db350ceca8e3e63e78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed integral type  <a href="#a76c8e2dd45f49db350ceca8e3e63e78a">More...</a><br/></td></tr>
<tr class="separator:a76c8e2dd45f49db350ceca8e3e63e78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf161ce7503d2bb75c329a71e6d4413e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#adf161ce7503d2bb75c329a71e6d4413e">reference</a></td></tr>
<tr class="memdesc:adf161ce7503d2bb75c329a71e6d4413e"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell reference type  <a href="#adf161ce7503d2bb75c329a71e6d4413e">More...</a><br/></td></tr>
<tr class="separator:adf161ce7503d2bb75c329a71e6d4413e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07305c387f4c2134aaaed0d99ce87a03"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a07305c387f4c2134aaaed0d99ce87a03">const_reference</a></td></tr>
<tr class="memdesc:a07305c387f4c2134aaaed0d99ce87a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell const reference type  <a href="#a07305c387f4c2134aaaed0d99ce87a03">More...</a><br/></td></tr>
<tr class="separator:a07305c387f4c2134aaaed0d99ce87a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf382998902613a84f0877c2b07a740"><td class="memItemLeft" align="right" valign="top">typedef std::allocator_traits<br class="typebreak"/>
&lt; Alloc &gt;::<a class="el" href="classecuda_1_1vector.html#a5bf382998902613a84f0877c2b07a740">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a5bf382998902613a84f0877c2b07a740">pointer</a></td></tr>
<tr class="memdesc:a5bf382998902613a84f0877c2b07a740"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell pointer type  <a href="#a5bf382998902613a84f0877c2b07a740">More...</a><br/></td></tr>
<tr class="separator:a5bf382998902613a84f0877c2b07a740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530ade1a42cac82fab8019c2e39dd49f"><td class="memItemLeft" align="right" valign="top">typedef std::allocator_traits<br class="typebreak"/>
&lt; Alloc &gt;::<a class="el" href="classecuda_1_1vector.html#a530ade1a42cac82fab8019c2e39dd49f">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a530ade1a42cac82fab8019c2e39dd49f">const_pointer</a></td></tr>
<tr class="memdesc:a530ade1a42cac82fab8019c2e39dd49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell const pointer type  <a href="#a530ade1a42cac82fab8019c2e39dd49f">More...</a><br/></td></tr>
<tr class="separator:a530ade1a42cac82fab8019c2e39dd49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1bdcdab23fb93bca4230b71518b7d1c"><td class="memItemLeft" align="right" valign="top">typedef Alloc::reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ac1bdcdab23fb93bca4230b71518b7d1c">reference</a></td></tr>
<tr class="memdesc:ac1bdcdab23fb93bca4230b71518b7d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell reference type  <a href="#ac1bdcdab23fb93bca4230b71518b7d1c">More...</a><br/></td></tr>
<tr class="separator:ac1bdcdab23fb93bca4230b71518b7d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf932ab1b8eef2454436ad7d58d61e11"><td class="memItemLeft" align="right" valign="top">typedef Alloc::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#abf932ab1b8eef2454436ad7d58d61e11">const_reference</a></td></tr>
<tr class="memdesc:abf932ab1b8eef2454436ad7d58d61e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell const reference type  <a href="#abf932ab1b8eef2454436ad7d58d61e11">More...</a><br/></td></tr>
<tr class="separator:abf932ab1b8eef2454436ad7d58d61e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7036904e428a9e265d03289c7e460b75"><td class="memItemLeft" align="right" valign="top">typedef Alloc::pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a7036904e428a9e265d03289c7e460b75">pointer</a></td></tr>
<tr class="memdesc:a7036904e428a9e265d03289c7e460b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell pointer type  <a href="#a7036904e428a9e265d03289c7e460b75">More...</a><br/></td></tr>
<tr class="separator:a7036904e428a9e265d03289c7e460b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a30ad87dd687f1e7d23424a95bc2de"><td class="memItemLeft" align="right" valign="top">typedef Alloc::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a29a30ad87dd687f1e7d23424a95bc2de">const_pointer</a></td></tr>
<tr class="memdesc:a29a30ad87dd687f1e7d23424a95bc2de"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell const pointer type  <a href="#a29a30ad87dd687f1e7d23424a95bc2de">More...</a><br/></td></tr>
<tr class="separator:a29a30ad87dd687f1e7d23424a95bc2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6c5f81e617def3d16565716e3ee0cf"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classecuda_1_1contiguous__device__iterator.html">contiguous_device_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#aeb6c5f81e617def3d16565716e3ee0cf">iterator</a></td></tr>
<tr class="memdesc:aeb6c5f81e617def3d16565716e3ee0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator type  <a href="#aeb6c5f81e617def3d16565716e3ee0cf">More...</a><br/></td></tr>
<tr class="separator:aeb6c5f81e617def3d16565716e3ee0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49059fdbbb05ba52a1ff476945d6db6b"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classecuda_1_1contiguous__device__iterator.html">contiguous_device_iterator</a><br class="typebreak"/>
&lt; const <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a49059fdbbb05ba52a1ff476945d6db6b">const_iterator</a></td></tr>
<tr class="memdesc:a49059fdbbb05ba52a1ff476945d6db6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">const iterator type  <a href="#a49059fdbbb05ba52a1ff476945d6db6b">More...</a><br/></td></tr>
<tr class="separator:a49059fdbbb05ba52a1ff476945d6db6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0556d788dc27375aa65398d8731f437"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classecuda_1_1reverse__device__iterator.html">reverse_device_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1vector.html#aeb6c5f81e617def3d16565716e3ee0cf">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ae0556d788dc27375aa65398d8731f437">reverse_iterator</a></td></tr>
<tr class="memdesc:ae0556d788dc27375aa65398d8731f437"><td class="mdescLeft">&#160;</td><td class="mdescRight">reverse iterator type  <a href="#ae0556d788dc27375aa65398d8731f437">More...</a><br/></td></tr>
<tr class="separator:ae0556d788dc27375aa65398d8731f437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0540b79731122af43dc10e96f28624"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classecuda_1_1reverse__device__iterator.html">reverse_device_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1vector.html#a49059fdbbb05ba52a1ff476945d6db6b">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#aac0540b79731122af43dc10e96f28624">const_reverse_iterator</a></td></tr>
<tr class="memdesc:aac0540b79731122af43dc10e96f28624"><td class="mdescLeft">&#160;</td><td class="mdescRight">const reverse iterator type  <a href="#aac0540b79731122af43dc10e96f28624">More...</a><br/></td></tr>
<tr class="separator:aac0540b79731122af43dc10e96f28624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e6768e9cc1d5f7f334afd76bb3ea16"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classecuda_1_1contiguous__device__iterator.html">contiguous_device_iterator</a><br class="typebreak"/>
&lt; const <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a55e6768e9cc1d5f7f334afd76bb3ea16">ContiguousDeviceIterator</a></td></tr>
<tr class="separator:a55e6768e9cc1d5f7f334afd76bb3ea16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0777ad0ee6210abfe1cac24d663df41b"><td class="memItemLeft" align="right" valign="top">HOST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a0777ad0ee6210abfe1cac24d663df41b">vector</a> (const <a class="el" href="classecuda_1_1vector.html#a7b94fcad8e25670029d3892edc53f124">allocator_type</a> &amp;allocator=<a class="el" href="classecuda_1_1vector.html#a7b94fcad8e25670029d3892edc53f124">allocator_type</a>())</td></tr>
<tr class="memdesc:a0777ad0ee6210abfe1cac24d663df41b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. Constructs empty container.  <a href="#a0777ad0ee6210abfe1cac24d663df41b">More...</a><br/></td></tr>
<tr class="separator:a0777ad0ee6210abfe1cac24d663df41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cacd373607e06fc8f96c6f9af2abf89"><td class="memItemLeft" align="right" valign="top">HOST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a1cacd373607e06fc8f96c6f9af2abf89">vector</a> (<a class="el" href="classecuda_1_1vector.html#a4360b100af6758b359fe4d62a5399d1f">size_type</a> n, const <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a> &amp;value, const <a class="el" href="classecuda_1_1vector.html#a7b94fcad8e25670029d3892edc53f124">allocator_type</a> &amp;allocator=<a class="el" href="classecuda_1_1vector.html#a7b94fcad8e25670029d3892edc53f124">allocator_type</a>())</td></tr>
<tr class="memdesc:a1cacd373607e06fc8f96c6f9af2abf89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with n copies of elements with value value.  <a href="#a1cacd373607e06fc8f96c6f9af2abf89">More...</a><br/></td></tr>
<tr class="separator:a1cacd373607e06fc8f96c6f9af2abf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf70212a895ad1533e15993989b22680"><td class="memItemLeft" align="right" valign="top">HOST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#aaf70212a895ad1533e15993989b22680">vector</a> (<a class="el" href="classecuda_1_1vector.html#a4360b100af6758b359fe4d62a5399d1f">size_type</a> n)</td></tr>
<tr class="memdesc:aaf70212a895ad1533e15993989b22680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with n default-inserted instances of T. No copies are made.  <a href="#aaf70212a895ad1533e15993989b22680">More...</a><br/></td></tr>
<tr class="separator:aaf70212a895ad1533e15993989b22680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5196647b7974fbe0042d00cf3060f386"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:a5196647b7974fbe0042d00cf3060f386"><td class="memTemplItemLeft" align="right" valign="top">HOST&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a5196647b7974fbe0042d00cf3060f386">vector</a> (Iterator first, Iterator last, const <a class="el" href="classecuda_1_1vector.html#a7b94fcad8e25670029d3892edc53f124">allocator_type</a> &amp;allocator=<a class="el" href="classecuda_1_1vector.html#a7b94fcad8e25670029d3892edc53f124">allocator_type</a>())</td></tr>
<tr class="memdesc:a5196647b7974fbe0042d00cf3060f386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the range [begin,end).  <a href="#a5196647b7974fbe0042d00cf3060f386">More...</a><br/></td></tr>
<tr class="separator:a5196647b7974fbe0042d00cf3060f386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3edce7ab426ce3b2126288b0cc737aa"><td class="memItemLeft" align="right" valign="top">HOST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ac3edce7ab426ce3b2126288b0cc737aa">vector</a> (const <a class="el" href="classecuda_1_1vector.html">vector</a>&lt; <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a> &gt; &amp;src)</td></tr>
<tr class="memdesc:ac3edce7ab426ce3b2126288b0cc737aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a vector with a shallow copy of each of the elements in src.  <a href="#ac3edce7ab426ce3b2126288b0cc737aa">More...</a><br/></td></tr>
<tr class="separator:ac3edce7ab426ce3b2126288b0cc737aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b5b1813183df104b58edef34e61b66"><td class="memTemplParams" colspan="2">template&lt;class Alloc2 &gt; </td></tr>
<tr class="memitem:a81b5b1813183df104b58edef34e61b66"><td class="memTemplItemLeft" align="right" valign="top">HOST&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a81b5b1813183df104b58edef34e61b66">vector</a> (const <a class="el" href="classecuda_1_1vector.html">vector</a>&lt; <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a>, Alloc2 &gt; &amp;src, const <a class="el" href="classecuda_1_1vector.html#a7b94fcad8e25670029d3892edc53f124">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:a81b5b1813183df104b58edef34e61b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. Constructs the container with the copy of the contents of the other.  <a href="#a81b5b1813183df104b58edef34e61b66">More...</a><br/></td></tr>
<tr class="separator:a81b5b1813183df104b58edef34e61b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8a5d41c07b08b4920786b79bbf7474"><td class="memItemLeft" align="right" valign="top">HOST DEVICE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a0b8a5d41c07b08b4920786b79bbf7474">vector</a> (<a class="el" href="classecuda_1_1vector.html">vector</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a0b8a5d41c07b08b4920786b79bbf7474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Constructs the container with the contents of the other using move semantics.  <a href="#a0b8a5d41c07b08b4920786b79bbf7474">More...</a><br/></td></tr>
<tr class="separator:a0b8a5d41c07b08b4920786b79bbf7474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec412cf800d67f3c5419ba08137e9d09"><td class="memItemLeft" align="right" valign="top">HOST DEVICE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#aec412cf800d67f3c5419ba08137e9d09">vector</a> (<a class="el" href="classecuda_1_1vector.html">vector</a> &amp;&amp;src, const <a class="el" href="classecuda_1_1vector.html#a7b94fcad8e25670029d3892edc53f124">allocator_type</a> &amp;allocator)</td></tr>
<tr class="memdesc:aec412cf800d67f3c5419ba08137e9d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Constructs the container with the contents of the other using move semantics.  <a href="#aec412cf800d67f3c5419ba08137e9d09">More...</a><br/></td></tr>
<tr class="separator:aec412cf800d67f3c5419ba08137e9d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a915b6c51fea25addab2abf4afdcf7c"><td class="memItemLeft" align="right" valign="top">HOST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a7a915b6c51fea25addab2abf4afdcf7c">vector</a> (std::initializer_list&lt; <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a> &gt; il, const <a class="el" href="classecuda_1_1vector.html#a7b94fcad8e25670029d3892edc53f124">allocator_type</a> &amp;allocator=<a class="el" href="classecuda_1_1vector.html#a7b94fcad8e25670029d3892edc53f124">allocator_type</a>())</td></tr>
<tr class="memdesc:a7a915b6c51fea25addab2abf4afdcf7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the initializer list il.  <a href="#a7a915b6c51fea25addab2abf4afdcf7c">More...</a><br/></td></tr>
<tr class="separator:a7a915b6c51fea25addab2abf4afdcf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2467abdd66dae3c6a8172f9cdc7568f6"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#aeb6c5f81e617def3d16565716e3ee0cf">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a2467abdd66dae3c6a8172f9cdc7568f6">begin</a> () __NOEXCEPT__</td></tr>
<tr class="memdesc:a2467abdd66dae3c6a8172f9cdc7568f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="#a2467abdd66dae3c6a8172f9cdc7568f6">More...</a><br/></td></tr>
<tr class="separator:a2467abdd66dae3c6a8172f9cdc7568f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aed58e1d01bd42f214470671ab72ff4"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#aeb6c5f81e617def3d16565716e3ee0cf">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a4aed58e1d01bd42f214470671ab72ff4">end</a> () __NOEXCEPT__</td></tr>
<tr class="memdesc:a4aed58e1d01bd42f214470671ab72ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="#a4aed58e1d01bd42f214470671ab72ff4">More...</a><br/></td></tr>
<tr class="separator:a4aed58e1d01bd42f214470671ab72ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d31c46fa5154afd211a96fdd914e519"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#a49059fdbbb05ba52a1ff476945d6db6b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a9d31c46fa5154afd211a96fdd914e519">begin</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:a9d31c46fa5154afd211a96fdd914e519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="#a9d31c46fa5154afd211a96fdd914e519">More...</a><br/></td></tr>
<tr class="separator:a9d31c46fa5154afd211a96fdd914e519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906967a8444907da0d3dde747257a0c3"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#a49059fdbbb05ba52a1ff476945d6db6b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a906967a8444907da0d3dde747257a0c3">end</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:a906967a8444907da0d3dde747257a0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="#a906967a8444907da0d3dde747257a0c3">More...</a><br/></td></tr>
<tr class="separator:a906967a8444907da0d3dde747257a0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad51e742ab7a799698c93f02b5e83e17"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#ae0556d788dc27375aa65398d8731f437">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#aad51e742ab7a799698c93f02b5e83e17">rbegin</a> () __NOEXCEPT__</td></tr>
<tr class="memdesc:aad51e742ab7a799698c93f02b5e83e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed container.  <a href="#aad51e742ab7a799698c93f02b5e83e17">More...</a><br/></td></tr>
<tr class="separator:aad51e742ab7a799698c93f02b5e83e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33e5783118b3c0639f81bb410c117b6"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#ae0556d788dc27375aa65398d8731f437">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ad33e5783118b3c0639f81bb410c117b6">rend</a> () __NOEXCEPT__</td></tr>
<tr class="memdesc:ad33e5783118b3c0639f81bb410c117b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed container.  <a href="#ad33e5783118b3c0639f81bb410c117b6">More...</a><br/></td></tr>
<tr class="separator:ad33e5783118b3c0639f81bb410c117b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e5fb030a8e3bc4536fdb615833d822"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#aac0540b79731122af43dc10e96f28624">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a76e5fb030a8e3bc4536fdb615833d822">rbegin</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:a76e5fb030a8e3bc4536fdb615833d822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed container.  <a href="#a76e5fb030a8e3bc4536fdb615833d822">More...</a><br/></td></tr>
<tr class="separator:a76e5fb030a8e3bc4536fdb615833d822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5059da0a53e5238ffddc5d6043242856"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#aac0540b79731122af43dc10e96f28624">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a5059da0a53e5238ffddc5d6043242856">rend</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:a5059da0a53e5238ffddc5d6043242856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed container.  <a href="#a5059da0a53e5238ffddc5d6043242856">More...</a><br/></td></tr>
<tr class="separator:a5059da0a53e5238ffddc5d6043242856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bef1d0b26671cf382140993250d59c0"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#a49059fdbbb05ba52a1ff476945d6db6b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a7bef1d0b26671cf382140993250d59c0">cbegin</a> () const __NOEXCEPT__</td></tr>
<tr class="separator:a7bef1d0b26671cf382140993250d59c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780a82ba3d45ffcf260d6418738ca468"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#a49059fdbbb05ba52a1ff476945d6db6b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a780a82ba3d45ffcf260d6418738ca468">cend</a> () const __NOEXCEPT__</td></tr>
<tr class="separator:a780a82ba3d45ffcf260d6418738ca468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92adc07637933bcb32ec50743fae238"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#aac0540b79731122af43dc10e96f28624">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#af92adc07637933bcb32ec50743fae238">crbegin</a> () __NOEXCEPT__</td></tr>
<tr class="separator:af92adc07637933bcb32ec50743fae238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688bbfc87bc10580c9e337147d7502c3"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#aac0540b79731122af43dc10e96f28624">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a688bbfc87bc10580c9e337147d7502c3">crend</a> () __NOEXCEPT__</td></tr>
<tr class="separator:a688bbfc87bc10580c9e337147d7502c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa205d2d46367666470c4c2eda19a1828"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#a4360b100af6758b359fe4d62a5399d1f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#aa205d2d46367666470c4c2eda19a1828">size</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:aa205d2d46367666470c4c2eda19a1828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container.  <a href="#aa205d2d46367666470c4c2eda19a1828">More...</a><br/></td></tr>
<tr class="separator:aa205d2d46367666470c4c2eda19a1828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23c4ce0190a3db78e826e719bcba9b8"><td class="memItemLeft" align="right" valign="top">HOST DEVICE __CONSTEXPR__ <a class="el" href="classecuda_1_1vector.html#a4360b100af6758b359fe4d62a5399d1f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ac23c4ce0190a3db78e826e719bcba9b8">max_size</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:ac23c4ce0190a3db78e826e719bcba9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the container is able to hold due to system or library implementation limitations.  <a href="#ac23c4ce0190a3db78e826e719bcba9b8">More...</a><br/></td></tr>
<tr class="separator:ac23c4ce0190a3db78e826e719bcba9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2db91bdd67ced4bf70288e2bd727549"><td class="memItemLeft" align="right" valign="top">HOST void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ab2db91bdd67ced4bf70288e2bd727549">resize</a> (<a class="el" href="classecuda_1_1vector.html#a4360b100af6758b359fe4d62a5399d1f">size_type</a> newSize, const <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a> &amp;value=<a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a>())</td></tr>
<tr class="memdesc:ab2db91bdd67ced4bf70288e2bd727549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain newSize elements.  <a href="#ab2db91bdd67ced4bf70288e2bd727549">More...</a><br/></td></tr>
<tr class="separator:ab2db91bdd67ced4bf70288e2bd727549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348205463812273f1c97c13696032ee6"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#a4360b100af6758b359fe4d62a5399d1f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a348205463812273f1c97c13696032ee6">capacity</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:a348205463812273f1c97c13696032ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements that the container has currently allocated space for.  <a href="#a348205463812273f1c97c13696032ee6">More...</a><br/></td></tr>
<tr class="separator:a348205463812273f1c97c13696032ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b07573d3746200ffbd7ae3cc5fad68b"><td class="memItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a7b07573d3746200ffbd7ae3cc5fad68b">empty</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:a7b07573d3746200ffbd7ae3cc5fad68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container has no elements.  <a href="#a7b07573d3746200ffbd7ae3cc5fad68b">More...</a><br/></td></tr>
<tr class="separator:a7b07573d3746200ffbd7ae3cc5fad68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4c98b533ab9759b444cbdf45d44d3d"><td class="memItemLeft" align="right" valign="top">HOST void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#aee4c98b533ab9759b444cbdf45d44d3d">reserve</a> (<a class="el" href="classecuda_1_1vector.html#a4360b100af6758b359fe4d62a5399d1f">size_type</a> newCapacity)</td></tr>
<tr class="memdesc:aee4c98b533ab9759b444cbdf45d44d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the capacity of the container to a value that's greater or equal to newCapacity.  <a href="#aee4c98b533ab9759b444cbdf45d44d3d">More...</a><br/></td></tr>
<tr class="separator:aee4c98b533ab9759b444cbdf45d44d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d3dedc0c021959091eb99b54f713f3"><td class="memItemLeft" align="right" valign="top">DEVICE <a class="el" href="classecuda_1_1vector.html#adf161ce7503d2bb75c329a71e6d4413e">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#af6d3dedc0c021959091eb99b54f713f3">operator[]</a> (const <a class="el" href="classecuda_1_1vector.html#a4360b100af6758b359fe4d62a5399d1f">size_type</a> index)</td></tr>
<tr class="memdesc:af6d3dedc0c021959091eb99b54f713f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index. No bounds checking is performed.  <a href="#af6d3dedc0c021959091eb99b54f713f3">More...</a><br/></td></tr>
<tr class="separator:af6d3dedc0c021959091eb99b54f713f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f38434341be0d09f7ed1c729ee9447"><td class="memItemLeft" align="right" valign="top">DEVICE <a class="el" href="classecuda_1_1vector.html#a07305c387f4c2134aaaed0d99ce87a03">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a17f38434341be0d09f7ed1c729ee9447">operator[]</a> (const <a class="el" href="classecuda_1_1vector.html#a4360b100af6758b359fe4d62a5399d1f">size_type</a> index) const </td></tr>
<tr class="memdesc:a17f38434341be0d09f7ed1c729ee9447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index. No bounds checking is performed.  <a href="#a17f38434341be0d09f7ed1c729ee9447">More...</a><br/></td></tr>
<tr class="separator:a17f38434341be0d09f7ed1c729ee9447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9494b0c6b68324807229874b1bdae5f6"><td class="memItemLeft" align="right" valign="top">DEVICE <a class="el" href="classecuda_1_1vector.html#adf161ce7503d2bb75c329a71e6d4413e">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a9494b0c6b68324807229874b1bdae5f6">front</a> ()</td></tr>
<tr class="memdesc:a9494b0c6b68324807229874b1bdae5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container.  <a href="#a9494b0c6b68324807229874b1bdae5f6">More...</a><br/></td></tr>
<tr class="separator:a9494b0c6b68324807229874b1bdae5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47096884dbc7e473635b43a655691111"><td class="memItemLeft" align="right" valign="top">DEVICE <a class="el" href="classecuda_1_1vector.html#adf161ce7503d2bb75c329a71e6d4413e">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a47096884dbc7e473635b43a655691111">back</a> ()</td></tr>
<tr class="memdesc:a47096884dbc7e473635b43a655691111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container.  <a href="#a47096884dbc7e473635b43a655691111">More...</a><br/></td></tr>
<tr class="separator:a47096884dbc7e473635b43a655691111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae873cbec6bf97605a2fc77e07add08f1"><td class="memItemLeft" align="right" valign="top">DEVICE <a class="el" href="classecuda_1_1vector.html#a07305c387f4c2134aaaed0d99ce87a03">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ae873cbec6bf97605a2fc77e07add08f1">front</a> () const </td></tr>
<tr class="memdesc:ae873cbec6bf97605a2fc77e07add08f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container.  <a href="#ae873cbec6bf97605a2fc77e07add08f1">More...</a><br/></td></tr>
<tr class="separator:ae873cbec6bf97605a2fc77e07add08f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bdbae25f0d096c13d1b25bcd0794e6"><td class="memItemLeft" align="right" valign="top">DEVICE <a class="el" href="classecuda_1_1vector.html#a07305c387f4c2134aaaed0d99ce87a03">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a23bdbae25f0d096c13d1b25bcd0794e6">back</a> () const </td></tr>
<tr class="memdesc:a23bdbae25f0d096c13d1b25bcd0794e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container.  <a href="#a23bdbae25f0d096c13d1b25bcd0794e6">More...</a><br/></td></tr>
<tr class="separator:a23bdbae25f0d096c13d1b25bcd0794e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5009ce62bc5072f2147e3e1905e465"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#a5bf382998902613a84f0877c2b07a740">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a1c5009ce62bc5072f2147e3e1905e465">data</a> () __NOEXCEPT__</td></tr>
<tr class="memdesc:a1c5009ce62bc5072f2147e3e1905e465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage.  <a href="#a1c5009ce62bc5072f2147e3e1905e465">More...</a><br/></td></tr>
<tr class="separator:a1c5009ce62bc5072f2147e3e1905e465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad749fe4768933101640fc0b570d52356"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#a530ade1a42cac82fab8019c2e39dd49f">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ad749fe4768933101640fc0b570d52356">data</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:ad749fe4768933101640fc0b570d52356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage.  <a href="#ad749fe4768933101640fc0b570d52356">More...</a><br/></td></tr>
<tr class="separator:ad749fe4768933101640fc0b570d52356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11024cc69b967283013d084390a88b62"><td class="memItemLeft" align="right" valign="top">HOST void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a11024cc69b967283013d084390a88b62">assign</a> (<a class="el" href="classecuda_1_1vector.html#a4360b100af6758b359fe4d62a5399d1f">size_type</a> newSize, const <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a> &amp;value=<a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a>())</td></tr>
<tr class="memdesc:a11024cc69b967283013d084390a88b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the container.  <a href="#a11024cc69b967283013d084390a88b62">More...</a><br/></td></tr>
<tr class="separator:a11024cc69b967283013d084390a88b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d7ae0d2b5035627da2029bc59c8bdb"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:a06d7ae0d2b5035627da2029bc59c8bdb"><td class="memTemplItemLeft" align="right" valign="top">HOST void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a06d7ae0d2b5035627da2029bc59c8bdb">assign</a> (Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a06d7ae0d2b5035627da2029bc59c8bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the container with copies of those in the range [first,last).  <a href="#a06d7ae0d2b5035627da2029bc59c8bdb">More...</a><br/></td></tr>
<tr class="separator:a06d7ae0d2b5035627da2029bc59c8bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7729954b19cabaa1df501c64c00a93ee"><td class="memItemLeft" align="right" valign="top">HOST void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a7729954b19cabaa1df501c64c00a93ee">assign</a> (std::initializer_list&lt; <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a> &gt; il)</td></tr>
<tr class="memdesc:a7729954b19cabaa1df501c64c00a93ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents with the elements from the initializer list il.  <a href="#a7729954b19cabaa1df501c64c00a93ee">More...</a><br/></td></tr>
<tr class="separator:a7729954b19cabaa1df501c64c00a93ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff584404ff28a5fc88187fe9e4138ece"><td class="memItemLeft" align="right" valign="top">HOST void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#aff584404ff28a5fc88187fe9e4138ece">push_back</a> (const <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:aff584404ff28a5fc88187fe9e4138ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the container.  <a href="#aff584404ff28a5fc88187fe9e4138ece">More...</a><br/></td></tr>
<tr class="separator:aff584404ff28a5fc88187fe9e4138ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1016ac07fb5980344060f195953ce95"><td class="memItemLeft" align="right" valign="top">HOST DEVICE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ac1016ac07fb5980344060f195953ce95">pop_back</a> ()</td></tr>
<tr class="memdesc:ac1016ac07fb5980344060f195953ce95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element of the container.  <a href="#ac1016ac07fb5980344060f195953ce95">More...</a><br/></td></tr>
<tr class="separator:ac1016ac07fb5980344060f195953ce95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda127f16a74f774ebe77f275a12ee20"><td class="memItemLeft" align="right" valign="top">HOST <a class="el" href="classecuda_1_1vector.html#aeb6c5f81e617def3d16565716e3ee0cf">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#afda127f16a74f774ebe77f275a12ee20">insert</a> (<a class="el" href="classecuda_1_1vector.html#a49059fdbbb05ba52a1ff476945d6db6b">const_iterator</a> position, const <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:afda127f16a74f774ebe77f275a12ee20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts value before position.  <a href="#afda127f16a74f774ebe77f275a12ee20">More...</a><br/></td></tr>
<tr class="separator:afda127f16a74f774ebe77f275a12ee20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e4e5f3b897d06a8c3b85a1d1cad552"><td class="memItemLeft" align="right" valign="top">HOST <a class="el" href="classecuda_1_1vector.html#aeb6c5f81e617def3d16565716e3ee0cf">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a02e4e5f3b897d06a8c3b85a1d1cad552">insert</a> (<a class="el" href="classecuda_1_1vector.html#a49059fdbbb05ba52a1ff476945d6db6b">const_iterator</a> position, const <a class="el" href="classecuda_1_1vector.html#a4360b100af6758b359fe4d62a5399d1f">size_type</a> count, const <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a02e4e5f3b897d06a8c3b85a1d1cad552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts count copies of the value before position.  <a href="#a02e4e5f3b897d06a8c3b85a1d1cad552">More...</a><br/></td></tr>
<tr class="separator:a02e4e5f3b897d06a8c3b85a1d1cad552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee1cba5509af06ca513bd68f5a0df27"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:afee1cba5509af06ca513bd68f5a0df27"><td class="memTemplItemLeft" align="right" valign="top">HOST void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#afee1cba5509af06ca513bd68f5a0df27">insert</a> (<a class="el" href="classecuda_1_1vector.html#a49059fdbbb05ba52a1ff476945d6db6b">const_iterator</a> position, InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:afee1cba5509af06ca513bd68f5a0df27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first,last) before position.  <a href="#afee1cba5509af06ca513bd68f5a0df27">More...</a><br/></td></tr>
<tr class="separator:afee1cba5509af06ca513bd68f5a0df27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3dd8c27ee3187f2468f7036c7764373"><td class="memItemLeft" align="right" valign="top">HOST void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ac3dd8c27ee3187f2468f7036c7764373">insert</a> (<a class="el" href="classecuda_1_1vector.html#a49059fdbbb05ba52a1ff476945d6db6b">const_iterator</a> position, std::initializer_list&lt; <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a> &gt; il)</td></tr>
<tr class="memdesc:ac3dd8c27ee3187f2468f7036c7764373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from initializer_list before position.  <a href="#ac3dd8c27ee3187f2468f7036c7764373">More...</a><br/></td></tr>
<tr class="separator:ac3dd8c27ee3187f2468f7036c7764373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44f6a5faa6b6887f32dc8456b85ecaf"><td class="memItemLeft" align="right" valign="top">HOST <a class="el" href="classecuda_1_1vector.html#aeb6c5f81e617def3d16565716e3ee0cf">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ad44f6a5faa6b6887f32dc8456b85ecaf">erase</a> (<a class="el" href="classecuda_1_1vector.html#a49059fdbbb05ba52a1ff476945d6db6b">const_iterator</a> position)</td></tr>
<tr class="memdesc:ad44f6a5faa6b6887f32dc8456b85ecaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element at position.  <a href="#ad44f6a5faa6b6887f32dc8456b85ecaf">More...</a><br/></td></tr>
<tr class="separator:ad44f6a5faa6b6887f32dc8456b85ecaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d405046fd83ab61f41c08000f07590"><td class="memItemLeft" align="right" valign="top">HOST <a class="el" href="classecuda_1_1vector.html#aeb6c5f81e617def3d16565716e3ee0cf">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a20d405046fd83ab61f41c08000f07590">erase</a> (<a class="el" href="classecuda_1_1vector.html#a49059fdbbb05ba52a1ff476945d6db6b">const_iterator</a> first, <a class="el" href="classecuda_1_1vector.html#a49059fdbbb05ba52a1ff476945d6db6b">const_iterator</a> last)</td></tr>
<tr class="memdesc:a20d405046fd83ab61f41c08000f07590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements in the range [first,last).  <a href="#a20d405046fd83ab61f41c08000f07590">More...</a><br/></td></tr>
<tr class="separator:a20d405046fd83ab61f41c08000f07590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8ac09770d4a4e6faec0c757f4526ce"><td class="memItemLeft" align="right" valign="top">HOST DEVICE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a9d8ac09770d4a4e6faec0c757f4526ce">swap</a> (<a class="el" href="classecuda_1_1vector.html">vector</a> &amp;other)</td></tr>
<tr class="memdesc:a9d8ac09770d4a4e6faec0c757f4526ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the container with those of the other.  <a href="#a9d8ac09770d4a4e6faec0c757f4526ce">More...</a><br/></td></tr>
<tr class="separator:a9d8ac09770d4a4e6faec0c757f4526ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc1611e3dd27e5e80eb0a45d7e2eae5"><td class="memItemLeft" align="right" valign="top">HOST DEVICE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#adcc1611e3dd27e5e80eb0a45d7e2eae5">clear</a> ()</td></tr>
<tr class="memdesc:adcc1611e3dd27e5e80eb0a45d7e2eae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the container.  <a href="#adcc1611e3dd27e5e80eb0a45d7e2eae5">More...</a><br/></td></tr>
<tr class="separator:adcc1611e3dd27e5e80eb0a45d7e2eae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6af1464f880951ab696a03a4cadd6d1"><td class="memItemLeft" align="right" valign="top">HOST <a class="el" href="classecuda_1_1vector.html#a7b94fcad8e25670029d3892edc53f124">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ae6af1464f880951ab696a03a4cadd6d1">get_allocator</a> () const </td></tr>
<tr class="memdesc:ae6af1464f880951ab696a03a4cadd6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the container.  <a href="#ae6af1464f880951ab696a03a4cadd6d1">More...</a><br/></td></tr>
<tr class="separator:ae6af1464f880951ab696a03a4cadd6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f3ff42433bd3e8ece9ddd736fd6501"><td class="memItemLeft" align="right" valign="top">HOST void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a54f3ff42433bd3e8ece9ddd736fd6501">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a54f3ff42433bd3e8ece9ddd736fd6501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the removal of unused capacity.  <a href="#a54f3ff42433bd3e8ece9ddd736fd6501">More...</a><br/></td></tr>
<tr class="separator:a54f3ff42433bd3e8ece9ddd736fd6501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1da059d31e44de14f076597b5f5473b"><td class="memItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ad1da059d31e44de14f076597b5f5473b">operator==</a> (const <a class="el" href="classecuda_1_1vector.html">vector</a> &amp;other) const </td></tr>
<tr class="memdesc:ad1da059d31e44de14f076597b5f5473b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of two vectors are equal.  <a href="#ad1da059d31e44de14f076597b5f5473b">More...</a><br/></td></tr>
<tr class="separator:ad1da059d31e44de14f076597b5f5473b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cd702a932de97fd0d2a8639f270941"><td class="memItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a76cd702a932de97fd0d2a8639f270941">operator!=</a> (const <a class="el" href="classecuda_1_1vector.html">vector</a> &amp;other) const </td></tr>
<tr class="memdesc:a76cd702a932de97fd0d2a8639f270941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of two arrays are not equal.  <a href="#a76cd702a932de97fd0d2a8639f270941">More...</a><br/></td></tr>
<tr class="separator:a76cd702a932de97fd0d2a8639f270941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172bf17497dda9b3b8ece118ae23e09f"><td class="memItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a172bf17497dda9b3b8ece118ae23e09f">operator&lt;</a> (const <a class="el" href="classecuda_1_1vector.html">vector</a> &amp;other) const </td></tr>
<tr class="memdesc:a172bf17497dda9b3b8ece118ae23e09f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two vectors lexicographically.  <a href="#a172bf17497dda9b3b8ece118ae23e09f">More...</a><br/></td></tr>
<tr class="separator:a172bf17497dda9b3b8ece118ae23e09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e39be5d7750c6b808b3b9ff1f44bc9"><td class="memItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a99e39be5d7750c6b808b3b9ff1f44bc9">operator&gt;</a> (const <a class="el" href="classecuda_1_1vector.html">vector</a> &amp;other) const </td></tr>
<tr class="memdesc:a99e39be5d7750c6b808b3b9ff1f44bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two vectors lexicographically.  <a href="#a99e39be5d7750c6b808b3b9ff1f44bc9">More...</a><br/></td></tr>
<tr class="separator:a99e39be5d7750c6b808b3b9ff1f44bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab345fe46f55c842d2c1ba010c31a6bb7"><td class="memItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ab345fe46f55c842d2c1ba010c31a6bb7">operator&lt;=</a> (const <a class="el" href="classecuda_1_1vector.html">vector</a> &amp;other) const </td></tr>
<tr class="memdesc:ab345fe46f55c842d2c1ba010c31a6bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two vectors lexicographically.  <a href="#ab345fe46f55c842d2c1ba010c31a6bb7">More...</a><br/></td></tr>
<tr class="separator:ab345fe46f55c842d2c1ba010c31a6bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845f28fc24b299bde1654b903d66384d"><td class="memItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a845f28fc24b299bde1654b903d66384d">operator&gt;=</a> (const <a class="el" href="classecuda_1_1vector.html">vector</a> &amp;other) const </td></tr>
<tr class="memdesc:a845f28fc24b299bde1654b903d66384d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two vectors lexicographically.  <a href="#a845f28fc24b299bde1654b903d66384d">More...</a><br/></td></tr>
<tr class="separator:a845f28fc24b299bde1654b903d66384d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1a70b8148ab4af057050a140538884"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a6f1a70b8148ab4af057050a140538884"><td class="memTemplItemLeft" align="right" valign="top">HOST Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a6f1a70b8148ab4af057050a140538884">operator&gt;&gt;</a> (Container &amp;dest) const </td></tr>
<tr class="memdesc:a6f1a70b8148ab4af057050a140538884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the contents of this device vector to another container.  <a href="#a6f1a70b8148ab4af057050a140538884">More...</a><br/></td></tr>
<tr class="separator:a6f1a70b8148ab4af057050a140538884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6696c389e290eb4676195b4356a645b"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:aa6696c389e290eb4676195b4356a645b"><td class="memTemplItemLeft" align="right" valign="top">HOST <a class="el" href="classecuda_1_1vector.html">vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#aa6696c389e290eb4676195b4356a645b">operator&lt;&lt;</a> (const Container &amp;src)</td></tr>
<tr class="memdesc:aa6696c389e290eb4676195b4356a645b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the contents of a container to this device array.  <a href="#aa6696c389e290eb4676195b4356a645b">More...</a><br/></td></tr>
<tr class="separator:aa6696c389e290eb4676195b4356a645b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt;<br/>
class ecuda::vector&lt; T, Alloc &gt;</h3>

<p>A resizable vector stored in device memory. </p>
<p>Methods are prefaced with appropriate keywords to declare them as host and/or device capable. In general: operations requiring memory allocation/deallocation are host only, operations to access the values of specific elements are device only, and copy operations on ranges of data and accessors of general information can be performed on both the host and device.</p>
<p>Any growth of the vector follows a doubling pattern. The existing memory allocation size is doubled until the requested amount of memory is met or exceeded. </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00102">102</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a7b94fcad8e25670029d3892edc53f124"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Alloc <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1vector.html#a7b94fcad8e25670029d3892edc53f124">allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocator type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00106">106</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a49059fdbbb05ba52a1ff476945d6db6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1contiguous__device__iterator.html">contiguous_device_iterator</a>&lt;const <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a>&gt; <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1vector.html#a49059fdbbb05ba52a1ff476945d6db6b">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const iterator type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00122">122</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a530ade1a42cac82fab8019c2e39dd49f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::allocator_traits&lt;Alloc&gt;::<a class="el" href="classecuda_1_1vector.html#a530ade1a42cac82fab8019c2e39dd49f">const_pointer</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1vector.html#a530ade1a42cac82fab8019c2e39dd49f">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell const pointer type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00113">113</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a29a30ad87dd687f1e7d23424a95bc2de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Alloc::const_pointer <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1vector.html#a530ade1a42cac82fab8019c2e39dd49f">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell const pointer type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00118">118</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a07305c387f4c2134aaaed0d99ce87a03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a>&amp; <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1vector.html#a07305c387f4c2134aaaed0d99ce87a03">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell const reference type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00111">111</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abf932ab1b8eef2454436ad7d58d61e11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Alloc::const_reference <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1vector.html#a07305c387f4c2134aaaed0d99ce87a03">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell const reference type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00116">116</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aac0540b79731122af43dc10e96f28624"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1reverse__device__iterator.html">reverse_device_iterator</a>&lt;<a class="el" href="classecuda_1_1vector.html#a49059fdbbb05ba52a1ff476945d6db6b">const_iterator</a>&gt; <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1vector.html#aac0540b79731122af43dc10e96f28624">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const reverse iterator type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00124">124</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a55e6768e9cc1d5f7f334afd76bb3ea16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1contiguous__device__iterator.html">contiguous_device_iterator</a>&lt;const <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a>&gt; <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1vector.html#a55e6768e9cc1d5f7f334afd76bb3ea16">ContiguousDeviceIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00126">126</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a76c8e2dd45f49db350ceca8e3e63e78a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::ptrdiff_t <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1vector.html#a76c8e2dd45f49db350ceca8e3e63e78a">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>signed integral type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00108">108</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeb6c5f81e617def3d16565716e3ee0cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1contiguous__device__iterator.html">contiguous_device_iterator</a>&lt;<a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a>&gt; <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1vector.html#aeb6c5f81e617def3d16565716e3ee0cf">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iterator type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00121">121</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5bf382998902613a84f0877c2b07a740"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::allocator_traits&lt;Alloc&gt;::<a class="el" href="classecuda_1_1vector.html#a5bf382998902613a84f0877c2b07a740">pointer</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1vector.html#a5bf382998902613a84f0877c2b07a740">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell pointer type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00112">112</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7036904e428a9e265d03289c7e460b75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Alloc::pointer <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1vector.html#a5bf382998902613a84f0877c2b07a740">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell pointer type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00117">117</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adf161ce7503d2bb75c329a71e6d4413e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a>&amp; <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1vector.html#adf161ce7503d2bb75c329a71e6d4413e">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell reference type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00110">110</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac1bdcdab23fb93bca4230b71518b7d1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Alloc::reference <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1vector.html#adf161ce7503d2bb75c329a71e6d4413e">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell reference type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00115">115</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae0556d788dc27375aa65398d8731f437"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1reverse__device__iterator.html">reverse_device_iterator</a>&lt;<a class="el" href="classecuda_1_1vector.html#aeb6c5f81e617def3d16565716e3ee0cf">iterator</a>&gt; <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1vector.html#ae0556d788dc27375aa65398d8731f437">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reverse iterator type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00123">123</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4360b100af6758b359fe4d62a5399d1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1vector.html#a4360b100af6758b359fe4d62a5399d1f">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unsigned integral type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00107">107</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae56bbcd61835f36a582c289667f9ac00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell data type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00105">105</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0777ad0ee6210abfe1cac24d663df41b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#a7b94fcad8e25670029d3892edc53f124">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code><a class="el" href="classecuda_1_1vector.html#a7b94fcad8e25670029d3892edc53f124">allocator_type</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. Constructs empty container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00158">158</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1cacd373607e06fc8f96c6f9af2abf89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html#a4360b100af6758b359fe4d62a5399d1f">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#a7b94fcad8e25670029d3892edc53f124">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code><a class="el" href="classecuda_1_1vector.html#a7b94fcad8e25670029d3892edc53f124">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with n copies of elements with value value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the size of the container </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize elements of the container with </td></tr>
    <tr><td class="paramname">allocator</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00166">166</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaf70212a895ad1533e15993989b22680"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html#a4360b100af6758b359fe4d62a5399d1f">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with n default-inserted instances of T. No copies are made. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the size of the container </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00174">174</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5196647b7974fbe0042d00cf3060f386"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#a7b94fcad8e25670029d3892edc53f124">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code><a class="el" href="classecuda_1_1vector.html#a7b94fcad8e25670029d3892edc53f124">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the range [begin,end). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,last</td><td>the range to copy the elements from </td></tr>
    <tr><td class="paramname">allocator</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00184">184</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac3edce7ab426ce3b2126288b0cc737aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html">vector</a>&lt; <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a vector with a shallow copy of each of the elements in src. </p>
<p>Be careful to note that a shallow copy means that only the pointer to the device memory that holds the elements is copied in the newly constructed container. This allows containers to be passed-by-value to kernel functions with minimal overhead. If a copy of the container is required in host code, use the &lt;&lt; or &gt;&gt; operators, or use iterators. For example:</p>
<div class="fragment"><div class="line"><a class="code" href="classecuda_1_1vector.html">ecuda::vector&lt;int&gt;</a> vec( 10, 3 ); <span class="comment">// create a vector of size 10 filled with 3s</span></div>
<div class="line"><a class="code" href="classecuda_1_1vector.html">ecuda::vector&lt;int&gt;</a> newVec( vec ); <span class="comment">// shallow copy</span></div>
<div class="line"><a class="code" href="classecuda_1_1vector.html">ecuda::vector&lt;int&gt;</a> newVec( 10 );</div>
<div class="line">newVec &lt;&lt; vec; <span class="comment">// deep copy</span></div>
<div class="line">vec &gt;&gt; newVec; <span class="comment">// deep copy</span></div>
<div class="line"><a class="code" href="classecuda_1_1vector.html">ecuda::vector&lt;int&gt;</a> newVec2( vec.begin(), vec.end() ); <span class="comment">// deep copy</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Another vector object of the same type, whose contents are copied. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00209">209</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a81b5b1813183df104b58edef34e61b66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html">vector</a>&lt; <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a>, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#a7b94fcad8e25670029d3892edc53f124">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. Constructs the container with the copy of the contents of the other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">allocator</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00224">224</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0b8a5d41c07b08b4920786b79bbf7474"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html">vector</a>&lt; T, Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. Constructs the container with the contents of the other using move semantics. </p>
<p>This constructor is only available if the compiler is configured to allow C++11.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00237">237</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aec412cf800d67f3c5419ba08137e9d09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html">vector</a>&lt; T, Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#a7b94fcad8e25670029d3892edc53f124">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. Constructs the container with the contents of the other using move semantics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">allocator</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00244">244</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7a915b6c51fea25addab2abf4afdcf7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#a7b94fcad8e25670029d3892edc53f124">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code><a class="el" href="classecuda_1_1vector.html#a7b94fcad8e25670029d3892edc53f124">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the initializer list il. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>initializer list to initialize the elements of the container with </td></tr>
    <tr><td class="paramname">allocator</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00251">251</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a11024cc69b967283013d084390a88b62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST void <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html#a4360b100af6758b359fe4d62a5399d1f">size_type</a>&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code><a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>the new size of the container </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize elements of the container with </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00487">487</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a06d7ae0d2b5035627da2029bc59c8bdb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST void <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents of the container with copies of those in the range [first,last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,last</td><td>the range to copy the elements from </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00499">499</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7729954b19cabaa1df501c64c00a93ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST void <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents with the elements from the initializer list il. </p>
<p>This method is only available if the compiler is configured to allow C++11.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>initializer list to copy the values from </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00514">514</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a47096884dbc7e473635b43a655691111"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEVICE <a class="el" href="classecuda_1_1vector.html#adf161ce7503d2bb75c329a71e6d4413e">reference</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the container. </p>
<p>Calling back on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00442">442</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a23bdbae25f0d096c13d1b25bcd0794e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEVICE <a class="el" href="classecuda_1_1vector.html#a07305c387f4c2134aaaed0d99ce87a03">const_reference</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the container. </p>
<p>Calling back on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00460">460</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2467abdd66dae3c6a8172f9cdc7568f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#aeb6c5f81e617def3d16565716e3ee0cf">iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classecuda_1_1vector.html#a4aed58e1d01bd42f214470671ab72ff4" title="Returns an iterator to the element following the last element of the container. ">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00268">268</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9d31c46fa5154afd211a96fdd914e519"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#a49059fdbbb05ba52a1ff476945d6db6b">const_iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classecuda_1_1vector.html#a4aed58e1d01bd42f214470671ab72ff4" title="Returns an iterator to the element following the last element of the container. ">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00286">286</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a348205463812273f1c97c13696032ee6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#a4360b100af6758b359fe4d62a5399d1f">size_type</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements that the container has currently allocated space for. </p>
<dl class="section return"><dt>Returns</dt><dd>Capacity of the currently allocated storage. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00379">379</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7bef1d0b26671cf382140993250d59c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#a49059fdbbb05ba52a1ff476945d6db6b">const_iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00336">336</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a780a82ba3d45ffcf260d6418738ca468"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#a49059fdbbb05ba52a1ff476945d6db6b">const_iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00337">337</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adcc1611e3dd27e5e80eb0a45d7e2eae5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE void <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements from the container. </p>
<p>Invalidates all references, pointers, or iterators referring to contained elements. May invalidate any past-the-end iterators. Leaves the <a class="el" href="classecuda_1_1vector.html#a348205463812273f1c97c13696032ee6" title="Returns the number of elements that the container has currently allocated space for. ">capacity()</a> of the vector unchanged.</p>
<p>Although this can be called from both the host and device, a call from the device only clears the contents of the container in the calling thread only. </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00746">746</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af92adc07637933bcb32ec50743fae238"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#aac0540b79731122af43dc10e96f28624">const_reverse_iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00338">338</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a688bbfc87bc10580c9e337147d7502c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#aac0540b79731122af43dc10e96f28624">const_reverse_iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00339">339</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1c5009ce62bc5072f2147e3e1905e465"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#a5bf382998902613a84f0877c2b07a740">pointer</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying array serving as element storage. </p>
<p>The pointer is such that range [<a class="el" href="classecuda_1_1vector.html#a1c5009ce62bc5072f2147e3e1905e465" title="Returns pointer to the underlying array serving as element storage. ">data()</a>,<a class="el" href="classecuda_1_1vector.html#a1c5009ce62bc5072f2147e3e1905e465" title="Returns pointer to the underlying array serving as element storage. ">data()</a>+size()) is always a valid range, even if the container is empty.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00470">470</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad749fe4768933101640fc0b570d52356"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#a530ade1a42cac82fab8019c2e39dd49f">const_pointer</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying array serving as element storage. </p>
<p>The pointer is such that range [<a class="el" href="classecuda_1_1vector.html#a1c5009ce62bc5072f2147e3e1905e465" title="Returns pointer to the underlying array serving as element storage. ">data()</a>,<a class="el" href="classecuda_1_1vector.html#a1c5009ce62bc5072f2147e3e1905e465" title="Returns pointer to the underlying array serving as element storage. ">data()</a>+size()) is always a valid range, even if the container is empty.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00480">480</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7b07573d3746200ffbd7ae3cc5fad68b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container has no elements. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the container is empty, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00386">386</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4aed58e1d01bd42f214470671ab72ff4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#aeb6c5f81e617def3d16565716e3ee0cf">iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>
<p>The element acts as a placeholder; attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00277">277</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a906967a8444907da0d3dde747257a0c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#a49059fdbbb05ba52a1ff476945d6db6b">const_iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>
<p>The element acts as a placeholder; attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00295">295</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad44f6a5faa6b6887f32dc8456b85ecaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST <a class="el" href="classecuda_1_1vector.html#aeb6c5f81e617def3d16565716e3ee0cf">iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html#a49059fdbbb05ba52a1ff476945d6db6b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element at position. </p>
<p>Invalidates iterators and references at or after the point of the erase, including the <a class="el" href="classecuda_1_1vector.html#a4aed58e1d01bd42f214470671ab72ff4" title="Returns an iterator to the element following the last element of the container. ">end()</a> iterator. The iterator position must be valid and dereferencable. Thus the <a class="el" href="classecuda_1_1vector.html#a4aed58e1d01bd42f214470671ab72ff4" title="Returns an iterator to the element following the last element of the container. ">end()</a> iterator (which is valid, but not dereferencable) cannot be used as a value for position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>iterator to the element to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element. If the iterator position refers to the last element, the <a class="el" href="classecuda_1_1vector.html#a4aed58e1d01bd42f214470671ab72ff4" title="Returns an iterator to the element following the last element of the container. ">end()</a> iterator is returned. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00686">686</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a20d405046fd83ab61f41c08000f07590"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST <a class="el" href="classecuda_1_1vector.html#aeb6c5f81e617def3d16565716e3ee0cf">iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html#a49059fdbbb05ba52a1ff476945d6db6b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html#a49059fdbbb05ba52a1ff476945d6db6b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the elements in the range [first,last). </p>
<p>Invalidates iterators and references at or after the point of the erase, including the <a class="el" href="classecuda_1_1vector.html#a4aed58e1d01bd42f214470671ab72ff4" title="Returns an iterator to the element following the last element of the container. ">end()</a> iterator. The iterator position must be valid and dereferencable. Thus the <a class="el" href="classecuda_1_1vector.html#a4aed58e1d01bd42f214470671ab72ff4" title="Returns an iterator to the element following the last element of the container. ">end()</a> iterator (which is valid, but not dereferencable) cannot be used as a value for position. The iterator first does not need to be dereferencable if first==last: erasing an empty range is a no-op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,last</td><td>range of elements to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element. If the iterator position refers to the last element, the <a class="el" href="classecuda_1_1vector.html#a4aed58e1d01bd42f214470671ab72ff4" title="Returns an iterator to the element following the last element of the container. ">end()</a> iterator is returned. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00706">706</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9494b0c6b68324807229874b1bdae5f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEVICE <a class="el" href="classecuda_1_1vector.html#adf161ce7503d2bb75c329a71e6d4413e">reference</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the container. </p>
<p>Calling front on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00433">433</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae873cbec6bf97605a2fc77e07add08f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEVICE <a class="el" href="classecuda_1_1vector.html#a07305c387f4c2134aaaed0d99ce87a03">const_reference</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the container. </p>
<p>Calling front on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00451">451</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae6af1464f880951ab696a03a4cadd6d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST <a class="el" href="classecuda_1_1vector.html#a7b94fcad8e25670029d3892edc53f124">allocator_type</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator associated with the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The associated allocator. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00752">752</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afda127f16a74f774ebe77f275a12ee20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST <a class="el" href="classecuda_1_1vector.html#aeb6c5f81e617def3d16565716e3ee0cf">iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html#a49059fdbbb05ba52a1ff476945d6db6b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts value before position. </p>
<p>Causes reallocation if the new <a class="el" href="classecuda_1_1vector.html#aa205d2d46367666470c4c2eda19a1828" title="Returns the number of elements in the container. ">size()</a> is greater than the old <a class="el" href="classecuda_1_1vector.html#a348205463812273f1c97c13696032ee6" title="Returns the number of elements that the container has currently allocated space for. ">capacity()</a>. If the new <a class="el" href="classecuda_1_1vector.html#aa205d2d46367666470c4c2eda19a1828" title="Returns the number of elements in the container. ">size()</a> is greater than <a class="el" href="classecuda_1_1vector.html#a348205463812273f1c97c13696032ee6" title="Returns the number of elements that the container has currently allocated space for. ">capacity()</a>, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>iterator before which the content will be inserted. position may be the <a class="el" href="classecuda_1_1vector.html#a4aed58e1d01bd42f214470671ab72ff4" title="Returns an iterator to the element following the last element of the container. ">end()</a> iterator </td></tr>
    <tr><td class="paramname">value</td><td>element value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to the inserted value </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00570">570</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a02e4e5f3b897d06a8c3b85a1d1cad552"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST <a class="el" href="classecuda_1_1vector.html#aeb6c5f81e617def3d16565716e3ee0cf">iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html#a49059fdbbb05ba52a1ff476945d6db6b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#a4360b100af6758b359fe4d62a5399d1f">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts count copies of the value before position. </p>
<p>Causes reallocation if the new <a class="el" href="classecuda_1_1vector.html#aa205d2d46367666470c4c2eda19a1828" title="Returns the number of elements in the container. ">size()</a> is greater than the old <a class="el" href="classecuda_1_1vector.html#a348205463812273f1c97c13696032ee6" title="Returns the number of elements that the container has currently allocated space for. ">capacity()</a>. If the new <a class="el" href="classecuda_1_1vector.html#aa205d2d46367666470c4c2eda19a1828" title="Returns the number of elements in the container. ">size()</a> is greater than <a class="el" href="classecuda_1_1vector.html#a348205463812273f1c97c13696032ee6" title="Returns the number of elements that the container has currently allocated space for. ">capacity()</a>, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>iterator before which the content will be inserted. position may be the <a class="el" href="classecuda_1_1vector.html#a4aed58e1d01bd42f214470671ab72ff4" title="Returns an iterator to the element following the last element of the container. ">end()</a> iterator </td></tr>
    <tr><td class="paramname">count</td><td>number of copies of value to insert </td></tr>
    <tr><td class="paramname">value</td><td>element value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to the inserted value </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00596">596</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afee1cba5509af06ca513bd68f5a0df27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST void <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html#a49059fdbbb05ba52a1ff476945d6db6b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from range [first,last) before position. </p>
<p>Causes reallocation if the new <a class="el" href="classecuda_1_1vector.html#aa205d2d46367666470c4c2eda19a1828" title="Returns the number of elements in the container. ">size()</a> is greater than the old <a class="el" href="classecuda_1_1vector.html#a348205463812273f1c97c13696032ee6" title="Returns the number of elements that the container has currently allocated space for. ">capacity()</a>. If the new <a class="el" href="classecuda_1_1vector.html#aa205d2d46367666470c4c2eda19a1828" title="Returns the number of elements in the container. ">size()</a> is greater than <a class="el" href="classecuda_1_1vector.html#a348205463812273f1c97c13696032ee6" title="Returns the number of elements that the container has currently allocated space for. ">capacity()</a>, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>iterator before which the content will be inserted. position may be the <a class="el" href="classecuda_1_1vector.html#a4aed58e1d01bd42f214470671ab72ff4" title="Returns an iterator to the element following the last element of the container. ">end()</a> iterator </td></tr>
    <tr><td class="paramname">first,last</td><td>the range of elements to insert, can't be iterators into container for which insert is called </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00641">641</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac3dd8c27ee3187f2468f7036c7764373"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST void <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html#a49059fdbbb05ba52a1ff476945d6db6b">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from initializer_list before position. </p>
<p>Causes reallocation if the new <a class="el" href="classecuda_1_1vector.html#aa205d2d46367666470c4c2eda19a1828" title="Returns the number of elements in the container. ">size()</a> is greater than the old <a class="el" href="classecuda_1_1vector.html#a348205463812273f1c97c13696032ee6" title="Returns the number of elements that the container has currently allocated space for. ">capacity()</a>. If the new <a class="el" href="classecuda_1_1vector.html#aa205d2d46367666470c4c2eda19a1828" title="Returns the number of elements in the container. ">size()</a> is greater than <a class="el" href="classecuda_1_1vector.html#a348205463812273f1c97c13696032ee6" title="Returns the number of elements that the container has currently allocated space for. ">capacity()</a>, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</p>
<p>This operator is only available if the compiler is configured to allow C++11.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>iterator before which the content will be inserted. position may be the <a class="el" href="classecuda_1_1vector.html#a4aed58e1d01bd42f214470671ab72ff4" title="Returns an iterator to the element following the last element of the container. ">end()</a> iterator </td></tr>
    <tr><td class="paramname">il</td><td>initializer list to insert values from </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00668">668</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac23c4ce0190a3db78e826e719bcba9b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE __CONSTEXPR__ <a class="el" href="classecuda_1_1vector.html#a4360b100af6758b359fe4d62a5399d1f">size_type</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements the container is able to hold due to system or library implementation limitations. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of elements. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00355">355</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a76cd702a932de97fd0d2a8639f270941"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html">vector</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the contents of two arrays are not equal. </p>
<p>That is, whether <a class="el" href="classecuda_1_1vector.html#aa205d2d46367666470c4c2eda19a1828" title="Returns the number of elements in the container. ">size()</a> != other.size() or whether any element in the this vector does not compare equal to the element in the other vector at the same position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents are not equal, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00803">803</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a172bf17497dda9b3b8ece118ae23e09f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html">vector</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two vectors lexicographically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of this vector are lexicographically less than the other vector, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00811">811</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa6696c389e290eb4676195b4356a645b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST <a class="el" href="classecuda_1_1vector.html">vector</a>&amp; <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the contents of a container to this device array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>container to copy contents from </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00872">872</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab345fe46f55c842d2c1ba010c31a6bb7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html">vector</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two vectors lexicographically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of this vector are lexicographically less than or equal to the other vector, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00845">845</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad1da059d31e44de14f076597b5f5473b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html">vector</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the contents of two vectors are equal. </p>
<p>That is, whether <a class="el" href="classecuda_1_1vector.html#aa205d2d46367666470c4c2eda19a1828" title="Returns the number of elements in the container. ">size()</a> == other.size() and each element in the this vector compares equal with the element in the other vector at the same position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents are equal, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00779">779</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a99e39be5d7750c6b808b3b9ff1f44bc9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html">vector</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two vectors lexicographically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of this vector are lexicographically greater than the other vector, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00828">828</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a845f28fc24b299bde1654b903d66384d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html">vector</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two vectors lexicographically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of this vector are lexicographically greater than or equal to the other vector, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00853">853</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f1a70b8148ab4af057050a140538884"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST Container&amp; <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the contents of this device vector to another container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>container to copy contents to </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00861">861</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6d3dedc0c021959091eb99b54f713f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEVICE <a class="el" href="classecuda_1_1vector.html#adf161ce7503d2bb75c329a71e6d4413e">reference</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#a4360b100af6758b359fe4d62a5399d1f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location index. No bounds checking is performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>position of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00407">407</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a17f38434341be0d09f7ed1c729ee9447"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEVICE <a class="el" href="classecuda_1_1vector.html#a07305c387f4c2134aaaed0d99ce87a03">const_reference</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#a4360b100af6758b359fe4d62a5399d1f">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location index. No bounds checking is performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>position of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00415">415</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac1016ac07fb5980344060f195953ce95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE void <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last element of the container. </p>
<p>Calling pop_back on an empty container is undefined. No iterators or references expect for <a class="el" href="classecuda_1_1vector.html#a47096884dbc7e473635b43a655691111" title="Returns a reference to the last element in the container. ">back()</a> and <a class="el" href="classecuda_1_1vector.html#a4aed58e1d01bd42f214470671ab72ff4" title="Returns an iterator to the element following the last element of the container. ">end()</a> are invalidated.</p>
<p>Although this can be called from both the host and device, a call from the device removes the last element of the container in the calling thread only. </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00556">556</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aff584404ff28a5fc88187fe9e4138ece"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST void <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value of the element to append </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00525">525</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aad51e742ab7a799698c93f02b5e83e17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#ae0556d788dc27375aa65398d8731f437">reverse_iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed container. </p>
<p>It corresponds to the last element of the non-reversed container.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00304">304</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a76e5fb030a8e3bc4536fdb615833d822"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#aac0540b79731122af43dc10e96f28624">const_reverse_iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed container. </p>
<p>It corresponds to the last element of the non-reversed container.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00323">323</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad33e5783118b3c0639f81bb410c117b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#ae0556d788dc27375aa65398d8731f437">reverse_iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed container. </p>
<p>It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00314">314</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5059da0a53e5238ffddc5d6043242856"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#aac0540b79731122af43dc10e96f28624">const_reverse_iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed container. </p>
<p>It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00333">333</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aee4c98b533ab9759b444cbdf45d44d3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST void <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html#a4360b100af6758b359fe4d62a5399d1f">size_type</a>&#160;</td>
          <td class="paramname"><em>newCapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increase the capacity of the container to a value that's greater or equal to newCapacity. </p>
<p>If newCapacity is greater than the current <a class="el" href="classecuda_1_1vector.html#a348205463812273f1c97c13696032ee6" title="Returns the number of elements that the container has currently allocated space for. ">capacity()</a>, new storage is allocated, otherwise the method does nothing.</p>
<p>If newCapacity is greater than <a class="el" href="classecuda_1_1vector.html#a348205463812273f1c97c13696032ee6" title="Returns the number of elements that the container has currently allocated space for. ">capacity()</a>, all iterators and references, including the past-the-end iterator, are invalidated. Otherwise, no iterators or references are invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newCapacity</td><td>new capacity of the container </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00399">399</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab2db91bdd67ced4bf70288e2bd727549"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST void <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html#a4360b100af6758b359fe4d62a5399d1f">size_type</a>&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code><a class="el" href="classecuda_1_1vector.html#ae56bbcd61835f36a582c289667f9ac00">value_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain newSize elements. </p>
<p>If the current size is greater than newSize, the container is reduced to its first newSize elements as if by repeatedly calling <a class="el" href="classecuda_1_1vector.html#ac1016ac07fb5980344060f195953ce95" title="Removes the last element of the container. ">pop_back()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>new size of the container </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize the new elements with </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00366">366</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a54f3ff42433bd3e8ece9ddd736fd6501"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST void <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests the removal of unused capacity. </p>
<p>The STL specification describes this as a non-binding request to reduce <a class="el" href="classecuda_1_1vector.html#a348205463812273f1c97c13696032ee6" title="Returns the number of elements that the container has currently allocated space for. ">capacity()</a> to <a class="el" href="classecuda_1_1vector.html#aa205d2d46367666470c4c2eda19a1828" title="Returns the number of elements in the container. ">size()</a> and it depends on the implementation if the request is fulfilled. In this implementation, the request is always fulfilled. All iterators, including the past the end iterator, are potentially invalidated. </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00762">762</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa205d2d46367666470c4c2eda19a1828"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1vector.html#a4360b100af6758b359fe4d62a5399d1f">size_type</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00347">347</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9d8ac09770d4a4e6faec0c757f4526ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE void <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html">vector</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of the container with those of the other. </p>
<p>Does not invoke any move, copy, or swap operations on individual elements. All iterators and references remain valid. The past-the-end iterator is invalidated.</p>
<p>Although this can be called from both the host and device, a call from the device only swaps the contents of the containers in the calling thread only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to exchange the contents with </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00724">724</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/ecuda/<a class="el" href="vector_8hpp_source.html">vector.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 17 2015 00:25:39 for Extended CUDA Library (ecuda) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
