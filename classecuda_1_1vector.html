<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Extended CUDA Library (ecuda): ecuda::vector&lt; T, Alloc, P &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Extended CUDA Library (ecuda)
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceecuda.html">ecuda</a></li><li class="navelem"><a class="el" href="classecuda_1_1vector.html">vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classecuda_1_1vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ecuda::vector&lt; T, Alloc, P &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A resizable vector stored in device memory.  
 <a href="classecuda_1_1vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vector_8hpp_source.html">vector.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ecuda::vector&lt; T, Alloc, P &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classecuda_1_1vector.png" usemap="#ecuda::vector&lt; T, Alloc, P &gt;_map" alt=""/>
  <map id="ecuda::vector&lt; T, Alloc, P &gt;_map" name="ecuda::vector&lt; T, Alloc, P &gt;_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2fce6a91814889f308d95d1edff0523d"><td class="memItemLeft" align="right" valign="top">typedef base_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a2fce6a91814889f308d95d1edff0523d">value_type</a></td></tr>
<tr class="memdesc:a2fce6a91814889f308d95d1edff0523d"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell data type  <a href="#a2fce6a91814889f308d95d1edff0523d">More...</a><br/></td></tr>
<tr class="separator:a2fce6a91814889f308d95d1edff0523d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5887618cbd9688c7d66489ab58d0da27"><td class="memItemLeft" align="right" valign="top">typedef Alloc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a5887618cbd9688c7d66489ab58d0da27">allocator_type</a></td></tr>
<tr class="memdesc:a5887618cbd9688c7d66489ab58d0da27"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type  <a href="#a5887618cbd9688c7d66489ab58d0da27">More...</a><br/></td></tr>
<tr class="separator:a5887618cbd9688c7d66489ab58d0da27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5e9d0cbaeda2536c0a107d019bb8fd"><td class="memItemLeft" align="right" valign="top">typedef base_type::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a></td></tr>
<tr class="memdesc:aef5e9d0cbaeda2536c0a107d019bb8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned integral type  <a href="#aef5e9d0cbaeda2536c0a107d019bb8fd">More...</a><br/></td></tr>
<tr class="separator:aef5e9d0cbaeda2536c0a107d019bb8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c82f33941ca23ad61306e408912540"><td class="memItemLeft" align="right" valign="top">typedef base_type::difference_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a44c82f33941ca23ad61306e408912540">difference_type</a></td></tr>
<tr class="memdesc:a44c82f33941ca23ad61306e408912540"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed integral type  <a href="#a44c82f33941ca23ad61306e408912540">More...</a><br/></td></tr>
<tr class="separator:a44c82f33941ca23ad61306e408912540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace31b171d581a33a3a443257df12d1fe"><td class="memItemLeft" align="right" valign="top">typedef Alloc::reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ace31b171d581a33a3a443257df12d1fe">reference</a></td></tr>
<tr class="memdesc:ace31b171d581a33a3a443257df12d1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell reference type  <a href="#ace31b171d581a33a3a443257df12d1fe">More...</a><br/></td></tr>
<tr class="separator:ace31b171d581a33a3a443257df12d1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ff21cadb8d9e21856b6891545ffca6"><td class="memItemLeft" align="right" valign="top">typedef Alloc::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a31ff21cadb8d9e21856b6891545ffca6">const_reference</a></td></tr>
<tr class="memdesc:a31ff21cadb8d9e21856b6891545ffca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell const reference type  <a href="#a31ff21cadb8d9e21856b6891545ffca6">More...</a><br/></td></tr>
<tr class="separator:a31ff21cadb8d9e21856b6891545ffca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77286106db562adc8d4e97a2b45564d9"><td class="memItemLeft" align="right" valign="top">typedef Alloc::pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a77286106db562adc8d4e97a2b45564d9">pointer</a></td></tr>
<tr class="memdesc:a77286106db562adc8d4e97a2b45564d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell pointer type  <a href="#a77286106db562adc8d4e97a2b45564d9">More...</a><br/></td></tr>
<tr class="separator:a77286106db562adc8d4e97a2b45564d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563f5301987bf77d3077d91e5127735c"><td class="memItemLeft" align="right" valign="top">typedef Alloc::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a563f5301987bf77d3077d91e5127735c">const_pointer</a></td></tr>
<tr class="memdesc:a563f5301987bf77d3077d91e5127735c"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell const pointer type  <a href="#a563f5301987bf77d3077d91e5127735c">More...</a><br/></td></tr>
<tr class="separator:a563f5301987bf77d3077d91e5127735c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad089d619255734bebaa895b4284dd559"><td class="memItemLeft" align="right" valign="top">typedef base_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ad089d619255734bebaa895b4284dd559">iterator</a></td></tr>
<tr class="memdesc:ad089d619255734bebaa895b4284dd559"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator type  <a href="#ad089d619255734bebaa895b4284dd559">More...</a><br/></td></tr>
<tr class="separator:ad089d619255734bebaa895b4284dd559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7945ab744faec01bd4717b3c4a8b5c37"><td class="memItemLeft" align="right" valign="top">typedef base_type::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a7945ab744faec01bd4717b3c4a8b5c37">const_iterator</a></td></tr>
<tr class="memdesc:a7945ab744faec01bd4717b3c4a8b5c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">const iterator type  <a href="#a7945ab744faec01bd4717b3c4a8b5c37">More...</a><br/></td></tr>
<tr class="separator:a7945ab744faec01bd4717b3c4a8b5c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b3d926bd37fe75ada2be8e1ffbcab5"><td class="memItemLeft" align="right" valign="top">typedef base_type::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#af5b3d926bd37fe75ada2be8e1ffbcab5">reverse_iterator</a></td></tr>
<tr class="memdesc:af5b3d926bd37fe75ada2be8e1ffbcab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">reverse iterator type  <a href="#af5b3d926bd37fe75ada2be8e1ffbcab5">More...</a><br/></td></tr>
<tr class="separator:af5b3d926bd37fe75ada2be8e1ffbcab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ea27e653f53ba8ae3a1cea96fd317f"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
base_type::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ac6ea27e653f53ba8ae3a1cea96fd317f">const_reverse_iterator</a></td></tr>
<tr class="memdesc:ac6ea27e653f53ba8ae3a1cea96fd317f"><td class="mdescLeft">&#160;</td><td class="mdescRight">const reverse iterator type  <a href="#ac6ea27e653f53ba8ae3a1cea96fd317f">More...</a><br/></td></tr>
<tr class="separator:ac6ea27e653f53ba8ae3a1cea96fd317f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ba7cbc4f9ebfee1d5ec8cbac83be4d"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
impl::vector_kernel_argument<br class="typebreak"/>
&lt; T, Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a18ba7cbc4f9ebfee1d5ec8cbac83be4d">kernel_argument</a></td></tr>
<tr class="memdesc:a18ba7cbc4f9ebfee1d5ec8cbac83be4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">kernel argument type  <a href="#a18ba7cbc4f9ebfee1d5ec8cbac83be4d">More...</a><br/></td></tr>
<tr class="separator:a18ba7cbc4f9ebfee1d5ec8cbac83be4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76006899e4498393c189e5dd2ef68e1"><td class="memItemLeft" align="right" valign="top">typedef const <br class="typebreak"/>
impl::vector_kernel_argument<br class="typebreak"/>
&lt; T, Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#af76006899e4498393c189e5dd2ef68e1">const_kernel_argument</a></td></tr>
<tr class="memdesc:af76006899e4498393c189e5dd2ef68e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">const kernel argument type  <a href="#af76006899e4498393c189e5dd2ef68e1">More...</a><br/></td></tr>
<tr class="separator:af76006899e4498393c189e5dd2ef68e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa8827006a23c2a26314ee6d46bdc34e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#aa8827006a23c2a26314ee6d46bdc34e2">vector</a> (const <a class="el" href="classecuda_1_1vector.html#a5887618cbd9688c7d66489ab58d0da27">allocator_type</a> &amp;allocator=<a class="el" href="classecuda_1_1vector.html#a5887618cbd9688c7d66489ab58d0da27">allocator_type</a>())</td></tr>
<tr class="memdesc:aa8827006a23c2a26314ee6d46bdc34e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. Constructs empty container.  <a href="#aa8827006a23c2a26314ee6d46bdc34e2">More...</a><br/></td></tr>
<tr class="separator:aa8827006a23c2a26314ee6d46bdc34e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0a48030af8e5ae087c1dac6a4e5cba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a1d0a48030af8e5ae087c1dac6a4e5cba">vector</a> (<a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a> n, const <a class="el" href="classecuda_1_1vector.html#a2fce6a91814889f308d95d1edff0523d">value_type</a> &amp;value, const <a class="el" href="classecuda_1_1vector.html#a5887618cbd9688c7d66489ab58d0da27">allocator_type</a> &amp;allocator=<a class="el" href="classecuda_1_1vector.html#a5887618cbd9688c7d66489ab58d0da27">allocator_type</a>())</td></tr>
<tr class="memdesc:a1d0a48030af8e5ae087c1dac6a4e5cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with n copies of elements with value value.  <a href="#a1d0a48030af8e5ae087c1dac6a4e5cba">More...</a><br/></td></tr>
<tr class="separator:a1d0a48030af8e5ae087c1dac6a4e5cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133ff827959406e5d8c39d8a979ac0d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a133ff827959406e5d8c39d8a979ac0d1">vector</a> (<a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a> n)</td></tr>
<tr class="memdesc:a133ff827959406e5d8c39d8a979ac0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with n default-inserted instances of T. No copies are made.  <a href="#a133ff827959406e5d8c39d8a979ac0d1">More...</a><br/></td></tr>
<tr class="separator:a133ff827959406e5d8c39d8a979ac0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27f032107aa3ef0e80ff565f03a11d9"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:ae27f032107aa3ef0e80ff565f03a11d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ae27f032107aa3ef0e80ff565f03a11d9">vector</a> (Iterator first, Iterator last, const <a class="el" href="classecuda_1_1vector.html#a5887618cbd9688c7d66489ab58d0da27">allocator_type</a> &amp;allocator=<a class="el" href="classecuda_1_1vector.html#a5887618cbd9688c7d66489ab58d0da27">allocator_type</a>())</td></tr>
<tr class="memdesc:ae27f032107aa3ef0e80ff565f03a11d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the range [begin,end).  <a href="#ae27f032107aa3ef0e80ff565f03a11d9">More...</a><br/></td></tr>
<tr class="separator:ae27f032107aa3ef0e80ff565f03a11d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb12b998a516e5bea3cc04151e209c50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#afb12b998a516e5bea3cc04151e209c50">vector</a> (const <a class="el" href="classecuda_1_1vector.html">vector</a> &amp;src)</td></tr>
<tr class="memdesc:afb12b998a516e5bea3cc04151e209c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#afb12b998a516e5bea3cc04151e209c50">More...</a><br/></td></tr>
<tr class="separator:afb12b998a516e5bea3cc04151e209c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27e56dafd12086209042838abbcf58e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1vector.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ad27e56dafd12086209042838abbcf58e">operator=</a> (const <a class="el" href="classecuda_1_1vector.html">vector</a> &amp;src)</td></tr>
<tr class="separator:ad27e56dafd12086209042838abbcf58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349bbad8dcc59294fd9eb977569a2709"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#ad089d619255734bebaa895b4284dd559">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a349bbad8dcc59294fd9eb977569a2709">begin</a> () <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:a349bbad8dcc59294fd9eb977569a2709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="#a349bbad8dcc59294fd9eb977569a2709">More...</a><br/></td></tr>
<tr class="separator:a349bbad8dcc59294fd9eb977569a2709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0acbfb1488fe04fe136df3b6c5cd8c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#ad089d619255734bebaa895b4284dd559">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#af0acbfb1488fe04fe136df3b6c5cd8c3">end</a> () <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:af0acbfb1488fe04fe136df3b6c5cd8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="#af0acbfb1488fe04fe136df3b6c5cd8c3">More...</a><br/></td></tr>
<tr class="separator:af0acbfb1488fe04fe136df3b6c5cd8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1627e625810bbd3df1e4090037f69618"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#a7945ab744faec01bd4717b3c4a8b5c37">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a1627e625810bbd3df1e4090037f69618">begin</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:a1627e625810bbd3df1e4090037f69618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="#a1627e625810bbd3df1e4090037f69618">More...</a><br/></td></tr>
<tr class="separator:a1627e625810bbd3df1e4090037f69618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07113a707e3534e4463ddb5398ecc6b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#a7945ab744faec01bd4717b3c4a8b5c37">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a07113a707e3534e4463ddb5398ecc6b5">end</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:a07113a707e3534e4463ddb5398ecc6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="#a07113a707e3534e4463ddb5398ecc6b5">More...</a><br/></td></tr>
<tr class="separator:a07113a707e3534e4463ddb5398ecc6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af377e335fb30c8cf12afcca2fa5a30c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <br class="typebreak"/>
<a class="el" href="classecuda_1_1vector.html#af5b3d926bd37fe75ada2be8e1ffbcab5">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#af377e335fb30c8cf12afcca2fa5a30c5">rbegin</a> () <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:af377e335fb30c8cf12afcca2fa5a30c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed container.  <a href="#af377e335fb30c8cf12afcca2fa5a30c5">More...</a><br/></td></tr>
<tr class="separator:af377e335fb30c8cf12afcca2fa5a30c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ca4f39d5a532de9ca93fd9dd8367b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <br class="typebreak"/>
<a class="el" href="classecuda_1_1vector.html#af5b3d926bd37fe75ada2be8e1ffbcab5">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#aa4ca4f39d5a532de9ca93fd9dd8367b2">rend</a> () <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:aa4ca4f39d5a532de9ca93fd9dd8367b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed container.  <a href="#aa4ca4f39d5a532de9ca93fd9dd8367b2">More...</a><br/></td></tr>
<tr class="separator:aa4ca4f39d5a532de9ca93fd9dd8367b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b4bf3e7674c91cc29f7fd4a5536dd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <br class="typebreak"/>
<a class="el" href="classecuda_1_1vector.html#ac6ea27e653f53ba8ae3a1cea96fd317f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a32b4bf3e7674c91cc29f7fd4a5536dd5">rbegin</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:a32b4bf3e7674c91cc29f7fd4a5536dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed container.  <a href="#a32b4bf3e7674c91cc29f7fd4a5536dd5">More...</a><br/></td></tr>
<tr class="separator:a32b4bf3e7674c91cc29f7fd4a5536dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804b14c44ca26e4a60099452008f40f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <br class="typebreak"/>
<a class="el" href="classecuda_1_1vector.html#ac6ea27e653f53ba8ae3a1cea96fd317f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a804b14c44ca26e4a60099452008f40f6">rend</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:a804b14c44ca26e4a60099452008f40f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed container.  <a href="#a804b14c44ca26e4a60099452008f40f6">More...</a><br/></td></tr>
<tr class="separator:a804b14c44ca26e4a60099452008f40f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16a3e7f04d5fabb57880ab06aee0dcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ad16a3e7f04d5fabb57880ab06aee0dcb">size</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:ad16a3e7f04d5fabb57880ab06aee0dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container.  <a href="#ad16a3e7f04d5fabb57880ab06aee0dcb">More...</a><br/></td></tr>
<tr class="separator:ad16a3e7f04d5fabb57880ab06aee0dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fb155d99d7d79d42cb110070335a62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <br class="typebreak"/>
<a class="el" href="global_8hpp.html#a9fec271a456e22bc9d8927abb3b8250d">__CONSTEXPR__</a> <a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a47fb155d99d7d79d42cb110070335a62">max_size</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:a47fb155d99d7d79d42cb110070335a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the container is able to hold due to system or library implementation limitations.  <a href="#a47fb155d99d7d79d42cb110070335a62">More...</a><br/></td></tr>
<tr class="separator:a47fb155d99d7d79d42cb110070335a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c587a73977d207bb1d0f5adb55a22e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a93c587a73977d207bb1d0f5adb55a22e">resize</a> (<a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a> newSize, const <a class="el" href="classecuda_1_1vector.html#a2fce6a91814889f308d95d1edff0523d">value_type</a> &amp;value=<a class="el" href="classecuda_1_1vector.html#a2fce6a91814889f308d95d1edff0523d">value_type</a>())</td></tr>
<tr class="memdesc:a93c587a73977d207bb1d0f5adb55a22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain newSize elements.  <a href="#a93c587a73977d207bb1d0f5adb55a22e">More...</a><br/></td></tr>
<tr class="separator:a93c587a73977d207bb1d0f5adb55a22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73e0c8899c54b7d2996a345e4218b9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ab73e0c8899c54b7d2996a345e4218b9f">capacity</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:ab73e0c8899c54b7d2996a345e4218b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements that the container has currently allocated space for.  <a href="#ab73e0c8899c54b7d2996a345e4218b9f">More...</a><br/></td></tr>
<tr class="separator:ab73e0c8899c54b7d2996a345e4218b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfde20484f8aa11714b60798a5757b12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#abfde20484f8aa11714b60798a5757b12">empty</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:abfde20484f8aa11714b60798a5757b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container has no elements.  <a href="#abfde20484f8aa11714b60798a5757b12">More...</a><br/></td></tr>
<tr class="separator:abfde20484f8aa11714b60798a5757b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6b414cf00029bc05f3e2541da97a25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a6f6b414cf00029bc05f3e2541da97a25">reserve</a> (<a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a> newCapacity)</td></tr>
<tr class="memdesc:a6f6b414cf00029bc05f3e2541da97a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the capacity of the container to a value that's greater or equal to newCapacity.  <a href="#a6f6b414cf00029bc05f3e2541da97a25">More...</a><br/></td></tr>
<tr class="separator:a6f6b414cf00029bc05f3e2541da97a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11dce1eafafb98aa36b62f3451c24c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#ace31b171d581a33a3a443257df12d1fe">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ac11dce1eafafb98aa36b62f3451c24c9">at</a> (<a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a> index)</td></tr>
<tr class="memdesc:ac11dce1eafafb98aa36b62f3451c24c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index, with bounds checking.  <a href="#ac11dce1eafafb98aa36b62f3451c24c9">More...</a><br/></td></tr>
<tr class="separator:ac11dce1eafafb98aa36b62f3451c24c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1fb514327f6e449ecf39cbf5224817"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#a31ff21cadb8d9e21856b6891545ffca6">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a3a1fb514327f6e449ecf39cbf5224817">at</a> (<a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a> index) const </td></tr>
<tr class="memdesc:a3a1fb514327f6e449ecf39cbf5224817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index, with bounds checking.  <a href="#a3a1fb514327f6e449ecf39cbf5224817">More...</a><br/></td></tr>
<tr class="separator:a3a1fb514327f6e449ecf39cbf5224817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095f075fde3a362c68fa82853fb9af0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#ace31b171d581a33a3a443257df12d1fe">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a095f075fde3a362c68fa82853fb9af0d">operator[]</a> (const <a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a> index)</td></tr>
<tr class="memdesc:a095f075fde3a362c68fa82853fb9af0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index. No bounds checking is performed.  <a href="#a095f075fde3a362c68fa82853fb9af0d">More...</a><br/></td></tr>
<tr class="separator:a095f075fde3a362c68fa82853fb9af0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e453580b39b046612c5985dd2dc16d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#a31ff21cadb8d9e21856b6891545ffca6">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a7e453580b39b046612c5985dd2dc16d5">operator[]</a> (const <a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a> index) const </td></tr>
<tr class="memdesc:a7e453580b39b046612c5985dd2dc16d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index. No bounds checking is performed.  <a href="#a7e453580b39b046612c5985dd2dc16d5">More...</a><br/></td></tr>
<tr class="separator:a7e453580b39b046612c5985dd2dc16d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ef097014dfe9e097aa613edb6bbae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#ace31b171d581a33a3a443257df12d1fe">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ac9ef097014dfe9e097aa613edb6bbae3">operator()</a> (const <a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a> index)</td></tr>
<tr class="memdesc:ac9ef097014dfe9e097aa613edb6bbae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index. No bounds checking is performed.  <a href="#ac9ef097014dfe9e097aa613edb6bbae3">More...</a><br/></td></tr>
<tr class="separator:ac9ef097014dfe9e097aa613edb6bbae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c6ce8ae4b3a03a0335e72227387035"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#a31ff21cadb8d9e21856b6891545ffca6">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a91c6ce8ae4b3a03a0335e72227387035">operator()</a> (const <a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a> index) const </td></tr>
<tr class="memdesc:a91c6ce8ae4b3a03a0335e72227387035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index. No bounds checking is performed.  <a href="#a91c6ce8ae4b3a03a0335e72227387035">More...</a><br/></td></tr>
<tr class="separator:a91c6ce8ae4b3a03a0335e72227387035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899b0276b4f45c67a5baf879f3abde24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#ace31b171d581a33a3a443257df12d1fe">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a899b0276b4f45c67a5baf879f3abde24">front</a> ()</td></tr>
<tr class="memdesc:a899b0276b4f45c67a5baf879f3abde24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container.  <a href="#a899b0276b4f45c67a5baf879f3abde24">More...</a><br/></td></tr>
<tr class="separator:a899b0276b4f45c67a5baf879f3abde24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac990d6c7ddf51327f6cc2db63f5145b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#ace31b171d581a33a3a443257df12d1fe">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ac990d6c7ddf51327f6cc2db63f5145b8">back</a> ()</td></tr>
<tr class="memdesc:ac990d6c7ddf51327f6cc2db63f5145b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container.  <a href="#ac990d6c7ddf51327f6cc2db63f5145b8">More...</a><br/></td></tr>
<tr class="separator:ac990d6c7ddf51327f6cc2db63f5145b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeebdd91d5b4b8b603ee5c646c65c823"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#a31ff21cadb8d9e21856b6891545ffca6">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#afeebdd91d5b4b8b603ee5c646c65c823">front</a> () const </td></tr>
<tr class="memdesc:afeebdd91d5b4b8b603ee5c646c65c823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container.  <a href="#afeebdd91d5b4b8b603ee5c646c65c823">More...</a><br/></td></tr>
<tr class="separator:afeebdd91d5b4b8b603ee5c646c65c823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b82e4fd0165302d847f5e145f040ebd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#a31ff21cadb8d9e21856b6891545ffca6">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a3b82e4fd0165302d847f5e145f040ebd">back</a> () const </td></tr>
<tr class="memdesc:a3b82e4fd0165302d847f5e145f040ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container.  <a href="#a3b82e4fd0165302d847f5e145f040ebd">More...</a><br/></td></tr>
<tr class="separator:a3b82e4fd0165302d847f5e145f040ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98395334dae4eb42782c0f4baaa7671"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#a77286106db562adc8d4e97a2b45564d9">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#af98395334dae4eb42782c0f4baaa7671">data</a> () <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:af98395334dae4eb42782c0f4baaa7671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage.  <a href="#af98395334dae4eb42782c0f4baaa7671">More...</a><br/></td></tr>
<tr class="separator:af98395334dae4eb42782c0f4baaa7671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5d286a052800bd3be9bcf489df9552"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#a563f5301987bf77d3077d91e5127735c">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a5d5d286a052800bd3be9bcf489df9552">data</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:a5d5d286a052800bd3be9bcf489df9552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage.  <a href="#a5d5d286a052800bd3be9bcf489df9552">More...</a><br/></td></tr>
<tr class="separator:a5d5d286a052800bd3be9bcf489df9552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae607e78a460ea63e371acb66e3602189"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ae607e78a460ea63e371acb66e3602189">assign</a> (<a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a> newSize, const <a class="el" href="classecuda_1_1vector.html#a2fce6a91814889f308d95d1edff0523d">value_type</a> &amp;value=<a class="el" href="classecuda_1_1vector.html#a2fce6a91814889f308d95d1edff0523d">value_type</a>())</td></tr>
<tr class="memdesc:ae607e78a460ea63e371acb66e3602189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the container.  <a href="#ae607e78a460ea63e371acb66e3602189">More...</a><br/></td></tr>
<tr class="separator:ae607e78a460ea63e371acb66e3602189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497d0f890b936ee610bd7809ceb3deaf"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:a497d0f890b936ee610bd7809ceb3deaf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a497d0f890b936ee610bd7809ceb3deaf">assign</a> (Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a497d0f890b936ee610bd7809ceb3deaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the container with copies of those in the range [first,last).  <a href="#a497d0f890b936ee610bd7809ceb3deaf">More...</a><br/></td></tr>
<tr class="separator:a497d0f890b936ee610bd7809ceb3deaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe197372024cc4644b0465c478a5771"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#aafe197372024cc4644b0465c478a5771">push_back</a> (const <a class="el" href="classecuda_1_1vector.html#a2fce6a91814889f308d95d1edff0523d">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:aafe197372024cc4644b0465c478a5771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given element value to the end of the container.  <a href="#aafe197372024cc4644b0465c478a5771">More...</a><br/></td></tr>
<tr class="separator:aafe197372024cc4644b0465c478a5771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac330b0bad34d3f9eddcb26f919f468a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ac330b0bad34d3f9eddcb26f919f468a8">pop_back</a> ()</td></tr>
<tr class="memdesc:ac330b0bad34d3f9eddcb26f919f468a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element of the container.  <a href="#ac330b0bad34d3f9eddcb26f919f468a8">More...</a><br/></td></tr>
<tr class="separator:ac330b0bad34d3f9eddcb26f919f468a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df939d3b084d053f22f4460f0fec9a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1vector.html#ad089d619255734bebaa895b4284dd559">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a3df939d3b084d053f22f4460f0fec9a2">insert</a> (<a class="el" href="classecuda_1_1vector.html#a7945ab744faec01bd4717b3c4a8b5c37">const_iterator</a> position, const <a class="el" href="classecuda_1_1vector.html#a2fce6a91814889f308d95d1edff0523d">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a3df939d3b084d053f22f4460f0fec9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts value before position.  <a href="#a3df939d3b084d053f22f4460f0fec9a2">More...</a><br/></td></tr>
<tr class="separator:a3df939d3b084d053f22f4460f0fec9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb863bbd7688ac8a1400c816ddad95a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1vector.html#ad089d619255734bebaa895b4284dd559">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a2bb863bbd7688ac8a1400c816ddad95a">insert</a> (<a class="el" href="classecuda_1_1vector.html#a7945ab744faec01bd4717b3c4a8b5c37">const_iterator</a> position, const <a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a> <a class="el" href="namespaceecuda.html#a902187585c1ae9933b4289ebbeef4d21">count</a>, const <a class="el" href="classecuda_1_1vector.html#a2fce6a91814889f308d95d1edff0523d">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a2bb863bbd7688ac8a1400c816ddad95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts count copies of the value before position.  <a href="#a2bb863bbd7688ac8a1400c816ddad95a">More...</a><br/></td></tr>
<tr class="separator:a2bb863bbd7688ac8a1400c816ddad95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5478a1ddbc31e3a038da5ff563ba15ac"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a5478a1ddbc31e3a038da5ff563ba15ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a5478a1ddbc31e3a038da5ff563ba15ac">insert</a> (<a class="el" href="classecuda_1_1vector.html#a7945ab744faec01bd4717b3c4a8b5c37">const_iterator</a> position, InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a5478a1ddbc31e3a038da5ff563ba15ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements from range [first,last) before position.  <a href="#a5478a1ddbc31e3a038da5ff563ba15ac">More...</a><br/></td></tr>
<tr class="separator:a5478a1ddbc31e3a038da5ff563ba15ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b812761ec020cc488da5e7f55902d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1vector.html#ad089d619255734bebaa895b4284dd559">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a35b812761ec020cc488da5e7f55902d2">erase</a> (<a class="el" href="classecuda_1_1vector.html#a7945ab744faec01bd4717b3c4a8b5c37">const_iterator</a> position)</td></tr>
<tr class="memdesc:a35b812761ec020cc488da5e7f55902d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element at position.  <a href="#a35b812761ec020cc488da5e7f55902d2">More...</a><br/></td></tr>
<tr class="separator:a35b812761ec020cc488da5e7f55902d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad321c5d54a8d72b7d01c6362732893c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1vector.html#ad089d619255734bebaa895b4284dd559">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ad321c5d54a8d72b7d01c6362732893c3">erase</a> (<a class="el" href="classecuda_1_1vector.html#a7945ab744faec01bd4717b3c4a8b5c37">const_iterator</a> first, <a class="el" href="classecuda_1_1vector.html#a7945ab744faec01bd4717b3c4a8b5c37">const_iterator</a> last)</td></tr>
<tr class="memdesc:ad321c5d54a8d72b7d01c6362732893c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements in the range [first,last).  <a href="#ad321c5d54a8d72b7d01c6362732893c3">More...</a><br/></td></tr>
<tr class="separator:ad321c5d54a8d72b7d01c6362732893c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638e60dcdad022976578312549f49c13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a638e60dcdad022976578312549f49c13">swap</a> (<a class="el" href="classecuda_1_1vector.html">vector</a> &amp;other)</td></tr>
<tr class="memdesc:a638e60dcdad022976578312549f49c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the container with those of the other.  <a href="#a638e60dcdad022976578312549f49c13">More...</a><br/></td></tr>
<tr class="separator:a638e60dcdad022976578312549f49c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8330b6cbf1d003030d84b656605b871d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a8330b6cbf1d003030d84b656605b871d">clear</a> ()</td></tr>
<tr class="memdesc:a8330b6cbf1d003030d84b656605b871d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the container.  <a href="#a8330b6cbf1d003030d84b656605b871d">More...</a><br/></td></tr>
<tr class="separator:a8330b6cbf1d003030d84b656605b871d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd242dd000249b8715cf4ef40e29f22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1vector.html#a5887618cbd9688c7d66489ab58d0da27">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a9dd242dd000249b8715cf4ef40e29f22">get_allocator</a> () const </td></tr>
<tr class="memdesc:a9dd242dd000249b8715cf4ef40e29f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the container.  <a href="#a9dd242dd000249b8715cf4ef40e29f22">More...</a><br/></td></tr>
<tr class="separator:a9dd242dd000249b8715cf4ef40e29f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22f50f85f55a2d831a9f0a645ab3d5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ab22f50f85f55a2d831a9f0a645ab3d5d">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:ab22f50f85f55a2d831a9f0a645ab3d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the removal of unused capacity.  <a href="#ab22f50f85f55a2d831a9f0a645ab3d5d">More...</a><br/></td></tr>
<tr class="separator:ab22f50f85f55a2d831a9f0a645ab3d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289067b4669862a37a49692b00ab9bf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a289067b4669862a37a49692b00ab9bf0">operator==</a> (const <a class="el" href="classecuda_1_1vector.html">vector</a> &amp;other) const </td></tr>
<tr class="memdesc:a289067b4669862a37a49692b00ab9bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of two vectors are equal.  <a href="#a289067b4669862a37a49692b00ab9bf0">More...</a><br/></td></tr>
<tr class="separator:a289067b4669862a37a49692b00ab9bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0a12bf93109985cb28be988c70ddb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a6a0a12bf93109985cb28be988c70ddb0">operator!=</a> (const <a class="el" href="classecuda_1_1vector.html">vector</a> &amp;other) const </td></tr>
<tr class="memdesc:a6a0a12bf93109985cb28be988c70ddb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of two arrays are not equal.  <a href="#a6a0a12bf93109985cb28be988c70ddb0">More...</a><br/></td></tr>
<tr class="separator:a6a0a12bf93109985cb28be988c70ddb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd9dcb2185d2953dc23587a1ce09537"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#affd9dcb2185d2953dc23587a1ce09537">operator&lt;</a> (const <a class="el" href="classecuda_1_1vector.html">vector</a> &amp;other) const </td></tr>
<tr class="memdesc:affd9dcb2185d2953dc23587a1ce09537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two vectors lexicographically.  <a href="#affd9dcb2185d2953dc23587a1ce09537">More...</a><br/></td></tr>
<tr class="separator:affd9dcb2185d2953dc23587a1ce09537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8eee6ce18fd9b2af53c13552c5b0609"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#ac8eee6ce18fd9b2af53c13552c5b0609">operator&gt;</a> (const <a class="el" href="classecuda_1_1vector.html">vector</a> &amp;other) const </td></tr>
<tr class="memdesc:ac8eee6ce18fd9b2af53c13552c5b0609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two vectors lexicographically.  <a href="#ac8eee6ce18fd9b2af53c13552c5b0609">More...</a><br/></td></tr>
<tr class="separator:ac8eee6ce18fd9b2af53c13552c5b0609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778da42875c4a98d9c3347e5fa213292"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a778da42875c4a98d9c3347e5fa213292">operator&lt;=</a> (const <a class="el" href="classecuda_1_1vector.html">vector</a> &amp;other) const </td></tr>
<tr class="memdesc:a778da42875c4a98d9c3347e5fa213292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two vectors lexicographically.  <a href="#a778da42875c4a98d9c3347e5fa213292">More...</a><br/></td></tr>
<tr class="separator:a778da42875c4a98d9c3347e5fa213292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff6acadf61314ee21152331a9f6ee04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a5ff6acadf61314ee21152331a9f6ee04">operator&gt;=</a> (const <a class="el" href="classecuda_1_1vector.html">vector</a> &amp;other) const </td></tr>
<tr class="memdesc:a5ff6acadf61314ee21152331a9f6ee04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two vectors lexicographically.  <a href="#a5ff6acadf61314ee21152331a9f6ee04">More...</a><br/></td></tr>
<tr class="separator:a5ff6acadf61314ee21152331a9f6ee04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a1481145cb8dfd597e872ce248645999b"><td class="memTemplParams" colspan="2">template&lt;typename U , class Alloc2 , class Q &gt; </td></tr>
<tr class="memitem:a1481145cb8dfd597e872ce248645999b"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html#a1481145cb8dfd597e872ce248645999b">vector</a></td></tr>
<tr class="separator:a1481145cb8dfd597e872ce248645999b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt;<br/>
class ecuda::vector&lt; T, Alloc, P &gt;</h3>

<p>A resizable vector stored in device memory. </p>
<p>Methods are prefaced with appropriate keywords to declare them as host and/or device capable. In general: operations requiring memory allocation/deallocation are host only, operations to access the values of specific elements are device only, and copy operations on ranges of data and accessors of general information can be performed on both the host and device.</p>
<p>Any growth of the vector follows a doubling pattern. The existing memory allocation size is doubled until the requested amount of memory is met or exceeded. In practice, vector growth, element insertions and so on, will be far faster with host memory and so it is preferred to do these kinds of operations in host code and then copy the final result into device memory.</p>
<div class="fragment"><div class="line"><span class="comment">// slow</span></div>
<div class="line"><a class="code" href="classecuda_1_1vector.html">ecuda::vector&lt;double&gt;</a> deviceVector;</div>
<div class="line"><span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i = 0; i &lt; 100; ++i ) deviceVector.<a class="code" href="classecuda_1_1vector.html#aafe197372024cc4644b0465c478a5771">push_back</a>( static_cast&lt;double&gt;(i) );</div>
<div class="line"></div>
<div class="line"><span class="comment">// fast</span></div>
<div class="line">std::vector&lt;double&gt; hostVector;</div>
<div class="line"><span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i = 0; i &lt; 100; ++i ) hostVector.push_back( static_cast&lt;double&gt;(i) );</div>
<div class="line"><a class="code" href="classecuda_1_1vector.html">ecuda::vector&lt;double&gt;</a> deviceVector( hostVector.begin(), hostVector.end() );</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00096">96</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a5887618cbd9688c7d66489ab58d0da27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Alloc <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1vector.html#a5887618cbd9688c7d66489ab58d0da27">allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocator type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00103">103</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7945ab744faec01bd4717b3c4a8b5c37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::const_iterator <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1vector.html#a7945ab744faec01bd4717b3c4a8b5c37">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const iterator type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00119">119</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af76006899e4498393c189e5dd2ef68e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const impl::vector_kernel_argument&lt;T,Alloc&gt; <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1vector.html#af76006899e4498393c189e5dd2ef68e1">const_kernel_argument</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const kernel argument type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00124">124</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a563f5301987bf77d3077d91e5127735c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Alloc::const_pointer <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1vector.html#a563f5301987bf77d3077d91e5127735c">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell const pointer type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00115">115</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a31ff21cadb8d9e21856b6891545ffca6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Alloc::const_reference <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1vector.html#a31ff21cadb8d9e21856b6891545ffca6">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell const reference type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00113">113</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac6ea27e653f53ba8ae3a1cea96fd317f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::const_reverse_iterator <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1vector.html#ac6ea27e653f53ba8ae3a1cea96fd317f">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const reverse iterator type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00121">121</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a44c82f33941ca23ad61306e408912540"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::difference_type <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1vector.html#a44c82f33941ca23ad61306e408912540">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>signed integral type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00105">105</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad089d619255734bebaa895b4284dd559"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::iterator <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1vector.html#ad089d619255734bebaa895b4284dd559">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iterator type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00118">118</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a18ba7cbc4f9ebfee1d5ec8cbac83be4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef impl::vector_kernel_argument&lt;T,Alloc&gt; <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1vector.html#a18ba7cbc4f9ebfee1d5ec8cbac83be4d">kernel_argument</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>kernel argument type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00123">123</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a77286106db562adc8d4e97a2b45564d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Alloc::pointer <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1vector.html#a77286106db562adc8d4e97a2b45564d9">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell pointer type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00114">114</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ace31b171d581a33a3a443257df12d1fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Alloc::reference <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1vector.html#ace31b171d581a33a3a443257df12d1fe">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell reference type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00112">112</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af5b3d926bd37fe75ada2be8e1ffbcab5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::reverse_iterator <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1vector.html#af5b3d926bd37fe75ada2be8e1ffbcab5">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reverse iterator type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00120">120</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef5e9d0cbaeda2536c0a107d019bb8fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::size_type <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unsigned integral type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00104">104</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2fce6a91814889f308d95d1edff0523d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::value_type <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1vector.html#a2fce6a91814889f308d95d1edff0523d">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell data type </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00102">102</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa8827006a23c2a26314ee6d46bdc34e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#a5887618cbd9688c7d66489ab58d0da27">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code><a class="el" href="classecuda_1_1vector.html#a5887618cbd9688c7d66489ab58d0da27">allocator_type</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. Constructs empty container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00176">176</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1d0a48030af8e5ae087c1dac6a4e5cba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#a2fce6a91814889f308d95d1edff0523d">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#a5887618cbd9688c7d66489ab58d0da27">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code><a class="el" href="classecuda_1_1vector.html#a5887618cbd9688c7d66489ab58d0da27">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with n copies of elements with value value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the size of the container </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize elements of the container with </td></tr>
    <tr><td class="paramname">allocator</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00184">184</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a133ff827959406e5d8c39d8a979ac0d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with n default-inserted instances of T. No copies are made. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the size of the container </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00193">193</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae27f032107aa3ef0e80ff565f03a11d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#a5887618cbd9688c7d66489ab58d0da27">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code><a class="el" href="classecuda_1_1vector.html#a5887618cbd9688c7d66489ab58d0da27">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the range [begin,end). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,last</td><td>the range to copy the elements from </td></tr>
    <tr><td class="paramname">allocator</td><td>allocator to use for all memory allocations of this container </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00204">204</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afb12b998a516e5bea3cc04151e209c50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html">vector</a>&lt; T, Alloc, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Constructs a vector with a copy of the contents of src.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Another vector object of the same type and size, whose contents are copied. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00217">217</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae607e78a460ea63e371acb66e3602189"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> void <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a>&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#a2fce6a91814889f308d95d1edff0523d">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code><a class="el" href="classecuda_1_1vector.html#a2fce6a91814889f308d95d1edff0523d">value_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>the new size of the container </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize elements of the container with </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00558">558</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a497d0f890b936ee610bd7809ceb3deaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> void <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents of the container with copies of those in the range [first,last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,last</td><td>the range to copy the elements from </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00570">570</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac11dce1eafafb98aa36b62f3451c24c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#ace31b171d581a33a3a443257df12d1fe">reference</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location index, with bounds checking. </p>
<p>If index is not within the range of the container, the current kernel will exit and cudaGetLastError will return cudaErrorUnknown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>position of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00420">420</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3a1fb514327f6e449ecf39cbf5224817"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#a31ff21cadb8d9e21856b6891545ffca6">const_reference</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location index, with bounds checking. </p>
<p>If index is not within the range of the container, the current kernel will exit and cudaGetLastError will return cudaErrorUnknown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>position of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00445">445</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac990d6c7ddf51327f6cc2db63f5145b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#ace31b171d581a33a3a443257df12d1fe">reference</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the container. </p>
<p>Calling back on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00513">513</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3b82e4fd0165302d847f5e145f040ebd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#a31ff21cadb8d9e21856b6891545ffca6">const_reference</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the container. </p>
<p>Calling back on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00531">531</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a349bbad8dcc59294fd9eb977569a2709"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#ad089d619255734bebaa895b4284dd559">iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classecuda_1_1vector.html#af0acbfb1488fe04fe136df3b6c5cd8c3" title="Returns an iterator to the element following the last element of the container. ">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00277">277</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1627e625810bbd3df1e4090037f69618"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#a7945ab744faec01bd4717b3c4a8b5c37">const_iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classecuda_1_1vector.html#af0acbfb1488fe04fe136df3b6c5cd8c3" title="Returns an iterator to the element following the last element of the container. ">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00295">295</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab73e0c8899c54b7d2996a345e4218b9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements that the container has currently allocated space for. </p>
<dl class="section return"><dt>Returns</dt><dd>Capacity of the currently allocated storage. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00389">389</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8330b6cbf1d003030d84b656605b871d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements from the container. </p>
<p>Invalidates all references, pointers, or iterators referring to contained elements. May invalidate any past-the-end iterators. Leaves the <a class="el" href="classecuda_1_1vector.html#ab73e0c8899c54b7d2996a345e4218b9f" title="Returns the number of elements that the container has currently allocated space for. ">capacity()</a> of the vector unchanged.</p>
<p>Although this can be called from both the host and device, a call from the device only clears the contents of the container in the calling thread only. </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00781">781</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af98395334dae4eb42782c0f4baaa7671"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#a77286106db562adc8d4e97a2b45564d9">pointer</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying array serving as element storage. </p>
<p>The pointer is such that range [<a class="el" href="classecuda_1_1vector.html#af98395334dae4eb42782c0f4baaa7671" title="Returns pointer to the underlying array serving as element storage. ">data()</a>,<a class="el" href="classecuda_1_1vector.html#af98395334dae4eb42782c0f4baaa7671" title="Returns pointer to the underlying array serving as element storage. ">data()</a>+size()) is always a valid range, even if the container is empty.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00541">541</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5d5d286a052800bd3be9bcf489df9552"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#a563f5301987bf77d3077d91e5127735c">const_pointer</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying array serving as element storage. </p>
<p>The pointer is such that range [<a class="el" href="classecuda_1_1vector.html#af98395334dae4eb42782c0f4baaa7671" title="Returns pointer to the underlying array serving as element storage. ">data()</a>,<a class="el" href="classecuda_1_1vector.html#af98395334dae4eb42782c0f4baaa7671" title="Returns pointer to the underlying array serving as element storage. ">data()</a>+size()) is always a valid range, even if the container is empty.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00551">551</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abfde20484f8aa11714b60798a5757b12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container has no elements. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the container is empty, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00396">396</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af0acbfb1488fe04fe136df3b6c5cd8c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#ad089d619255734bebaa895b4284dd559">iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>
<p>The element acts as a placeholder; attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00286">286</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a07113a707e3534e4463ddb5398ecc6b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#a7945ab744faec01bd4717b3c4a8b5c37">const_iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>
<p>The element acts as a placeholder; attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00304">304</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a35b812761ec020cc488da5e7f55902d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1vector.html#ad089d619255734bebaa895b4284dd559">iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html#a7945ab744faec01bd4717b3c4a8b5c37">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element at position. </p>
<p>Invalidates iterators and references at or after the point of the erase, including the <a class="el" href="classecuda_1_1vector.html#af0acbfb1488fe04fe136df3b6c5cd8c3" title="Returns an iterator to the element following the last element of the container. ">end()</a> iterator. The iterator position must be valid and dereferencable. Thus the <a class="el" href="classecuda_1_1vector.html#af0acbfb1488fe04fe136df3b6c5cd8c3" title="Returns an iterator to the element following the last element of the container. ">end()</a> iterator (which is valid, but not dereferencable) cannot be used as a value for position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>iterator to the element to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element. If the iterator position refers to the last element, the <a class="el" href="classecuda_1_1vector.html#af0acbfb1488fe04fe136df3b6c5cd8c3" title="Returns an iterator to the element following the last element of the container. ">end()</a> iterator is returned. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00726">726</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad321c5d54a8d72b7d01c6362732893c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1vector.html#ad089d619255734bebaa895b4284dd559">iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html#a7945ab744faec01bd4717b3c4a8b5c37">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html#a7945ab744faec01bd4717b3c4a8b5c37">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the elements in the range [first,last). </p>
<p>Invalidates iterators and references at or after the point of the erase, including the <a class="el" href="classecuda_1_1vector.html#af0acbfb1488fe04fe136df3b6c5cd8c3" title="Returns an iterator to the element following the last element of the container. ">end()</a> iterator. The iterator position must be valid and dereferencable. Thus the <a class="el" href="classecuda_1_1vector.html#af0acbfb1488fe04fe136df3b6c5cd8c3" title="Returns an iterator to the element following the last element of the container. ">end()</a> iterator (which is valid, but not dereferencable) cannot be used as a value for position. The iterator first does not need to be dereferencable if first==last: erasing an empty range is a no-op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,last</td><td>range of elements to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator following the last removed element. If the iterator position refers to the last element, the <a class="el" href="classecuda_1_1vector.html#af0acbfb1488fe04fe136df3b6c5cd8c3" title="Returns an iterator to the element following the last element of the container. ">end()</a> iterator is returned. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00747">747</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a899b0276b4f45c67a5baf879f3abde24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#ace31b171d581a33a3a443257df12d1fe">reference</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the container. </p>
<p>Calling front on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00504">504</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afeebdd91d5b4b8b603ee5c646c65c823"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#a31ff21cadb8d9e21856b6891545ffca6">const_reference</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the container. </p>
<p>Calling front on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00522">522</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9dd242dd000249b8715cf4ef40e29f22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1vector.html#a5887618cbd9688c7d66489ab58d0da27">allocator_type</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator associated with the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The associated allocator. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00787">787</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3df939d3b084d053f22f4460f0fec9a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1vector.html#ad089d619255734bebaa895b4284dd559">iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html#a7945ab744faec01bd4717b3c4a8b5c37">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#a2fce6a91814889f308d95d1edff0523d">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts value before position. </p>
<p>Causes reallocation if the new <a class="el" href="classecuda_1_1vector.html#ad16a3e7f04d5fabb57880ab06aee0dcb" title="Returns the number of elements in the container. ">size()</a> is greater than the old <a class="el" href="classecuda_1_1vector.html#ab73e0c8899c54b7d2996a345e4218b9f" title="Returns the number of elements that the container has currently allocated space for. ">capacity()</a>. If the new <a class="el" href="classecuda_1_1vector.html#ad16a3e7f04d5fabb57880ab06aee0dcb" title="Returns the number of elements in the container. ">size()</a> is greater than <a class="el" href="classecuda_1_1vector.html#ab73e0c8899c54b7d2996a345e4218b9f" title="Returns the number of elements that the container has currently allocated space for. ">capacity()</a>, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>iterator before which the content will be inserted. position may be the <a class="el" href="classecuda_1_1vector.html#af0acbfb1488fe04fe136df3b6c5cd8c3" title="Returns an iterator to the element following the last element of the container. ">end()</a> iterator </td></tr>
    <tr><td class="paramname">value</td><td>element value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to the inserted value </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00628">628</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2bb863bbd7688ac8a1400c816ddad95a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1vector.html#ad089d619255734bebaa895b4284dd559">iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html#a7945ab744faec01bd4717b3c4a8b5c37">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#a2fce6a91814889f308d95d1edff0523d">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts count copies of the value before position. </p>
<p>Causes reallocation if the new <a class="el" href="classecuda_1_1vector.html#ad16a3e7f04d5fabb57880ab06aee0dcb" title="Returns the number of elements in the container. ">size()</a> is greater than the old <a class="el" href="classecuda_1_1vector.html#ab73e0c8899c54b7d2996a345e4218b9f" title="Returns the number of elements that the container has currently allocated space for. ">capacity()</a>. If the new <a class="el" href="classecuda_1_1vector.html#ad16a3e7f04d5fabb57880ab06aee0dcb" title="Returns the number of elements in the container. ">size()</a> is greater than <a class="el" href="classecuda_1_1vector.html#ab73e0c8899c54b7d2996a345e4218b9f" title="Returns the number of elements that the container has currently allocated space for. ">capacity()</a>, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>iterator before which the content will be inserted. position may be the <a class="el" href="classecuda_1_1vector.html#af0acbfb1488fe04fe136df3b6c5cd8c3" title="Returns an iterator to the element following the last element of the container. ">end()</a> iterator </td></tr>
    <tr><td class="paramname">count</td><td>number of copies of value to insert </td></tr>
    <tr><td class="paramname">value</td><td>element value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing to the inserted value </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00655">655</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5478a1ddbc31e3a038da5ff563ba15ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> void <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html#a7945ab744faec01bd4717b3c4a8b5c37">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts elements from range [first,last) before position. </p>
<p>Causes reallocation if the new <a class="el" href="classecuda_1_1vector.html#ad16a3e7f04d5fabb57880ab06aee0dcb" title="Returns the number of elements in the container. ">size()</a> is greater than the old <a class="el" href="classecuda_1_1vector.html#ab73e0c8899c54b7d2996a345e4218b9f" title="Returns the number of elements that the container has currently allocated space for. ">capacity()</a>. If the new <a class="el" href="classecuda_1_1vector.html#ad16a3e7f04d5fabb57880ab06aee0dcb" title="Returns the number of elements in the container. ">size()</a> is greater than <a class="el" href="classecuda_1_1vector.html#ab73e0c8899c54b7d2996a345e4218b9f" title="Returns the number of elements that the container has currently allocated space for. ">capacity()</a>, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>iterator before which the content will be inserted. position may be the <a class="el" href="classecuda_1_1vector.html#af0acbfb1488fe04fe136df3b6c5cd8c3" title="Returns an iterator to the element following the last element of the container. ">end()</a> iterator </td></tr>
    <tr><td class="paramname">first,last</td><td>the range of elements to insert, can't be iterators into container for which insert is called </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00680">680</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a47fb155d99d7d79d42cb110070335a62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="global_8hpp.html#a9fec271a456e22bc9d8927abb3b8250d">__CONSTEXPR__</a> <a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements the container is able to hold due to system or library implementation limitations. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of elements. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00364">364</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6a0a12bf93109985cb28be988c70ddb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html">vector</a>&lt; T, Alloc, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the contents of two arrays are not equal. </p>
<p>That is, whether <a class="el" href="classecuda_1_1vector.html#ad16a3e7f04d5fabb57880ab06aee0dcb" title="Returns the number of elements in the container. ">size()</a> != other.size() or whether any element in the this vector does not compare equal to the element in the other vector at the same position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents are not equal, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00836">836</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac9ef097014dfe9e097aa613edb6bbae3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#ace31b171d581a33a3a443257df12d1fe">reference</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location index. No bounds checking is performed. </p>
<p>This is identical to operator[] but is present for consistency with higher-dimensional containers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>position of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00485">485</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a91c6ce8ae4b3a03a0335e72227387035"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#a31ff21cadb8d9e21856b6891545ffca6">const_reference</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location index. No bounds checking is performed. </p>
<p>This is identical to operator[] but is present for consistency with higher-dimensional containers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>position of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00495">495</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="affd9dcb2185d2953dc23587a1ce09537"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html">vector</a>&lt; T, Alloc, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two vectors lexicographically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of this vector are lexicographically less than the other vector, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00844">844</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a778da42875c4a98d9c3347e5fa213292"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html">vector</a>&lt; T, Alloc, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two vectors lexicographically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of this vector are lexicographically less than or equal to the other vector, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00880">880</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad27e56dafd12086209042838abbcf58e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1vector.html">vector</a>&amp; <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html">vector</a>&lt; T, Alloc, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00227">227</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a289067b4669862a37a49692b00ab9bf0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html">vector</a>&lt; T, Alloc, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the contents of two vectors are equal. </p>
<p>That is, whether <a class="el" href="classecuda_1_1vector.html#ad16a3e7f04d5fabb57880ab06aee0dcb" title="Returns the number of elements in the container. ">size()</a> == other.size() and each element in the this vector compares equal with the element in the other vector at the same position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents are equal, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00814">814</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac8eee6ce18fd9b2af53c13552c5b0609"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html">vector</a>&lt; T, Alloc, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two vectors lexicographically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of this vector are lexicographically greater than the other vector, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00862">862</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5ff6acadf61314ee21152331a9f6ee04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html">vector</a>&lt; T, Alloc, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two vectors lexicographically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of this vector are lexicographically greater than or equal to the other vector, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00888">888</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a095f075fde3a362c68fa82853fb9af0d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#ace31b171d581a33a3a443257df12d1fe">reference</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location index. No bounds checking is performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>position of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00467">467</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7e453580b39b046612c5985dd2dc16d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#a31ff21cadb8d9e21856b6891545ffca6">const_reference</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location index. No bounds checking is performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>position of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00475">475</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac330b0bad34d3f9eddcb26f919f468a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last element of the container. </p>
<p>Calling pop_back on an empty container is undefined. No iterators or references expect for <a class="el" href="classecuda_1_1vector.html#ac990d6c7ddf51327f6cc2db63f5145b8" title="Returns a reference to the last element in the container. ">back()</a> and <a class="el" href="classecuda_1_1vector.html#af0acbfb1488fe04fe136df3b6c5cd8c3" title="Returns an iterator to the element following the last element of the container. ">end()</a> are invalidated.</p>
<p>Although this can be called from both the host and device, a call from the device removes the last element of the container in the calling thread only. </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00614">614</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aafe197372024cc4644b0465c478a5771"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> void <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#a2fce6a91814889f308d95d1edff0523d">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given element value to the end of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value of the element to append </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00598">598</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af377e335fb30c8cf12afcca2fa5a30c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#af5b3d926bd37fe75ada2be8e1ffbcab5">reverse_iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed container. </p>
<p>It corresponds to the last element of the non-reversed container.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00313">313</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a32b4bf3e7674c91cc29f7fd4a5536dd5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#ac6ea27e653f53ba8ae3a1cea96fd317f">const_reverse_iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed container. </p>
<p>It corresponds to the last element of the non-reversed container.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00332">332</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa4ca4f39d5a532de9ca93fd9dd8367b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#af5b3d926bd37fe75ada2be8e1ffbcab5">reverse_iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed container. </p>
<p>It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00323">323</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a804b14c44ca26e4a60099452008f40f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#ac6ea27e653f53ba8ae3a1cea96fd317f">const_reverse_iterator</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed container. </p>
<p>It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00342">342</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f6b414cf00029bc05f3e2541da97a25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> void <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a>&#160;</td>
          <td class="paramname"><em>newCapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increase the capacity of the container to a value that's greater or equal to newCapacity. </p>
<p>If newCapacity is greater than the current <a class="el" href="classecuda_1_1vector.html#ab73e0c8899c54b7d2996a345e4218b9f" title="Returns the number of elements that the container has currently allocated space for. ">capacity()</a>, new storage is allocated, otherwise the method does nothing.</p>
<p>If newCapacity is greater than <a class="el" href="classecuda_1_1vector.html#ab73e0c8899c54b7d2996a345e4218b9f" title="Returns the number of elements that the container has currently allocated space for. ">capacity()</a>, all iterators and references, including the past-the-end iterator, are invalidated. Otherwise, no iterators or references are invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newCapacity</td><td>new capacity of the container </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00409">409</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a93c587a73977d207bb1d0f5adb55a22e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> void <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a>&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1vector.html#a2fce6a91814889f308d95d1edff0523d">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code><a class="el" href="classecuda_1_1vector.html#a2fce6a91814889f308d95d1edff0523d">value_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain newSize elements. </p>
<p>If the current size is greater than newSize, the container is reduced to its first newSize elements as if by repeatedly calling <a class="el" href="classecuda_1_1vector.html#ac330b0bad34d3f9eddcb26f919f468a8" title="Removes the last element of the container. ">pop_back()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>new size of the container </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize the new elements with </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00375">375</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab22f50f85f55a2d831a9f0a645ab3d5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> void <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests the removal of unused capacity. </p>
<p>The STL specification describes this as a non-binding request to reduce <a class="el" href="classecuda_1_1vector.html#ab73e0c8899c54b7d2996a345e4218b9f" title="Returns the number of elements that the container has currently allocated space for. ">capacity()</a> to <a class="el" href="classecuda_1_1vector.html#ad16a3e7f04d5fabb57880ab06aee0dcb" title="Returns the number of elements in the container. ">size()</a> and it depends on the implementation if the request is fulfilled. In this implementation, the request is always fulfilled. All iterators, including the past the end iterator, are potentially invalidated. </p>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00797">797</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad16a3e7f04d5fabb57880ab06aee0dcb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1vector.html#aef5e9d0cbaeda2536c0a107d019bb8fd">size_type</a> <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container. </dd></dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00356">356</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a638e60dcdad022976578312549f49c13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void <a class="el" href="classecuda_1_1vector.html">ecuda::vector</a>&lt; T, Alloc, P &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1vector.html">vector</a>&lt; T, Alloc, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of the container with those of the other. </p>
<p>Does not invoke any move, copy, or swap operations on individual elements. All iterators and references remain valid. The past-the-end iterator is invalidated.</p>
<p>Although this can be called from both the host and device, a call from the device only swaps the contents of the containers in the calling thread only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to exchange the contents with </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00766">766</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a1481145cb8dfd597e872ce248645999b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U , class Alloc2 , class Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classecuda_1_1vector.html">vector</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vector_8hpp_source.html#l00130">130</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/ecuda/<a class="el" href="vector_8hpp_source.html">vector.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 28 2016 14:05:58 for Extended CUDA Library (ecuda) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
