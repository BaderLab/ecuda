<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Extended CUDA Library (ecuda): ecuda::matrix&lt; T, Alloc, P &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Extended CUDA Library (ecuda)
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceecuda.html">ecuda</a></li><li class="navelem"><a class="el" href="classecuda_1_1matrix.html">matrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classecuda_1_1matrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ecuda::matrix&lt; T, Alloc, P &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A resizable matrix stored in device memory.  
 <a href="classecuda_1_1matrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ecuda::matrix&lt; T, Alloc, P &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classecuda_1_1matrix.png" usemap="#ecuda::matrix&lt; T, Alloc, P &gt;_map" alt=""/>
  <map id="ecuda::matrix&lt; T, Alloc, P &gt;_map" name="ecuda::matrix&lt; T, Alloc, P &gt;_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac5f815079bedbc3323e5c77116586886"><td class="memItemLeft" align="right" valign="top">typedef base_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ac5f815079bedbc3323e5c77116586886">value_type</a></td></tr>
<tr class="memdesc:ac5f815079bedbc3323e5c77116586886"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell data type  <a href="#ac5f815079bedbc3323e5c77116586886">More...</a><br/></td></tr>
<tr class="separator:ac5f815079bedbc3323e5c77116586886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e763cf80733b9d8acafd8cfcec1fd2"><td class="memItemLeft" align="right" valign="top">typedef Alloc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a74e763cf80733b9d8acafd8cfcec1fd2">allocator_type</a></td></tr>
<tr class="memdesc:a74e763cf80733b9d8acafd8cfcec1fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type  <a href="#a74e763cf80733b9d8acafd8cfcec1fd2">More...</a><br/></td></tr>
<tr class="separator:a74e763cf80733b9d8acafd8cfcec1fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc059f3d11827c75527cc8884d7c0ba"><td class="memItemLeft" align="right" valign="top">typedef base_type::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a></td></tr>
<tr class="memdesc:a2dc059f3d11827c75527cc8884d7c0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned integral type  <a href="#a2dc059f3d11827c75527cc8884d7c0ba">More...</a><br/></td></tr>
<tr class="separator:a2dc059f3d11827c75527cc8884d7c0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009307bfac8da5effa7bed37427f9661"><td class="memItemLeft" align="right" valign="top">typedef base_type::difference_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a009307bfac8da5effa7bed37427f9661">difference_type</a></td></tr>
<tr class="memdesc:a009307bfac8da5effa7bed37427f9661"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed integral type  <a href="#a009307bfac8da5effa7bed37427f9661">More...</a><br/></td></tr>
<tr class="separator:a009307bfac8da5effa7bed37427f9661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6463c15c6de5f1cd9ebe56d613ed3d32"><td class="memItemLeft" align="right" valign="top">typedef base_type::reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a6463c15c6de5f1cd9ebe56d613ed3d32">reference</a></td></tr>
<tr class="memdesc:a6463c15c6de5f1cd9ebe56d613ed3d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell reference type  <a href="#a6463c15c6de5f1cd9ebe56d613ed3d32">More...</a><br/></td></tr>
<tr class="separator:a6463c15c6de5f1cd9ebe56d613ed3d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad63fbf6e65de21bc5ef0b73f1da55c3"><td class="memItemLeft" align="right" valign="top">typedef base_type::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#aad63fbf6e65de21bc5ef0b73f1da55c3">const_reference</a></td></tr>
<tr class="memdesc:aad63fbf6e65de21bc5ef0b73f1da55c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell const reference type  <a href="#aad63fbf6e65de21bc5ef0b73f1da55c3">More...</a><br/></td></tr>
<tr class="separator:aad63fbf6e65de21bc5ef0b73f1da55c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eed3ea13e4cedec5e09b3a3dae6610e"><td class="memItemLeft" align="right" valign="top">typedef base_type::pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a4eed3ea13e4cedec5e09b3a3dae6610e">pointer</a></td></tr>
<tr class="memdesc:a4eed3ea13e4cedec5e09b3a3dae6610e"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell pointer type  <a href="#a4eed3ea13e4cedec5e09b3a3dae6610e">More...</a><br/></td></tr>
<tr class="separator:a4eed3ea13e4cedec5e09b3a3dae6610e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a617534ef25c6734126ba41440909c4"><td class="memItemLeft" align="right" valign="top">typedef make_const&lt; <a class="el" href="classecuda_1_1matrix.html#a4eed3ea13e4cedec5e09b3a3dae6610e">pointer</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a2a617534ef25c6734126ba41440909c4">const_pointer</a></td></tr>
<tr class="memdesc:a2a617534ef25c6734126ba41440909c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell const pointer type  <a href="#a2a617534ef25c6734126ba41440909c4">More...</a><br/></td></tr>
<tr class="separator:a2a617534ef25c6734126ba41440909c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7947927ff51492aaa2e788151befca99"><td class="memItemLeft" align="right" valign="top">typedef base_type::row_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a7947927ff51492aaa2e788151befca99">row_type</a></td></tr>
<tr class="memdesc:a7947927ff51492aaa2e788151befca99"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix row container type  <a href="#a7947927ff51492aaa2e788151befca99">More...</a><br/></td></tr>
<tr class="separator:a7947927ff51492aaa2e788151befca99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48381b66921d28af72aba77fc050ddd6"><td class="memItemLeft" align="right" valign="top">typedef base_type::column_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a48381b66921d28af72aba77fc050ddd6">column_type</a></td></tr>
<tr class="memdesc:a48381b66921d28af72aba77fc050ddd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix column container type  <a href="#a48381b66921d28af72aba77fc050ddd6">More...</a><br/></td></tr>
<tr class="separator:a48381b66921d28af72aba77fc050ddd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ffcd571700bbe2403095403cd445f9"><td class="memItemLeft" align="right" valign="top">typedef base_type::const_row_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ad0ffcd571700bbe2403095403cd445f9">const_row_type</a></td></tr>
<tr class="memdesc:ad0ffcd571700bbe2403095403cd445f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix const row container type  <a href="#ad0ffcd571700bbe2403095403cd445f9">More...</a><br/></td></tr>
<tr class="separator:ad0ffcd571700bbe2403095403cd445f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6206e8f8dfd5a5971cc066ad48aa8ee5"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
base_type::const_column_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a6206e8f8dfd5a5971cc066ad48aa8ee5">const_column_type</a></td></tr>
<tr class="memdesc:a6206e8f8dfd5a5971cc066ad48aa8ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix const column container type  <a href="#a6206e8f8dfd5a5971cc066ad48aa8ee5">More...</a><br/></td></tr>
<tr class="separator:a6206e8f8dfd5a5971cc066ad48aa8ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf32fbe2a3d9be37375ec9f0bb2b161f"><td class="memItemLeft" align="right" valign="top">typedef base_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#acf32fbe2a3d9be37375ec9f0bb2b161f">iterator</a></td></tr>
<tr class="memdesc:acf32fbe2a3d9be37375ec9f0bb2b161f"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator type  <a href="#acf32fbe2a3d9be37375ec9f0bb2b161f">More...</a><br/></td></tr>
<tr class="separator:acf32fbe2a3d9be37375ec9f0bb2b161f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5916ed0b4e30f1a8b86d01dbc057d937"><td class="memItemLeft" align="right" valign="top">typedef base_type::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a5916ed0b4e30f1a8b86d01dbc057d937">const_iterator</a></td></tr>
<tr class="memdesc:a5916ed0b4e30f1a8b86d01dbc057d937"><td class="mdescLeft">&#160;</td><td class="mdescRight">const iterator type  <a href="#a5916ed0b4e30f1a8b86d01dbc057d937">More...</a><br/></td></tr>
<tr class="separator:a5916ed0b4e30f1a8b86d01dbc057d937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac255dcaba969cc3a9767b6a20bb3db5f"><td class="memItemLeft" align="right" valign="top">typedef base_type::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ac255dcaba969cc3a9767b6a20bb3db5f">reverse_iterator</a></td></tr>
<tr class="memdesc:ac255dcaba969cc3a9767b6a20bb3db5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">reverse iterator type  <a href="#ac255dcaba969cc3a9767b6a20bb3db5f">More...</a><br/></td></tr>
<tr class="separator:ac255dcaba969cc3a9767b6a20bb3db5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac743fb5b0913c5a3ccff65cc0f311750"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
base_type::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ac743fb5b0913c5a3ccff65cc0f311750">const_reverse_iterator</a></td></tr>
<tr class="memdesc:ac743fb5b0913c5a3ccff65cc0f311750"><td class="mdescLeft">&#160;</td><td class="mdescRight">const reverse iterator type  <a href="#ac743fb5b0913c5a3ccff65cc0f311750">More...</a><br/></td></tr>
<tr class="separator:ac743fb5b0913c5a3ccff65cc0f311750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916ec29b2a5e8d6323e5bee8688cddda"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
impl::matrix_kernel_argument<br class="typebreak"/>
&lt; T, Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a916ec29b2a5e8d6323e5bee8688cddda">kernel_argument</a></td></tr>
<tr class="memdesc:a916ec29b2a5e8d6323e5bee8688cddda"><td class="mdescLeft">&#160;</td><td class="mdescRight">kernel argument type  <a href="#a916ec29b2a5e8d6323e5bee8688cddda">More...</a><br/></td></tr>
<tr class="separator:a916ec29b2a5e8d6323e5bee8688cddda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301256d70b0f6a10804589d040c120c1"><td class="memItemLeft" align="right" valign="top">typedef const <br class="typebreak"/>
impl::matrix_kernel_argument<br class="typebreak"/>
&lt; T, Alloc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a301256d70b0f6a10804589d040c120c1">const_kernel_argument</a></td></tr>
<tr class="memdesc:a301256d70b0f6a10804589d040c120c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">const kernel argument type  <a href="#a301256d70b0f6a10804589d040c120c1">More...</a><br/></td></tr>
<tr class="separator:a301256d70b0f6a10804589d040c120c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeb4e594239e4434c92e90ccfb7831a7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#aeb4e594239e4434c92e90ccfb7831a7b">matrix</a> (const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a> numberRows=0, const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a> numberColumns=0, const <a class="el" href="classecuda_1_1matrix.html#ac5f815079bedbc3323e5c77116586886">value_type</a> &amp;value=<a class="el" href="classecuda_1_1matrix.html#ac5f815079bedbc3323e5c77116586886">value_type</a>(), const <a class="el" href="classecuda_1_1matrix.html#a74e763cf80733b9d8acafd8cfcec1fd2">allocator_type</a> &amp;allocator=<a class="el" href="classecuda_1_1matrix.html#a74e763cf80733b9d8acafd8cfcec1fd2">allocator_type</a>())</td></tr>
<tr class="memdesc:aeb4e594239e4434c92e90ccfb7831a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a matrix with dimensions numberRows x numberColumns filled with copies of elements with value value.  <a href="#aeb4e594239e4434c92e90ccfb7831a7b">More...</a><br/></td></tr>
<tr class="separator:aeb4e594239e4434c92e90ccfb7831a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475a407c0f367dc9d97bc40308b47e92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a475a407c0f367dc9d97bc40308b47e92">matrix</a> (const <a class="el" href="classecuda_1_1matrix.html">matrix</a> &amp;src)</td></tr>
<tr class="memdesc:a475a407c0f367dc9d97bc40308b47e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a475a407c0f367dc9d97bc40308b47e92">More...</a><br/></td></tr>
<tr class="separator:a475a407c0f367dc9d97bc40308b47e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b489db90b620fcd18330cdb633e12f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ae9b489db90b620fcd18330cdb633e12f">matrix</a> (const <a class="el" href="classecuda_1_1matrix.html">matrix</a> &amp;src, const <a class="el" href="classecuda_1_1matrix.html#a74e763cf80733b9d8acafd8cfcec1fd2">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:ae9b489db90b620fcd18330cdb633e12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#ae9b489db90b620fcd18330cdb633e12f">More...</a><br/></td></tr>
<tr class="separator:ae9b489db90b620fcd18330cdb633e12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db18cf972cfb417e5f6c043d6b6631f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1matrix.html">matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a2db18cf972cfb417e5f6c043d6b6631f">operator=</a> (const <a class="el" href="classecuda_1_1matrix.html">matrix</a> &amp;other)</td></tr>
<tr class="separator:a2db18cf972cfb417e5f6c043d6b6631f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666281d4bd99e10e085ee4f19ea6a209"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#acf32fbe2a3d9be37375ec9f0bb2b161f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a666281d4bd99e10e085ee4f19ea6a209">begin</a> () <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:a666281d4bd99e10e085ee4f19ea6a209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="#a666281d4bd99e10e085ee4f19ea6a209">More...</a><br/></td></tr>
<tr class="separator:a666281d4bd99e10e085ee4f19ea6a209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18b87019666c7c74f730015f6936b7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#acf32fbe2a3d9be37375ec9f0bb2b161f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#af18b87019666c7c74f730015f6936b7d">end</a> () <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:af18b87019666c7c74f730015f6936b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="#af18b87019666c7c74f730015f6936b7d">More...</a><br/></td></tr>
<tr class="separator:af18b87019666c7c74f730015f6936b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6cb82d6260fd7b433bb0bc50e5c789e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a5916ed0b4e30f1a8b86d01dbc057d937">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ac6cb82d6260fd7b433bb0bc50e5c789e">begin</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:ac6cb82d6260fd7b433bb0bc50e5c789e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="#ac6cb82d6260fd7b433bb0bc50e5c789e">More...</a><br/></td></tr>
<tr class="separator:ac6cb82d6260fd7b433bb0bc50e5c789e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef005875f473f87676dd53b3bfb0ba42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a5916ed0b4e30f1a8b86d01dbc057d937">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#aef005875f473f87676dd53b3bfb0ba42">end</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:aef005875f473f87676dd53b3bfb0ba42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="#aef005875f473f87676dd53b3bfb0ba42">More...</a><br/></td></tr>
<tr class="separator:aef005875f473f87676dd53b3bfb0ba42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b897ab384797891d842764494cddc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <br class="typebreak"/>
<a class="el" href="classecuda_1_1matrix.html#ac255dcaba969cc3a9767b6a20bb3db5f">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ab0b897ab384797891d842764494cddc0">rbegin</a> () <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:ab0b897ab384797891d842764494cddc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed container.  <a href="#ab0b897ab384797891d842764494cddc0">More...</a><br/></td></tr>
<tr class="separator:ab0b897ab384797891d842764494cddc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4630a557cdec93883e53a68784a5c40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <br class="typebreak"/>
<a class="el" href="classecuda_1_1matrix.html#ac255dcaba969cc3a9767b6a20bb3db5f">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#af4630a557cdec93883e53a68784a5c40">rend</a> () <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:af4630a557cdec93883e53a68784a5c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed container.  <a href="#af4630a557cdec93883e53a68784a5c40">More...</a><br/></td></tr>
<tr class="separator:af4630a557cdec93883e53a68784a5c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a30f7fb3bd8a98d80fb375bd45a34a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <br class="typebreak"/>
<a class="el" href="classecuda_1_1matrix.html#ac743fb5b0913c5a3ccff65cc0f311750">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a91a30f7fb3bd8a98d80fb375bd45a34a">rbegin</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:a91a30f7fb3bd8a98d80fb375bd45a34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed container.  <a href="#a91a30f7fb3bd8a98d80fb375bd45a34a">More...</a><br/></td></tr>
<tr class="separator:a91a30f7fb3bd8a98d80fb375bd45a34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384a3cabde771c73dc001d621c5aa493"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <br class="typebreak"/>
<a class="el" href="classecuda_1_1matrix.html#ac743fb5b0913c5a3ccff65cc0f311750">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a384a3cabde771c73dc001d621c5aa493">rend</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:a384a3cabde771c73dc001d621c5aa493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed container.  <a href="#a384a3cabde771c73dc001d621c5aa493">More...</a><br/></td></tr>
<tr class="separator:a384a3cabde771c73dc001d621c5aa493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067b728cc23e2de6fb8ba75835f9f72b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a067b728cc23e2de6fb8ba75835f9f72b">size</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:a067b728cc23e2de6fb8ba75835f9f72b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container (numberRows*numberColumns).  <a href="#a067b728cc23e2de6fb8ba75835f9f72b">More...</a><br/></td></tr>
<tr class="separator:a067b728cc23e2de6fb8ba75835f9f72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b33fbb7877e42fe2dd95afb54d6ee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <br class="typebreak"/>
<a class="el" href="global_8hpp.html#a9fec271a456e22bc9d8927abb3b8250d">__CONSTEXPR__</a> <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#aa4b33fbb7877e42fe2dd95afb54d6ee7">max_size</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:aa4b33fbb7877e42fe2dd95afb54d6ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the container is able to hold due to system or library implementation limitations.  <a href="#aa4b33fbb7877e42fe2dd95afb54d6ee7">More...</a><br/></td></tr>
<tr class="separator:aa4b33fbb7877e42fe2dd95afb54d6ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4040fd7e844942d96f4da9afee4e04f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#aa4040fd7e844942d96f4da9afee4e04f">number_rows</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:aa4040fd7e844942d96f4da9afee4e04f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rows in the container.  <a href="#aa4040fd7e844942d96f4da9afee4e04f">More...</a><br/></td></tr>
<tr class="separator:aa4040fd7e844942d96f4da9afee4e04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace012e99870f617eb65233cf90bb2039"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ace012e99870f617eb65233cf90bb2039">number_columns</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:ace012e99870f617eb65233cf90bb2039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in the container.  <a href="#ace012e99870f617eb65233cf90bb2039">More...</a><br/></td></tr>
<tr class="separator:ace012e99870f617eb65233cf90bb2039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4748638a890938db56cdd9221347ec4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ae4748638a890938db56cdd9221347ec4">resize</a> (const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a> newNumberRows, const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a> newNumberColumns, const <a class="el" href="classecuda_1_1matrix.html#ac5f815079bedbc3323e5c77116586886">value_type</a> &amp;value=<a class="el" href="classecuda_1_1matrix.html#ac5f815079bedbc3323e5c77116586886">value_type</a>())</td></tr>
<tr class="memdesc:ae4748638a890938db56cdd9221347ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to have dimensions newNumberRows x newNumberColumns.  <a href="#ae4748638a890938db56cdd9221347ec4">More...</a><br/></td></tr>
<tr class="separator:ae4748638a890938db56cdd9221347ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f222809e66c6bb0c28a6e8450a9454b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a9f222809e66c6bb0c28a6e8450a9454b">empty</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:a9f222809e66c6bb0c28a6e8450a9454b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container has no elements.  <a href="#a9f222809e66c6bb0c28a6e8450a9454b">More...</a><br/></td></tr>
<tr class="separator:a9f222809e66c6bb0c28a6e8450a9454b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473a3209c4a77046c99b95833700769d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a7947927ff51492aaa2e788151befca99">row_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a473a3209c4a77046c99b95833700769d">get_row</a> (const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a> rowIndex)</td></tr>
<tr class="memdesc:a473a3209c4a77046c99b95833700769d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a view object of a single row of the matrix.  <a href="#a473a3209c4a77046c99b95833700769d">More...</a><br/></td></tr>
<tr class="separator:a473a3209c4a77046c99b95833700769d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0728b27572534d987b9300da65bbef7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#ad0ffcd571700bbe2403095403cd445f9">const_row_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a0728b27572534d987b9300da65bbef7d">get_row</a> (const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a> rowIndex) const </td></tr>
<tr class="memdesc:a0728b27572534d987b9300da65bbef7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a view object of a single row of the matrix.  <a href="#a0728b27572534d987b9300da65bbef7d">More...</a><br/></td></tr>
<tr class="separator:a0728b27572534d987b9300da65bbef7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1697da9b4512e34dd46431be3204df2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a48381b66921d28af72aba77fc050ddd6">column_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#aa1697da9b4512e34dd46431be3204df2">get_column</a> (const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a> columnIndex)</td></tr>
<tr class="memdesc:aa1697da9b4512e34dd46431be3204df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a view object of a single column of the matrix.  <a href="#aa1697da9b4512e34dd46431be3204df2">More...</a><br/></td></tr>
<tr class="separator:aa1697da9b4512e34dd46431be3204df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95985cff0863facbafcc4ffb3d60a193"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <br class="typebreak"/>
<a class="el" href="classecuda_1_1matrix.html#a6206e8f8dfd5a5971cc066ad48aa8ee5">const_column_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a95985cff0863facbafcc4ffb3d60a193">get_column</a> (const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a> columnIndex) const </td></tr>
<tr class="memdesc:a95985cff0863facbafcc4ffb3d60a193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a view object of a single column of the matrix.  <a href="#a95985cff0863facbafcc4ffb3d60a193">More...</a><br/></td></tr>
<tr class="separator:a95985cff0863facbafcc4ffb3d60a193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88b00a0d29a03613fca18865c93cda4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a6463c15c6de5f1cd9ebe56d613ed3d32">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ac88b00a0d29a03613fca18865c93cda4">at</a> (<a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a> rowIndex, <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a> columnIndex)</td></tr>
<tr class="memdesc:ac88b00a0d29a03613fca18865c93cda4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified row and column index, with bounds checking.  <a href="#ac88b00a0d29a03613fca18865c93cda4">More...</a><br/></td></tr>
<tr class="separator:ac88b00a0d29a03613fca18865c93cda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ceaa1e7b9f6c63e5e3fdea4c39ea1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#aad63fbf6e65de21bc5ef0b73f1da55c3">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a53ceaa1e7b9f6c63e5e3fdea4c39ea1c">at</a> (<a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a> rowIndex, <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a> columnIndex) const </td></tr>
<tr class="memdesc:a53ceaa1e7b9f6c63e5e3fdea4c39ea1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the element at specified row and column index, with bounds checking.  <a href="#a53ceaa1e7b9f6c63e5e3fdea4c39ea1c">More...</a><br/></td></tr>
<tr class="separator:a53ceaa1e7b9f6c63e5e3fdea4c39ea1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a31d2069dafa55bf9cb2ecb10504f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a6463c15c6de5f1cd9ebe56d613ed3d32">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a56a31d2069dafa55bf9cb2ecb10504f1">operator()</a> (const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a> rowIndex, const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a> columnIndex)</td></tr>
<tr class="memdesc:a56a31d2069dafa55bf9cb2ecb10504f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index. No bounds checking is performed.  <a href="#a56a31d2069dafa55bf9cb2ecb10504f1">More...</a><br/></td></tr>
<tr class="separator:a56a31d2069dafa55bf9cb2ecb10504f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc6cd765a848dcb75eb39a343707597"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#aad63fbf6e65de21bc5ef0b73f1da55c3">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#adfc6cd765a848dcb75eb39a343707597">operator()</a> (const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a> rowIndex, const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a> columnIndex) const </td></tr>
<tr class="memdesc:adfc6cd765a848dcb75eb39a343707597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index. No bounds checking is performed.  <a href="#adfc6cd765a848dcb75eb39a343707597">More...</a><br/></td></tr>
<tr class="separator:adfc6cd765a848dcb75eb39a343707597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9864c204c790fffbfb41f5e0fa4254d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a7947927ff51492aaa2e788151befca99">row_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ab9864c204c790fffbfb41f5e0fa4254d">operator[]</a> (const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a> rowIndex)</td></tr>
<tr class="memdesc:ab9864c204c790fffbfb41f5e0fa4254d"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator[](rowIndex) alias for get_row(rowIndex)  <a href="#ab9864c204c790fffbfb41f5e0fa4254d">More...</a><br/></td></tr>
<tr class="separator:ab9864c204c790fffbfb41f5e0fa4254d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f09421c5aa969af1da89345e3b3b34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#ad0ffcd571700bbe2403095403cd445f9">const_row_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a48f09421c5aa969af1da89345e3b3b34">operator[]</a> (const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a> rowIndex) const </td></tr>
<tr class="memdesc:a48f09421c5aa969af1da89345e3b3b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator[](rowIndex) alias for get_row(rowIndex)  <a href="#a48f09421c5aa969af1da89345e3b3b34">More...</a><br/></td></tr>
<tr class="separator:a48f09421c5aa969af1da89345e3b3b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ac098a2e5a302e9e4147424ba126a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a6463c15c6de5f1cd9ebe56d613ed3d32">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a49ac098a2e5a302e9e4147424ba126a3">front</a> ()</td></tr>
<tr class="memdesc:a49ac098a2e5a302e9e4147424ba126a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container.  <a href="#a49ac098a2e5a302e9e4147424ba126a3">More...</a><br/></td></tr>
<tr class="separator:a49ac098a2e5a302e9e4147424ba126a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a025fba461d28f9d27371f4f1fed186"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a6463c15c6de5f1cd9ebe56d613ed3d32">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a0a025fba461d28f9d27371f4f1fed186">back</a> ()</td></tr>
<tr class="memdesc:a0a025fba461d28f9d27371f4f1fed186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container.  <a href="#a0a025fba461d28f9d27371f4f1fed186">More...</a><br/></td></tr>
<tr class="separator:a0a025fba461d28f9d27371f4f1fed186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab60fdf204f47cf434622f99e9dca8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#aad63fbf6e65de21bc5ef0b73f1da55c3">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a2ab60fdf204f47cf434622f99e9dca8f">front</a> () const </td></tr>
<tr class="memdesc:a2ab60fdf204f47cf434622f99e9dca8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container.  <a href="#a2ab60fdf204f47cf434622f99e9dca8f">More...</a><br/></td></tr>
<tr class="separator:a2ab60fdf204f47cf434622f99e9dca8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d092697ef2b612c3b7474f311ec582a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#aad63fbf6e65de21bc5ef0b73f1da55c3">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a6d092697ef2b612c3b7474f311ec582a">back</a> () const </td></tr>
<tr class="memdesc:a6d092697ef2b612c3b7474f311ec582a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container.  <a href="#a6d092697ef2b612c3b7474f311ec582a">More...</a><br/></td></tr>
<tr class="separator:a6d092697ef2b612c3b7474f311ec582a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0f9f8f6f4761c9da78f5f7730f4a8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a4eed3ea13e4cedec5e09b3a3dae6610e">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a3f0f9f8f6f4761c9da78f5f7730f4a8d">data</a> () <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:a3f0f9f8f6f4761c9da78f5f7730f4a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage.  <a href="#a3f0f9f8f6f4761c9da78f5f7730f4a8d">More...</a><br/></td></tr>
<tr class="separator:a3f0f9f8f6f4761c9da78f5f7730f4a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209297cc6412b61a24cb7c40406e560b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a2a617534ef25c6734126ba41440909c4">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a209297cc6412b61a24cb7c40406e560b">data</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:a209297cc6412b61a24cb7c40406e560b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage.  <a href="#a209297cc6412b61a24cb7c40406e560b">More...</a><br/></td></tr>
<tr class="separator:a209297cc6412b61a24cb7c40406e560b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abb6b29d046a944b5333cdf5382b262"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a7abb6b29d046a944b5333cdf5382b262">fill</a> (const <a class="el" href="classecuda_1_1matrix.html#ac5f815079bedbc3323e5c77116586886">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a7abb6b29d046a944b5333cdf5382b262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a given value to all elements in the container.  <a href="#a7abb6b29d046a944b5333cdf5382b262">More...</a><br/></td></tr>
<tr class="separator:a7abb6b29d046a944b5333cdf5382b262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a02afe8835857a4151f8bc9053b5d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#af9a02afe8835857a4151f8bc9053b5d4">swap</a> (<a class="el" href="classecuda_1_1matrix.html">matrix</a> &amp;other)</td></tr>
<tr class="memdesc:af9a02afe8835857a4151f8bc9053b5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the container with those of the other.  <a href="#af9a02afe8835857a4151f8bc9053b5d4">More...</a><br/></td></tr>
<tr class="separator:af9a02afe8835857a4151f8bc9053b5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b6eecadbfd2e71837195dffb773c37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1matrix.html#a74e763cf80733b9d8acafd8cfcec1fd2">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#af7b6eecadbfd2e71837195dffb773c37">get_allocator</a> () const </td></tr>
<tr class="memdesc:af7b6eecadbfd2e71837195dffb773c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the container.  <a href="#af7b6eecadbfd2e71837195dffb773c37">More...</a><br/></td></tr>
<tr class="separator:af7b6eecadbfd2e71837195dffb773c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99562162af52394e74b514c018cfb28"><td class="memTemplParams" colspan="2">template&lt;class Alloc2 &gt; </td></tr>
<tr class="memitem:af99562162af52394e74b514c018cfb28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#af99562162af52394e74b514c018cfb28">operator==</a> (const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; <a class="el" href="classecuda_1_1matrix.html#ac5f815079bedbc3323e5c77116586886">value_type</a>, Alloc2 &gt; &amp;other) const </td></tr>
<tr class="memdesc:af99562162af52394e74b514c018cfb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of two matrices are equal.  <a href="#af99562162af52394e74b514c018cfb28">More...</a><br/></td></tr>
<tr class="separator:af99562162af52394e74b514c018cfb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91eb4d42e901e3ad497c964f82ddbd91"><td class="memTemplParams" colspan="2">template&lt;class Alloc2 &gt; </td></tr>
<tr class="memitem:a91eb4d42e901e3ad497c964f82ddbd91"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a91eb4d42e901e3ad497c964f82ddbd91">operator!=</a> (const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; <a class="el" href="classecuda_1_1matrix.html#ac5f815079bedbc3323e5c77116586886">value_type</a>, Alloc2 &gt; &amp;other) const </td></tr>
<tr class="memdesc:a91eb4d42e901e3ad497c964f82ddbd91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of two matrices are not equal.  <a href="#a91eb4d42e901e3ad497c964f82ddbd91">More...</a><br/></td></tr>
<tr class="separator:a91eb4d42e901e3ad497c964f82ddbd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dfdcc6dfe77f45bb2f39fa449a85b8f"><td class="memTemplParams" colspan="2">template&lt;class Alloc2 &gt; </td></tr>
<tr class="memitem:a7dfdcc6dfe77f45bb2f39fa449a85b8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a7dfdcc6dfe77f45bb2f39fa449a85b8f">operator&lt;</a> (const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; <a class="el" href="classecuda_1_1matrix.html#ac5f815079bedbc3323e5c77116586886">value_type</a>, Alloc2 &gt; &amp;other) const </td></tr>
<tr class="memdesc:a7dfdcc6dfe77f45bb2f39fa449a85b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two matrices lexicographically.  <a href="#a7dfdcc6dfe77f45bb2f39fa449a85b8f">More...</a><br/></td></tr>
<tr class="separator:a7dfdcc6dfe77f45bb2f39fa449a85b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14136ce59424f5ec240a376b9866dc3"><td class="memTemplParams" colspan="2">template&lt;class Alloc2 &gt; </td></tr>
<tr class="memitem:ac14136ce59424f5ec240a376b9866dc3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ac14136ce59424f5ec240a376b9866dc3">operator&gt;</a> (const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; <a class="el" href="classecuda_1_1matrix.html#ac5f815079bedbc3323e5c77116586886">value_type</a>, Alloc2 &gt; &amp;other) const </td></tr>
<tr class="memdesc:ac14136ce59424f5ec240a376b9866dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two matrices lexicographically.  <a href="#ac14136ce59424f5ec240a376b9866dc3">More...</a><br/></td></tr>
<tr class="separator:ac14136ce59424f5ec240a376b9866dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776612cdefe417f9a5c2011eaea3390d"><td class="memTemplParams" colspan="2">template&lt;class Alloc2 &gt; </td></tr>
<tr class="memitem:a776612cdefe417f9a5c2011eaea3390d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a776612cdefe417f9a5c2011eaea3390d">operator&lt;=</a> (const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; <a class="el" href="classecuda_1_1matrix.html#ac5f815079bedbc3323e5c77116586886">value_type</a>, Alloc2 &gt; &amp;other) const </td></tr>
<tr class="memdesc:a776612cdefe417f9a5c2011eaea3390d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two matrices lexicographically.  <a href="#a776612cdefe417f9a5c2011eaea3390d">More...</a><br/></td></tr>
<tr class="separator:a776612cdefe417f9a5c2011eaea3390d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee8264abbd772896815aee34c952ac1"><td class="memTemplParams" colspan="2">template&lt;class Alloc2 &gt; </td></tr>
<tr class="memitem:aaee8264abbd772896815aee34c952ac1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#aaee8264abbd772896815aee34c952ac1">operator&gt;=</a> (const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; <a class="el" href="classecuda_1_1matrix.html#ac5f815079bedbc3323e5c77116586886">value_type</a>, Alloc2 &gt; &amp;other) const </td></tr>
<tr class="memdesc:aaee8264abbd772896815aee34c952ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two matrices lexicographically.  <a href="#aaee8264abbd772896815aee34c952ac1">More...</a><br/></td></tr>
<tr class="separator:aaee8264abbd772896815aee34c952ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac9ec3fbcd2ac57a92e744d585ac6a0d5"><td class="memTemplParams" colspan="2">template&lt;typename U , class Alloc2 , class Q &gt; </td></tr>
<tr class="memitem:ac9ec3fbcd2ac57a92e744d585ac6a0d5"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ac9ec3fbcd2ac57a92e744d585ac6a0d5">matrix</a></td></tr>
<tr class="separator:ac9ec3fbcd2ac57a92e744d585ac6a0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt;<br/>
class ecuda::matrix&lt; T, Alloc, P &gt;</h3>

<p>A resizable matrix stored in device memory. </p>
<p>A matrix is defined as a 2D structure of dimensions rows*columns. The default implementation uses pitched memory where a 2D block of video memory is allocated with width=columns and height=rows. Pitched memory is aligned in a device-dependent manner so that calls to individual elements can be threaded more efficiently (i.e. minimizing the number of read operations required to supply data to multiple threads). Consult the CUDA API documentation for a more verbose explanation.</p>
<p>Methods are prefaced with appropriate keywords to declare them as host and/or device capable. In general: operations requiring memory allocation/deallocation are host only, operations to access the values of specific elements are device only, and copy operations on ranges of data and accessors of general information can be performed on both the host and device.</p>
<p>Memory use can be conceptualized as: </p>
<div class="fragment"><div class="line">     |- columns -|</div>
<div class="line">     |---- pitch -----|</div>
<div class="line">  _  +-----------+----+</div>
<div class="line"> |   |           |xxxx| x = allocated but not used, just padding to</div>
<div class="line"> |   |           |xxxx|     enforce an efficient memory alignment</div>
<div class="line">rows |           |xxxx|</div>
<div class="line"> |   |           |xxxx|</div>
<div class="line"> |_  +-----------+----+</div>
</div><!-- fragment --><p>As a result, it is highly desirable for threading to utilize a column-wise orientation. For example, a good kernel to perform an operation on the elements of a matrix might be:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; __global__ <span class="keywordtype">void</span> doMatrixOperation( <span class="keyword">typename</span> <a class="code" href="classecuda_1_1matrix.html#a916ec29b2a5e8d6323e5bee8688cddda">ecuda::matrix&lt;T&gt;::kernel_argument</a> <a class="code" href="classecuda_1_1matrix.html#ac9ec3fbcd2ac57a92e744d585ac6a0d5">matrix</a> )</div>
<div class="line">{</div>
<div class="line">   <span class="keyword">const</span> <span class="keywordtype">int</span> row = blockIdx.x;</div>
<div class="line">   <span class="keyword">const</span> <span class="keywordtype">int</span> col = blockDim.y*gridDim.y; <span class="comment">// each thread gets a different column value</span></div>
<div class="line">   <span class="keywordflow">if</span>( row &lt; matrix.<a class="code" href="classecuda_1_1matrix.html#aa4040fd7e844942d96f4da9afee4e04f">number_rows</a>() &amp;&amp; col &lt; matrix.<a class="code" href="classecuda_1_1matrix.html#ace012e99870f617eb65233cf90bb2039">number_columns</a>() ) {</div>
<div class="line">      T&amp; value = <a class="code" href="classecuda_1_1matrix.html#ac9ec3fbcd2ac57a92e744d585ac6a0d5">matrix</a>(row,col);</div>
<div class="line">      <span class="comment">// ... do work on value</span></div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p>This could be called from host code like: </p>
<div class="fragment"><div class="line"><a class="code" href="classecuda_1_1matrix.html">ecuda::matrix&lt;double&gt;</a> <a class="code" href="classecuda_1_1matrix.html#ac9ec3fbcd2ac57a92e744d585ac6a0d5">matrix</a>( 100, 1000 );</div>
<div class="line"><span class="comment">// ... fill matrix with data</span></div>
<div class="line">dim3 grid( 100, 1 ), block( 1, 1000 );</div>
<div class="line">doMatrixOperation&lt;&lt;&lt;grid,block&gt;&gt;&gt;( <a class="code" href="classecuda_1_1matrix.html#ac9ec3fbcd2ac57a92e744d585ac6a0d5">matrix</a> );</div>
</div><!-- fragment --><p>Unfortunately, CUDA solutions are very problem specific, so there is no generally applicable example for specifying how thread blocks should be defined. The size of the matrix, hardware limitations, CUDA API limitations, etc. all play a part. For example, the above implementation won't work in earlier versions of CUDA since blockDim.y was limited to 512 (at the time of this writing it was 1024 in the newer versions of CUDA).</p>
<p>Just keep in mind that the column dimension lies in contiguous memory, and the row dimension is contiguous blocks of columns; thus, an implementation that aims to have concurrently running threads accessing column &gt;&gt;&gt;&gt; row will run much more efficiently.</p>
<p>Matrix iterators (via <a class="el" href="classecuda_1_1matrix.html#a666281d4bd99e10e085ee4f19ea6a209" title="Returns an iterator to the first element of the container. ">begin()</a>,<a class="el" href="classecuda_1_1matrix.html#af18b87019666c7c74f730015f6936b7d" title="Returns an iterator to the element following the last element of the container. ">end()</a>,<a class="el" href="classecuda_1_1matrix.html#ab0b897ab384797891d842764494cddc0" title="Returns a reverse iterator to the first element of the reversed container. ">rbegin()</a>,<a class="el" href="classecuda_1_1matrix.html#af4630a557cdec93883e53a68784a5c40" title="Returns a reverse iterator to the element following the last element of the reversed container...">rend()</a>) and lexicographical comparisons traverse the matrix linearly in row-major fashion (i.e. each column of the first row is traversed, then each column of the next row, and so on...). </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00126">126</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a74e763cf80733b9d8acafd8cfcec1fd2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Alloc <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1matrix.html#a74e763cf80733b9d8acafd8cfcec1fd2">allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocator type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00134">134</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a48381b66921d28af72aba77fc050ddd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::column_type <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1matrix.html#a48381b66921d28af72aba77fc050ddd6">column_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>matrix column container type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00143">143</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6206e8f8dfd5a5971cc066ad48aa8ee5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::const_column_type <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1matrix.html#a6206e8f8dfd5a5971cc066ad48aa8ee5">const_column_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>matrix const column container type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00145">145</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5916ed0b4e30f1a8b86d01dbc057d937"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::const_iterator <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1matrix.html#a5916ed0b4e30f1a8b86d01dbc057d937">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const iterator type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00148">148</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a301256d70b0f6a10804589d040c120c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const impl::matrix_kernel_argument&lt;T,Alloc&gt; <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1matrix.html#a301256d70b0f6a10804589d040c120c1">const_kernel_argument</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const kernel argument type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00153">153</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2a617534ef25c6734126ba41440909c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef make_const&lt;<a class="el" href="classecuda_1_1matrix.html#a4eed3ea13e4cedec5e09b3a3dae6610e">pointer</a>&gt;::type <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1matrix.html#a2a617534ef25c6734126ba41440909c4">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell const pointer type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00140">140</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aad63fbf6e65de21bc5ef0b73f1da55c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::const_reference <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1matrix.html#aad63fbf6e65de21bc5ef0b73f1da55c3">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell const reference type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00138">138</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac743fb5b0913c5a3ccff65cc0f311750"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::const_reverse_iterator <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1matrix.html#ac743fb5b0913c5a3ccff65cc0f311750">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const reverse iterator type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00150">150</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad0ffcd571700bbe2403095403cd445f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::const_row_type <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1matrix.html#ad0ffcd571700bbe2403095403cd445f9">const_row_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>matrix const row container type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00144">144</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a009307bfac8da5effa7bed37427f9661"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::difference_type <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1matrix.html#a009307bfac8da5effa7bed37427f9661">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>signed integral type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00136">136</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acf32fbe2a3d9be37375ec9f0bb2b161f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::iterator <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1matrix.html#acf32fbe2a3d9be37375ec9f0bb2b161f">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iterator type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00147">147</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a916ec29b2a5e8d6323e5bee8688cddda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef impl::matrix_kernel_argument&lt;T,Alloc&gt; <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1matrix.html#a916ec29b2a5e8d6323e5bee8688cddda">kernel_argument</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>kernel argument type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00152">152</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4eed3ea13e4cedec5e09b3a3dae6610e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::pointer <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1matrix.html#a4eed3ea13e4cedec5e09b3a3dae6610e">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell pointer type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00139">139</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6463c15c6de5f1cd9ebe56d613ed3d32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::reference <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1matrix.html#a6463c15c6de5f1cd9ebe56d613ed3d32">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell reference type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00137">137</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac255dcaba969cc3a9767b6a20bb3db5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::reverse_iterator <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1matrix.html#ac255dcaba969cc3a9767b6a20bb3db5f">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reverse iterator type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00149">149</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7947927ff51492aaa2e788151befca99"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::row_type <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1matrix.html#a7947927ff51492aaa2e788151befca99">row_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>matrix row container type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00142">142</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2dc059f3d11827c75527cc8884d7c0ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::size_type <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unsigned integral type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00135">135</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac5f815079bedbc3323e5c77116586886"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::value_type <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1matrix.html#ac5f815079bedbc3323e5c77116586886">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell data type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00133">133</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aeb4e594239e4434c92e90ccfb7831a7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1matrix.html">matrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a>&#160;</td>
          <td class="paramname"><em>numberRows</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a>&#160;</td>
          <td class="paramname"><em>numberColumns</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#ac5f815079bedbc3323e5c77116586886">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code><a class="el" href="classecuda_1_1matrix.html#ac5f815079bedbc3323e5c77116586886">value_type</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#a74e763cf80733b9d8acafd8cfcec1fd2">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code><a class="el" href="classecuda_1_1matrix.html#a74e763cf80733b9d8acafd8cfcec1fd2">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a matrix with dimensions numberRows x numberColumns filled with copies of elements with value value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numberRows</td><td>number of rows (default: 0) </td></tr>
    <tr><td class="paramname">numberColumns</td><td>number of columns (default: 0) </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize elements of the matrix with (default: T()) </td></tr>
    <tr><td class="paramname">allocator</td><td>allocator to use for all memory allocations of this container (does not normally need to be specified, by default the internal ecuda pitched memory allocator) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00204">204</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a475a407c0f367dc9d97bc40308b47e92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1matrix.html">matrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Constructs the matrix with a copy of the contents of src.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Another matrix object of the same type, whose contents are copied. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00219">219</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae9b489db90b620fcd18330cdb633e12f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::<a class="el" href="classecuda_1_1matrix.html">matrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#a74e763cf80733b9d8acafd8cfcec1fd2">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Constructs the matrix with a copy of the contents of src.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Another matrix object of the same type, whose contents are copied. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for all memory allocations of this container. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00237">237</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac88b00a0d29a03613fca18865c93cda4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a6463c15c6de5f1cd9ebe56d613ed3d32">reference</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a>&#160;</td>
          <td class="paramname"><em>rowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a>&#160;</td>
          <td class="paramname"><em>columnIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified row and column index, with bounds checking. </p>
<p>If the row and column are not within the range of the container, the current kernel will exit and cudaGetLastError will return cudaErrorUnknown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowIndex</td><td>position of the row to return </td></tr>
    <tr><td class="paramname">columnIndex</td><td>position of the column to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00470">470</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a53ceaa1e7b9f6c63e5e3fdea4c39ea1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#aad63fbf6e65de21bc5ef0b73f1da55c3">const_reference</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a>&#160;</td>
          <td class="paramname"><em>rowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a>&#160;</td>
          <td class="paramname"><em>columnIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to the element at specified row and column index, with bounds checking. </p>
<p>If the row and column are not within the range of the container, the current kernel will exit and cudaGetLastError will return cudaErrorUnknown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowIndex</td><td>position of the row to return </td></tr>
    <tr><td class="paramname">columnIndex</td><td>position of the column to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00496">496</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0a025fba461d28f9d27371f4f1fed186"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a6463c15c6de5f1cd9ebe56d613ed3d32">reference</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the container. </p>
<p>This is effectively the element at position (numberRows-1,numberColumns-1). Calling back on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00564">564</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d092697ef2b612c3b7474f311ec582a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#aad63fbf6e65de21bc5ef0b73f1da55c3">const_reference</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the container. </p>
<p>This is effectively the element at position (numberRows-1,numberColumns-1). Calling back on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00582">582</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a666281d4bd99e10e085ee4f19ea6a209"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#acf32fbe2a3d9be37375ec9f0bb2b161f">iterator</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classecuda_1_1matrix.html#af18b87019666c7c74f730015f6936b7d" title="Returns an iterator to the element following the last element of the container. ">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00278">278</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac6cb82d6260fd7b433bb0bc50e5c789e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a5916ed0b4e30f1a8b86d01dbc057d937">const_iterator</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classecuda_1_1matrix.html#af18b87019666c7c74f730015f6936b7d" title="Returns an iterator to the element following the last element of the container. ">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00296">296</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3f0f9f8f6f4761c9da78f5f7730f4a8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a4eed3ea13e4cedec5e09b3a3dae6610e">pointer</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying array serving as element storage. </p>
<p>The pointer is such that range [<a class="el" href="classecuda_1_1matrix.html#a3f0f9f8f6f4761c9da78f5f7730f4a8d" title="Returns pointer to the underlying array serving as element storage. ">data()</a>,<a class="el" href="classecuda_1_1matrix.html#a3f0f9f8f6f4761c9da78f5f7730f4a8d" title="Returns pointer to the underlying array serving as element storage. ">data()</a>+size()) is always a valid range, even if the container is empty.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00592">592</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a209297cc6412b61a24cb7c40406e560b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a2a617534ef25c6734126ba41440909c4">const_pointer</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying array serving as element storage. </p>
<p>The pointer is such that range [<a class="el" href="classecuda_1_1matrix.html#a3f0f9f8f6f4761c9da78f5f7730f4a8d" title="Returns pointer to the underlying array serving as element storage. ">data()</a>,<a class="el" href="classecuda_1_1matrix.html#a3f0f9f8f6f4761c9da78f5f7730f4a8d" title="Returns pointer to the underlying array serving as element storage. ">data()</a>+size()) is always a valid range, even if the container is empty.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00602">602</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9f222809e66c6bb0c28a6e8450a9454b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container has no elements. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the container is empty, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00408">408</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af18b87019666c7c74f730015f6936b7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#acf32fbe2a3d9be37375ec9f0bb2b161f">iterator</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>
<p>The element acts as a placeholder; attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00287">287</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef005875f473f87676dd53b3bfb0ba42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a5916ed0b4e30f1a8b86d01dbc057d937">const_iterator</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>
<p>The element acts as a placeholder; attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00305">305</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7abb6b29d046a944b5333cdf5382b262"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#ac5f815079bedbc3323e5c77116586886">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a given value to all elements in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to assign to the elements </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00609">609</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a49ac098a2e5a302e9e4147424ba126a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a6463c15c6de5f1cd9ebe56d613ed3d32">reference</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the container. </p>
<p>This is effectively the element at position (0,0). Calling front on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00555">555</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2ab60fdf204f47cf434622f99e9dca8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#aad63fbf6e65de21bc5ef0b73f1da55c3">const_reference</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the container. </p>
<p>This is effectively the element at position (0,0). Calling front on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00573">573</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af7b6eecadbfd2e71837195dffb773c37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1matrix.html#a74e763cf80733b9d8acafd8cfcec1fd2">allocator_type</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator associated with the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The associated allocator. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00628">628</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa1697da9b4512e34dd46431be3204df2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a48381b66921d28af72aba77fc050ddd6">column_type</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::get_column </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a>&#160;</td>
          <td class="paramname"><em>columnIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a view object of a single column of the matrix. </p>
<p>The view object is guaranteed to perform no memory allocations or deallocation, and merely holds a pointer to the start of the row and provides methods to traverse, access, and alter the underlying data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">columnIndex</td><td>index of the column to isolate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>view object for the specified column </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00445">445</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a95985cff0863facbafcc4ffb3d60a193"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a6206e8f8dfd5a5971cc066ad48aa8ee5">const_column_type</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::get_column </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a>&#160;</td>
          <td class="paramname"><em>columnIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a view object of a single column of the matrix. </p>
<p>The view object is guaranteed to perform no memory allocations or deallocation, and merely holds a pointer to the start of the row and provides methods to traverse and access the underlying data. In addition, the constness of this matrix is enforced so the view will not allow any alterations to the underlying data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">columnIndex</td><td>index of the column to isolate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>view object for the specified column </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00458">458</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a473a3209c4a77046c99b95833700769d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a7947927ff51492aaa2e788151befca99">row_type</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::get_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a>&#160;</td>
          <td class="paramname"><em>rowIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a view object of a single row of the matrix. </p>
<p>The view object is guaranteed to perform no memory allocations or deallocation, and merely holds a pointer to the start of the row and provides methods to traverse, access, and alter the underlying data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowIndex</td><td>of the row to isolate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>view object for the specified row </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00420">420</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0728b27572534d987b9300da65bbef7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#ad0ffcd571700bbe2403095403cd445f9">const_row_type</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::get_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a>&#160;</td>
          <td class="paramname"><em>rowIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a view object of a single row of the matrix. </p>
<p>The view object is guaranteed to perform no memory allocations or deallocation, and merely holds a pointer to the start of the row and provides methods to traverse and access the underlying data. In addition, the constness of this matrix is enforced so the view will not allow any alterations to the underlying data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowIndex</td><td>of the row to isolate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>view object for the specified row </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00433">433</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa4b33fbb7877e42fe2dd95afb54d6ee7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="global_8hpp.html#a9fec271a456e22bc9d8927abb3b8250d">__CONSTEXPR__</a> <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements the container is able to hold due to system or library implementation limitations. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of elements. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00365">365</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ace012e99870f617eb65233cf90bb2039"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::number_columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of columns in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of columns in the container. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00379">379</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa4040fd7e844942d96f4da9afee4e04f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::number_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of rows in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of rows in the container. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00372">372</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a91eb4d42e901e3ad497c964f82ddbd91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; <a class="el" href="classecuda_1_1matrix.html#ac5f815079bedbc3323e5c77116586886">value_type</a>, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the contents of two matrices are not equal. </p>
<p>That is, whether <a class="el" href="classecuda_1_1matrix.html#aa4040fd7e844942d96f4da9afee4e04f" title="Returns the number of rows in the container. ">number_rows()</a> != other.number_rows(), <a class="el" href="classecuda_1_1matrix.html#ace012e99870f617eb65233cf90bb2039" title="Returns the number of columns in the container. ">number_columns()</a> != other.number_columns(), or whether any element in the this matrix does not compare equal to the element in the other matrix at the same position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents are not equal, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00656">656</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a56a31d2069dafa55bf9cb2ecb10504f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a6463c15c6de5f1cd9ebe56d613ed3d32">reference</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a>&#160;</td>
          <td class="paramname"><em>rowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a>&#160;</td>
          <td class="paramname"><em>columnIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location index. No bounds checking is performed. </p>
<p>This is identical to <a class="el" href="classecuda_1_1matrix.html#ac88b00a0d29a03613fca18865c93cda4" title="Returns a reference to the element at specified row and column index, with bounds checking...">at()</a> but no bounds checking is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowIndex</td><td>row of the element to return </td></tr>
    <tr><td class="paramname">columnIndex</td><td>column of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00521">521</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adfc6cd765a848dcb75eb39a343707597"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#aad63fbf6e65de21bc5ef0b73f1da55c3">const_reference</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a>&#160;</td>
          <td class="paramname"><em>rowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a>&#160;</td>
          <td class="paramname"><em>columnIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location index. No bounds checking is performed. </p>
<p>This is identical to <a class="el" href="classecuda_1_1matrix.html#ac88b00a0d29a03613fca18865c93cda4" title="Returns a reference to the element at specified row and column index, with bounds checking...">at()</a> but no bounds checking is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowIndex</td><td>row of the element to return </td></tr>
    <tr><td class="paramname">columnIndex</td><td>column of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00532">532</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7dfdcc6dfe77f45bb2f39fa449a85b8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; <a class="el" href="classecuda_1_1matrix.html#ac5f815079bedbc3323e5c77116586886">value_type</a>, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two matrices lexicographically. </p>
<p>The order that elements are compared corresponds to their linearized layout (i.e. each column of the first row is compared, then each column of the next row, and so on...).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of this matrix are lexicographically less than the other matrix, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00668">668</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a776612cdefe417f9a5c2011eaea3390d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; <a class="el" href="classecuda_1_1matrix.html#ac5f815079bedbc3323e5c77116586886">value_type</a>, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two matrices lexicographically. </p>
<p>The order that elements are compared corresponds to their linearized layout (i.e. each column of the first row is compared, then each column of the next row, and so on...).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of this matrix are lexicographically less than or equal to the other matrix, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00698">698</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2db18cf972cfb417e5f6c043d6b6631f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1matrix.html">matrix</a>&amp; <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00245">245</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af99562162af52394e74b514c018cfb28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; <a class="el" href="classecuda_1_1matrix.html#ac5f815079bedbc3323e5c77116586886">value_type</a>, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the contents of two matrices are equal. </p>
<p>That is, whether <a class="el" href="classecuda_1_1matrix.html#aa4040fd7e844942d96f4da9afee4e04f" title="Returns the number of rows in the container. ">number_rows()</a> == other.number_rows(), <a class="el" href="classecuda_1_1matrix.html#ace012e99870f617eb65233cf90bb2039" title="Returns the number of columns in the container. ">number_columns()</a> == other.number_columns() and each element in the this matrix compares equal to the other matrix at the same position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents are equal, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00640">640</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac14136ce59424f5ec240a376b9866dc3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; <a class="el" href="classecuda_1_1matrix.html#ac5f815079bedbc3323e5c77116586886">value_type</a>, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two matrices lexicographically. </p>
<p>The order that elements are compared corresponds to their linearized layout (i.e. each column of the first row is compared, then each column of the next row, and so on...).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of this matrix are lexicographically greater than the other matrix, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00683">683</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaee8264abbd772896815aee34c952ac1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; <a class="el" href="classecuda_1_1matrix.html#ac5f815079bedbc3323e5c77116586886">value_type</a>, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two matrices lexicographically. </p>
<p>The order that elements are compared corresponds to their linearized layout (i.e. each column of the first row is compared, then each column of the next row, and so on...).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of this matrix are lexicographically greater than or equal to the other matrix, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00710">710</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab9864c204c790fffbfb41f5e0fa4254d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a7947927ff51492aaa2e788151befca99">row_type</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a>&#160;</td>
          <td class="paramname"><em>rowIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator[](rowIndex) alias for get_row(rowIndex) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowIndex</td><td>index of the row to isolate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>view object for the specified row </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00539">539</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a48f09421c5aa969af1da89345e3b3b34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#ad0ffcd571700bbe2403095403cd445f9">const_row_type</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a>&#160;</td>
          <td class="paramname"><em>rowIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator[](rowIndex) alias for get_row(rowIndex) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowIndex</td><td>index of the row to isolate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>view object for the specified row </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00546">546</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab0b897ab384797891d842764494cddc0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#ac255dcaba969cc3a9767b6a20bb3db5f">reverse_iterator</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed container. </p>
<p>It corresponds to the last element of the non-reversed container.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00314">314</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a91a30f7fb3bd8a98d80fb375bd45a34a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#ac743fb5b0913c5a3ccff65cc0f311750">const_reverse_iterator</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed container. </p>
<p>It corresponds to the last element of the non-reversed container.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00333">333</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af4630a557cdec93883e53a68784a5c40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#ac255dcaba969cc3a9767b6a20bb3db5f">reverse_iterator</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed container. </p>
<p>It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00324">324</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a384a3cabde771c73dc001d621c5aa493"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#ac743fb5b0913c5a3ccff65cc0f311750">const_reverse_iterator</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed container. </p>
<p>It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00343">343</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae4748638a890938db56cdd9221347ec4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> void <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a>&#160;</td>
          <td class="paramname"><em>newNumberRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a>&#160;</td>
          <td class="paramname"><em>newNumberColumns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#ac5f815079bedbc3323e5c77116586886">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code><a class="el" href="classecuda_1_1matrix.html#ac5f815079bedbc3323e5c77116586886">value_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to have dimensions newNumberRows x newNumberColumns. </p>
<p>If the current size is greater in either or both dimensions, the existing elements are truncated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newNumberRows</td><td>new number of rows </td></tr>
    <tr><td class="paramname">newNumberColumns</td><td>new number of columns </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize the new elements with (default constructed if not specified) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00390">390</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a067b728cc23e2de6fb8ba75835f9f72b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1matrix.html#a2dc059f3d11827c75527cc8884d7c0ba">size_type</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the container (numberRows*numberColumns). </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00357">357</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af9a02afe8835857a4151f8bc9053b5d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc, P &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of the container with those of the other. </p>
<p>Does not invoke any move, copy, or swap operations on individual elements. All iterators and references remain valid. The past-the-end iterator is invalidated.</p>
<p>Although this can be called from both the host and device, a call from the device only swaps the contents of the containers in the calling thread only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to exchange the contents with </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00622">622</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="ac9ec3fbcd2ac57a92e744d585ac6a0d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;, class P = shared_ptr&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U , class Alloc2 , class Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classecuda_1_1matrix.html">matrix</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00158">158</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/ecuda/<a class="el" href="matrix_8hpp_source.html">matrix.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 28 2016 14:05:58 for Extended CUDA Library (ecuda) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
