<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Extended CUDA Library (ecuda): ecuda::matrix&lt; T, Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Extended CUDA Library (ecuda)
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceecuda.html">ecuda</a></li><li class="navelem"><a class="el" href="classecuda_1_1matrix.html">matrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classecuda_1_1matrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ecuda::matrix&lt; T, Alloc &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A resizable matrix stored in device memory.  
 <a href="classecuda_1_1matrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a98ff206805cd70f6b5a70cd6c1997826"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a></td></tr>
<tr class="memdesc:a98ff206805cd70f6b5a70cd6c1997826"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell data type  <a href="#a98ff206805cd70f6b5a70cd6c1997826">More...</a><br/></td></tr>
<tr class="separator:a98ff206805cd70f6b5a70cd6c1997826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac702fbaec24a5ad06a46171e4765dace"><td class="memItemLeft" align="right" valign="top">typedef Alloc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ac702fbaec24a5ad06a46171e4765dace">allocator_type</a></td></tr>
<tr class="memdesc:ac702fbaec24a5ad06a46171e4765dace"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type  <a href="#ac702fbaec24a5ad06a46171e4765dace">More...</a><br/></td></tr>
<tr class="separator:ac702fbaec24a5ad06a46171e4765dace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf61a7885dcb1f6598873e7fff33af4"><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a></td></tr>
<tr class="memdesc:aabf61a7885dcb1f6598873e7fff33af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned integral type  <a href="#aabf61a7885dcb1f6598873e7fff33af4">More...</a><br/></td></tr>
<tr class="separator:aabf61a7885dcb1f6598873e7fff33af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c8c2b07f0445a9b4d416dcd7bb56dd"><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a54c8c2b07f0445a9b4d416dcd7bb56dd">difference_type</a></td></tr>
<tr class="memdesc:a54c8c2b07f0445a9b4d416dcd7bb56dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed integral type  <a href="#a54c8c2b07f0445a9b4d416dcd7bb56dd">More...</a><br/></td></tr>
<tr class="separator:a54c8c2b07f0445a9b4d416dcd7bb56dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6ded4470757fa619873ae792bde260"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#afd6ded4470757fa619873ae792bde260">reference</a></td></tr>
<tr class="memdesc:afd6ded4470757fa619873ae792bde260"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell reference type  <a href="#afd6ded4470757fa619873ae792bde260">More...</a><br/></td></tr>
<tr class="separator:afd6ded4470757fa619873ae792bde260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66893e0729e39b8a851de853f4b9c60f"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a66893e0729e39b8a851de853f4b9c60f">const_reference</a></td></tr>
<tr class="memdesc:a66893e0729e39b8a851de853f4b9c60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell const reference type  <a href="#a66893e0729e39b8a851de853f4b9c60f">More...</a><br/></td></tr>
<tr class="separator:a66893e0729e39b8a851de853f4b9c60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae557b91e1336743625c2fd4634132672"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ae557b91e1336743625c2fd4634132672">pointer</a></td></tr>
<tr class="memdesc:ae557b91e1336743625c2fd4634132672"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell pointer type  <a href="#ae557b91e1336743625c2fd4634132672">More...</a><br/></td></tr>
<tr class="separator:ae557b91e1336743625c2fd4634132672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c67ed23295f86d8f3aea74d6cc2e3c"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a74c67ed23295f86d8f3aea74d6cc2e3c">const_pointer</a></td></tr>
<tr class="memdesc:a74c67ed23295f86d8f3aea74d6cc2e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell const pointer type  <a href="#a74c67ed23295f86d8f3aea74d6cc2e3c">More...</a><br/></td></tr>
<tr class="separator:a74c67ed23295f86d8f3aea74d6cc2e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259a05b61efca61de57617c6e2a4b42b"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classecuda_1_1contiguous__sequence__view.html">contiguous_sequence_view</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a259a05b61efca61de57617c6e2a4b42b">row_type</a></td></tr>
<tr class="memdesc:a259a05b61efca61de57617c6e2a4b42b"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix row container type  <a href="#a259a05b61efca61de57617c6e2a4b42b">More...</a><br/></td></tr>
<tr class="separator:a259a05b61efca61de57617c6e2a4b42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c441c91751839576bf074dd053749ee"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classecuda_1_1sequence__view.html">sequence_view</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>, <a class="el" href="classecuda_1_1padded__ptr.html">padded_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>, <a class="el" href="classecuda_1_1striding__ptr.html">striding_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a> &gt;, 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a4c441c91751839576bf074dd053749ee">column_type</a></td></tr>
<tr class="memdesc:a4c441c91751839576bf074dd053749ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix column container type  <a href="#a4c441c91751839576bf074dd053749ee">More...</a><br/></td></tr>
<tr class="separator:a4c441c91751839576bf074dd053749ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125da39d087f5f7ce853a302aef95b99"><td class="memItemLeft" align="right" valign="top">typedef const <br class="typebreak"/>
<a class="el" href="classecuda_1_1contiguous__sequence__view.html">contiguous_sequence_view</a><br class="typebreak"/>
&lt; const <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a125da39d087f5f7ce853a302aef95b99">const_row_type</a></td></tr>
<tr class="memdesc:a125da39d087f5f7ce853a302aef95b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix const row container type  <a href="#a125da39d087f5f7ce853a302aef95b99">More...</a><br/></td></tr>
<tr class="separator:a125da39d087f5f7ce853a302aef95b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62eb815d09942ed5b5ca0ee3c6e286c"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classecuda_1_1sequence__view.html">sequence_view</a><br class="typebreak"/>
&lt; const <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>, <a class="el" href="classecuda_1_1padded__ptr.html">padded_ptr</a><br class="typebreak"/>
&lt; const <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>, <br class="typebreak"/>
<a class="el" href="classecuda_1_1striding__ptr.html">striding_ptr</a>&lt; const <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a> &gt;, 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ad62eb815d09942ed5b5ca0ee3c6e286c">const_column_type</a></td></tr>
<tr class="memdesc:ad62eb815d09942ed5b5ca0ee3c6e286c"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix const column container type  <a href="#ad62eb815d09942ed5b5ca0ee3c6e286c">More...</a><br/></td></tr>
<tr class="separator:ad62eb815d09942ed5b5ca0ee3c6e286c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f79c587aeefa4b60c34a4188b34d850"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classecuda_1_1device__iterator.html">device_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>, <a class="el" href="classecuda_1_1padded__ptr.html">padded_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>, <a class="el" href="classecuda_1_1matrix.html#ae557b91e1336743625c2fd4634132672">pointer</a>, 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a1f79c587aeefa4b60c34a4188b34d850">iterator</a></td></tr>
<tr class="memdesc:a1f79c587aeefa4b60c34a4188b34d850"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator type  <a href="#a1f79c587aeefa4b60c34a4188b34d850">More...</a><br/></td></tr>
<tr class="separator:a1f79c587aeefa4b60c34a4188b34d850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d1152caca5f9324834f71a57abda45"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classecuda_1_1device__iterator.html">device_iterator</a>&lt; const <br class="typebreak"/>
<a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>, <a class="el" href="classecuda_1_1padded__ptr.html">padded_ptr</a>&lt; const <br class="typebreak"/>
<a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>, <a class="el" href="classecuda_1_1matrix.html#a74c67ed23295f86d8f3aea74d6cc2e3c">const_pointer</a>, 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ab6d1152caca5f9324834f71a57abda45">const_iterator</a></td></tr>
<tr class="memdesc:ab6d1152caca5f9324834f71a57abda45"><td class="mdescLeft">&#160;</td><td class="mdescRight">const iterator type  <a href="#ab6d1152caca5f9324834f71a57abda45">More...</a><br/></td></tr>
<tr class="separator:ab6d1152caca5f9324834f71a57abda45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6569cc486b72a5a234fecdbe16ec122"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classecuda_1_1reverse__device__iterator.html">reverse_device_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1matrix.html#a1f79c587aeefa4b60c34a4188b34d850">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#af6569cc486b72a5a234fecdbe16ec122">reverse_iterator</a></td></tr>
<tr class="memdesc:af6569cc486b72a5a234fecdbe16ec122"><td class="mdescLeft">&#160;</td><td class="mdescRight">reverse iterator type  <a href="#af6569cc486b72a5a234fecdbe16ec122">More...</a><br/></td></tr>
<tr class="separator:af6569cc486b72a5a234fecdbe16ec122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79611de33047f682840ac376e0ff196"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classecuda_1_1reverse__device__iterator.html">reverse_device_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1matrix.html#ab6d1152caca5f9324834f71a57abda45">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ac79611de33047f682840ac376e0ff196">const_reverse_iterator</a></td></tr>
<tr class="memdesc:ac79611de33047f682840ac376e0ff196"><td class="mdescLeft">&#160;</td><td class="mdescRight">const reverse iterator type  <a href="#ac79611de33047f682840ac376e0ff196">More...</a><br/></td></tr>
<tr class="separator:ac79611de33047f682840ac376e0ff196"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a98e330a7d3ba8c03e7cfa21f18ab3d53"><td class="memItemLeft" align="right" valign="top">HOST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a98e330a7d3ba8c03e7cfa21f18ab3d53">matrix</a> (const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a> numberRows=0, const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a> numberColumns=0, const T &amp;value=T(), const Alloc &amp;allocator=Alloc())</td></tr>
<tr class="memdesc:a98e330a7d3ba8c03e7cfa21f18ab3d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a matrix with dimensions numberRows x numberColumns filled with copies of elements with value value.  <a href="#a98e330a7d3ba8c03e7cfa21f18ab3d53">More...</a><br/></td></tr>
<tr class="separator:a98e330a7d3ba8c03e7cfa21f18ab3d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae68ab54ca2bc6a36c2aac3c58536ee4"><td class="memItemLeft" align="right" valign="top">HOST DEVICE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#aae68ab54ca2bc6a36c2aac3c58536ee4">matrix</a> (const <a class="el" href="classecuda_1_1matrix.html">matrix</a> &amp;src)</td></tr>
<tr class="memdesc:aae68ab54ca2bc6a36c2aac3c58536ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a matrix with a shallow copy of each of the elements in src.  <a href="#aae68ab54ca2bc6a36c2aac3c58536ee4">More...</a><br/></td></tr>
<tr class="separator:aae68ab54ca2bc6a36c2aac3c58536ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed9a22231910968b86daefd41a39b1f"><td class="memItemLeft" align="right" valign="top">HOST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a8ed9a22231910968b86daefd41a39b1f">matrix</a> (<a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T &gt; &amp;&amp;src)</td></tr>
<tr class="memdesc:a8ed9a22231910968b86daefd41a39b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Constructs the container with the contents of the other using move semantics.  <a href="#a8ed9a22231910968b86daefd41a39b1f">More...</a><br/></td></tr>
<tr class="separator:a8ed9a22231910968b86daefd41a39b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6c98eb22a8c57990818eb045dab534"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#a1f79c587aeefa4b60c34a4188b34d850">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a1a6c98eb22a8c57990818eb045dab534">begin</a> () __NOEXCEPT__</td></tr>
<tr class="memdesc:a1a6c98eb22a8c57990818eb045dab534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="#a1a6c98eb22a8c57990818eb045dab534">More...</a><br/></td></tr>
<tr class="separator:a1a6c98eb22a8c57990818eb045dab534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af795712961534a0667aa8b8b2e8afdd1"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#a1f79c587aeefa4b60c34a4188b34d850">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#af795712961534a0667aa8b8b2e8afdd1">end</a> () __NOEXCEPT__</td></tr>
<tr class="memdesc:af795712961534a0667aa8b8b2e8afdd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="#af795712961534a0667aa8b8b2e8afdd1">More...</a><br/></td></tr>
<tr class="separator:af795712961534a0667aa8b8b2e8afdd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf0046182fd3997e24fb087c55fcad8"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#ab6d1152caca5f9324834f71a57abda45">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a5bf0046182fd3997e24fb087c55fcad8">begin</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:a5bf0046182fd3997e24fb087c55fcad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="#a5bf0046182fd3997e24fb087c55fcad8">More...</a><br/></td></tr>
<tr class="separator:a5bf0046182fd3997e24fb087c55fcad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0856ed91548f60f90dfd8028964c202"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#ab6d1152caca5f9324834f71a57abda45">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ac0856ed91548f60f90dfd8028964c202">end</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:ac0856ed91548f60f90dfd8028964c202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="#ac0856ed91548f60f90dfd8028964c202">More...</a><br/></td></tr>
<tr class="separator:ac0856ed91548f60f90dfd8028964c202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9725d9654c4965e36084a8d903ddbe"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#af6569cc486b72a5a234fecdbe16ec122">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#add9725d9654c4965e36084a8d903ddbe">rbegin</a> () __NOEXCEPT__</td></tr>
<tr class="memdesc:add9725d9654c4965e36084a8d903ddbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed container.  <a href="#add9725d9654c4965e36084a8d903ddbe">More...</a><br/></td></tr>
<tr class="separator:add9725d9654c4965e36084a8d903ddbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3b8fc063697c9f046d024afea8dfe7"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#af6569cc486b72a5a234fecdbe16ec122">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#aac3b8fc063697c9f046d024afea8dfe7">rend</a> () __NOEXCEPT__</td></tr>
<tr class="memdesc:aac3b8fc063697c9f046d024afea8dfe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed container.  <a href="#aac3b8fc063697c9f046d024afea8dfe7">More...</a><br/></td></tr>
<tr class="separator:aac3b8fc063697c9f046d024afea8dfe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afadcbdedfe526df5497970186b1dd09d"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#ac79611de33047f682840ac376e0ff196">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#afadcbdedfe526df5497970186b1dd09d">rbegin</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:afadcbdedfe526df5497970186b1dd09d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed container.  <a href="#afadcbdedfe526df5497970186b1dd09d">More...</a><br/></td></tr>
<tr class="separator:afadcbdedfe526df5497970186b1dd09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c231293048a18afff7688a890138e0"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#ac79611de33047f682840ac376e0ff196">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a26c231293048a18afff7688a890138e0">rend</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:a26c231293048a18afff7688a890138e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed container.  <a href="#a26c231293048a18afff7688a890138e0">More...</a><br/></td></tr>
<tr class="separator:a26c231293048a18afff7688a890138e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9ac9fd37bf8d0304f07110d59ba40a"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#ab6d1152caca5f9324834f71a57abda45">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#abb9ac9fd37bf8d0304f07110d59ba40a">cbegin</a> () const __NOEXCEPT__</td></tr>
<tr class="separator:abb9ac9fd37bf8d0304f07110d59ba40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39991d6f8e9f8f27848ea5db5626e1a8"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#ab6d1152caca5f9324834f71a57abda45">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a39991d6f8e9f8f27848ea5db5626e1a8">cend</a> () const __NOEXCEPT__</td></tr>
<tr class="separator:a39991d6f8e9f8f27848ea5db5626e1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0685a1bd34187372bf6527c852184ba"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#ac79611de33047f682840ac376e0ff196">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ac0685a1bd34187372bf6527c852184ba">crbegin</a> () __NOEXCEPT__</td></tr>
<tr class="separator:ac0685a1bd34187372bf6527c852184ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b01ff1a23591cd33f7fb76ade1575e"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#ac79611de33047f682840ac376e0ff196">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ab5b01ff1a23591cd33f7fb76ade1575e">crend</a> () __NOEXCEPT__</td></tr>
<tr class="separator:ab5b01ff1a23591cd33f7fb76ade1575e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a01ee901e90891187bb085066a2269"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ae8a01ee901e90891187bb085066a2269">size</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:ae8a01ee901e90891187bb085066a2269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container (numberRows*numberColumns).  <a href="#ae8a01ee901e90891187bb085066a2269">More...</a><br/></td></tr>
<tr class="separator:ae8a01ee901e90891187bb085066a2269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897e4a51a1815834d02090032bfd420b"><td class="memItemLeft" align="right" valign="top">HOST DEVICE __CONSTEXPR__ <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a897e4a51a1815834d02090032bfd420b">max_size</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:a897e4a51a1815834d02090032bfd420b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the container is able to hold due to system or library implementation limitations.  <a href="#a897e4a51a1815834d02090032bfd420b">More...</a><br/></td></tr>
<tr class="separator:a897e4a51a1815834d02090032bfd420b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cd78b7556febca832023c4d6ef3812"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a00cd78b7556febca832023c4d6ef3812">number_rows</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:a00cd78b7556febca832023c4d6ef3812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rows in the container.  <a href="#a00cd78b7556febca832023c4d6ef3812">More...</a><br/></td></tr>
<tr class="separator:a00cd78b7556febca832023c4d6ef3812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d63816227c0ab01aed53486fd9932f"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a54d63816227c0ab01aed53486fd9932f">number_columns</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:a54d63816227c0ab01aed53486fd9932f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in the container.  <a href="#a54d63816227c0ab01aed53486fd9932f">More...</a><br/></td></tr>
<tr class="separator:a54d63816227c0ab01aed53486fd9932f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442651b85e74534c2100b43b41fb1fe2"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a442651b85e74534c2100b43b41fb1fe2">get_pitch</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:a442651b85e74534c2100b43b41fb1fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pitch of the underlying 2D device memory.  <a href="#a442651b85e74534c2100b43b41fb1fe2">More...</a><br/></td></tr>
<tr class="separator:a442651b85e74534c2100b43b41fb1fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96278422bbfb42a3e82798ab6698a5b4"><td class="memItemLeft" align="right" valign="top">HOST void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a96278422bbfb42a3e82798ab6698a5b4">resize</a> (const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a> newNumberRows, const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a> newNumberColumns, const <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a> &amp;value=<a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>())</td></tr>
<tr class="memdesc:a96278422bbfb42a3e82798ab6698a5b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to have dimensions newNumberRows x newNumberColumns.  <a href="#a96278422bbfb42a3e82798ab6698a5b4">More...</a><br/></td></tr>
<tr class="separator:a96278422bbfb42a3e82798ab6698a5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6a8e8d50cf742b488caccb0a2629e1"><td class="memItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a6d6a8e8d50cf742b488caccb0a2629e1">empty</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:a6d6a8e8d50cf742b488caccb0a2629e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container has no elements.  <a href="#a6d6a8e8d50cf742b488caccb0a2629e1">More...</a><br/></td></tr>
<tr class="separator:a6d6a8e8d50cf742b488caccb0a2629e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fec8d606dfb1084a92275c78e5159e"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#a259a05b61efca61de57617c6e2a4b42b">row_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a92fec8d606dfb1084a92275c78e5159e">get_row</a> (const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a> rowIndex)</td></tr>
<tr class="memdesc:a92fec8d606dfb1084a92275c78e5159e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a view object of a single row of the matrix.  <a href="#a92fec8d606dfb1084a92275c78e5159e">More...</a><br/></td></tr>
<tr class="separator:a92fec8d606dfb1084a92275c78e5159e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926b29dd74d04690320c98e17190e6bb"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#a125da39d087f5f7ce853a302aef95b99">const_row_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a926b29dd74d04690320c98e17190e6bb">get_row</a> (const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a> rowIndex) const </td></tr>
<tr class="memdesc:a926b29dd74d04690320c98e17190e6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a view object of a single row of the matrix.  <a href="#a926b29dd74d04690320c98e17190e6bb">More...</a><br/></td></tr>
<tr class="separator:a926b29dd74d04690320c98e17190e6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673e78abb3a630b5b98cb1a58906c9a3"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#a4c441c91751839576bf074dd053749ee">column_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a673e78abb3a630b5b98cb1a58906c9a3">get_column</a> (const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a> columnIndex)</td></tr>
<tr class="memdesc:a673e78abb3a630b5b98cb1a58906c9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a view object of a single column of the matrix.  <a href="#a673e78abb3a630b5b98cb1a58906c9a3">More...</a><br/></td></tr>
<tr class="separator:a673e78abb3a630b5b98cb1a58906c9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c7103d1745e744d42e04952d31e5a1"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#ad62eb815d09942ed5b5ca0ee3c6e286c">const_column_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a80c7103d1745e744d42e04952d31e5a1">get_column</a> (const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a> columnIndex) const </td></tr>
<tr class="memdesc:a80c7103d1745e744d42e04952d31e5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a view object of a single column of the matrix.  <a href="#a80c7103d1745e744d42e04952d31e5a1">More...</a><br/></td></tr>
<tr class="separator:a80c7103d1745e744d42e04952d31e5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c315c44a0a5f0a385612add3f4440d"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#a259a05b61efca61de57617c6e2a4b42b">row_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ac9c315c44a0a5f0a385612add3f4440d">operator[]</a> (const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a> rowIndex)</td></tr>
<tr class="memdesc:ac9c315c44a0a5f0a385612add3f4440d"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator[](rowIndex) alias for get_row(rowIndex)  <a href="#ac9c315c44a0a5f0a385612add3f4440d">More...</a><br/></td></tr>
<tr class="separator:ac9c315c44a0a5f0a385612add3f4440d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8756e9fdfed58a1ffd52482fcff4da"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#a125da39d087f5f7ce853a302aef95b99">const_row_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a5e8756e9fdfed58a1ffd52482fcff4da">operator[]</a> (const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a> rowIndex) const </td></tr>
<tr class="memdesc:a5e8756e9fdfed58a1ffd52482fcff4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator[](rowIndex) alias for get_row(rowIndex)  <a href="#a5e8756e9fdfed58a1ffd52482fcff4da">More...</a><br/></td></tr>
<tr class="separator:a5e8756e9fdfed58a1ffd52482fcff4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade446c8a8ee5feb45bc792284235fd68"><td class="memItemLeft" align="right" valign="top">DEVICE <a class="el" href="classecuda_1_1matrix.html#afd6ded4470757fa619873ae792bde260">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ade446c8a8ee5feb45bc792284235fd68">front</a> ()</td></tr>
<tr class="memdesc:ade446c8a8ee5feb45bc792284235fd68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container.  <a href="#ade446c8a8ee5feb45bc792284235fd68">More...</a><br/></td></tr>
<tr class="separator:ade446c8a8ee5feb45bc792284235fd68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e47d6f4eeea044e4e9766d6baec2b9"><td class="memItemLeft" align="right" valign="top">DEVICE <a class="el" href="classecuda_1_1matrix.html#afd6ded4470757fa619873ae792bde260">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a96e47d6f4eeea044e4e9766d6baec2b9">back</a> ()</td></tr>
<tr class="memdesc:a96e47d6f4eeea044e4e9766d6baec2b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container.  <a href="#a96e47d6f4eeea044e4e9766d6baec2b9">More...</a><br/></td></tr>
<tr class="separator:a96e47d6f4eeea044e4e9766d6baec2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ad537eb3eada60d1f687d850fe4e9d"><td class="memItemLeft" align="right" valign="top">DEVICE <a class="el" href="classecuda_1_1matrix.html#a66893e0729e39b8a851de853f4b9c60f">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#aa7ad537eb3eada60d1f687d850fe4e9d">front</a> () const </td></tr>
<tr class="memdesc:aa7ad537eb3eada60d1f687d850fe4e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container.  <a href="#aa7ad537eb3eada60d1f687d850fe4e9d">More...</a><br/></td></tr>
<tr class="separator:aa7ad537eb3eada60d1f687d850fe4e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe4e08fc0013c81b9a184ab7c577b11"><td class="memItemLeft" align="right" valign="top">DEVICE <a class="el" href="classecuda_1_1matrix.html#a66893e0729e39b8a851de853f4b9c60f">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a9fe4e08fc0013c81b9a184ab7c577b11">back</a> () const </td></tr>
<tr class="memdesc:a9fe4e08fc0013c81b9a184ab7c577b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container.  <a href="#a9fe4e08fc0013c81b9a184ab7c577b11">More...</a><br/></td></tr>
<tr class="separator:a9fe4e08fc0013c81b9a184ab7c577b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1cf710d0d9d50358a7820a7765f8fce"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#ae557b91e1336743625c2fd4634132672">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ab1cf710d0d9d50358a7820a7765f8fce">data</a> () __NOEXCEPT__</td></tr>
<tr class="memdesc:ab1cf710d0d9d50358a7820a7765f8fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage.  <a href="#ab1cf710d0d9d50358a7820a7765f8fce">More...</a><br/></td></tr>
<tr class="separator:ab1cf710d0d9d50358a7820a7765f8fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0922b7d2f8aa1c5e4198ef3bb9fd973"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#a74c67ed23295f86d8f3aea74d6cc2e3c">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ac0922b7d2f8aa1c5e4198ef3bb9fd973">data</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:ac0922b7d2f8aa1c5e4198ef3bb9fd973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage.  <a href="#ac0922b7d2f8aa1c5e4198ef3bb9fd973">More...</a><br/></td></tr>
<tr class="separator:ac0922b7d2f8aa1c5e4198ef3bb9fd973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d92e326a0b1e784e9c431ba8b1eecd7"><td class="memItemLeft" align="right" valign="top">HOST void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a5d92e326a0b1e784e9c431ba8b1eecd7">assign</a> (<a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a> newNumberRows, <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a> newNumberColumns, const <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a> &amp;value=<a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>())</td></tr>
<tr class="memdesc:a5d92e326a0b1e784e9c431ba8b1eecd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the container.  <a href="#a5d92e326a0b1e784e9c431ba8b1eecd7">More...</a><br/></td></tr>
<tr class="separator:a5d92e326a0b1e784e9c431ba8b1eecd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6812a1306edebd818d3c596c0c0c1b4"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:ac6812a1306edebd818d3c596c0c0c1b4"><td class="memTemplItemLeft" align="right" valign="top">HOST DEVICE void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ac6812a1306edebd818d3c596c0c0c1b4">assign</a> (Iterator first, Iterator last)</td></tr>
<tr class="memdesc:ac6812a1306edebd818d3c596c0c0c1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the container with copies of those in the range [begin,end).  <a href="#ac6812a1306edebd818d3c596c0c0c1b4">More...</a><br/></td></tr>
<tr class="separator:ac6812a1306edebd818d3c596c0c0c1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529dac481c819f8d16afc1b1fcfa1ef2"><td class="memItemLeft" align="right" valign="top">HOST void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a529dac481c819f8d16afc1b1fcfa1ef2">assign</a> (std::initializer_list&lt; T &gt; il)</td></tr>
<tr class="memdesc:a529dac481c819f8d16afc1b1fcfa1ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the container with copies of those in the initializer list.  <a href="#a529dac481c819f8d16afc1b1fcfa1ef2">More...</a><br/></td></tr>
<tr class="separator:a529dac481c819f8d16afc1b1fcfa1ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d43f72d362ef12df6d3dfcc0be742cb"><td class="memItemLeft" align="right" valign="top">HOST DEVICE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a1d43f72d362ef12df6d3dfcc0be742cb">fill</a> (const <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a1d43f72d362ef12df6d3dfcc0be742cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a given value to all elements in the container.  <a href="#a1d43f72d362ef12df6d3dfcc0be742cb">More...</a><br/></td></tr>
<tr class="separator:a1d43f72d362ef12df6d3dfcc0be742cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc3cc204a820a9d45b7eb4d57bb7af0"><td class="memItemLeft" align="right" valign="top">HOST DEVICE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a7cc3cc204a820a9d45b7eb4d57bb7af0">swap</a> (<a class="el" href="classecuda_1_1matrix.html">matrix</a> &amp;other)</td></tr>
<tr class="memdesc:a7cc3cc204a820a9d45b7eb4d57bb7af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the container with those of the other.  <a href="#a7cc3cc204a820a9d45b7eb4d57bb7af0">More...</a><br/></td></tr>
<tr class="separator:a7cc3cc204a820a9d45b7eb4d57bb7af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1957fea2d7c2fffca82baac04ad0f8"><td class="memItemLeft" align="right" valign="top">HOST <a class="el" href="classecuda_1_1matrix.html#ac702fbaec24a5ad06a46171e4765dace">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a8a1957fea2d7c2fffca82baac04ad0f8">get_allocator</a> () const </td></tr>
<tr class="memdesc:a8a1957fea2d7c2fffca82baac04ad0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the container.  <a href="#a8a1957fea2d7c2fffca82baac04ad0f8">More...</a><br/></td></tr>
<tr class="separator:a8a1957fea2d7c2fffca82baac04ad0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2e804bac9e756054cd0560a2696e77"><td class="memTemplParams" colspan="2">template&lt;class Alloc2 &gt; </td></tr>
<tr class="memitem:a9f2e804bac9e756054cd0560a2696e77"><td class="memTemplItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a9f2e804bac9e756054cd0560a2696e77">operator==</a> (const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>, Alloc2 &gt; &amp;other) const </td></tr>
<tr class="memdesc:a9f2e804bac9e756054cd0560a2696e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of two matrices are equal.  <a href="#a9f2e804bac9e756054cd0560a2696e77">More...</a><br/></td></tr>
<tr class="separator:a9f2e804bac9e756054cd0560a2696e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c78744241d852094401c2d726d53ab"><td class="memTemplParams" colspan="2">template&lt;class Alloc2 &gt; </td></tr>
<tr class="memitem:a70c78744241d852094401c2d726d53ab"><td class="memTemplItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a70c78744241d852094401c2d726d53ab">operator!=</a> (const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>, Alloc2 &gt; &amp;other) const </td></tr>
<tr class="memdesc:a70c78744241d852094401c2d726d53ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of two matrices are not equal.  <a href="#a70c78744241d852094401c2d726d53ab">More...</a><br/></td></tr>
<tr class="separator:a70c78744241d852094401c2d726d53ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3b2d1f6ea70da095993e8b37d792ee"><td class="memTemplParams" colspan="2">template&lt;class Alloc2 &gt; </td></tr>
<tr class="memitem:a4b3b2d1f6ea70da095993e8b37d792ee"><td class="memTemplItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a4b3b2d1f6ea70da095993e8b37d792ee">operator&lt;</a> (const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>, Alloc2 &gt; &amp;other) const </td></tr>
<tr class="memdesc:a4b3b2d1f6ea70da095993e8b37d792ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two matrices lexicographically.  <a href="#a4b3b2d1f6ea70da095993e8b37d792ee">More...</a><br/></td></tr>
<tr class="separator:a4b3b2d1f6ea70da095993e8b37d792ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca45f3dcf01cc1afc120234a092f5eff"><td class="memTemplParams" colspan="2">template&lt;class Alloc2 &gt; </td></tr>
<tr class="memitem:aca45f3dcf01cc1afc120234a092f5eff"><td class="memTemplItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#aca45f3dcf01cc1afc120234a092f5eff">operator&gt;</a> (const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>, Alloc2 &gt; &amp;other) const </td></tr>
<tr class="memdesc:aca45f3dcf01cc1afc120234a092f5eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two matrices lexicographically.  <a href="#aca45f3dcf01cc1afc120234a092f5eff">More...</a><br/></td></tr>
<tr class="separator:aca45f3dcf01cc1afc120234a092f5eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d4e1c65a3507a10cdcbf2ca3792a05"><td class="memTemplParams" colspan="2">template&lt;class Alloc2 &gt; </td></tr>
<tr class="memitem:ac0d4e1c65a3507a10cdcbf2ca3792a05"><td class="memTemplItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ac0d4e1c65a3507a10cdcbf2ca3792a05">operator&lt;=</a> (const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>, Alloc2 &gt; &amp;other) const </td></tr>
<tr class="memdesc:ac0d4e1c65a3507a10cdcbf2ca3792a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two matrices lexicographically.  <a href="#ac0d4e1c65a3507a10cdcbf2ca3792a05">More...</a><br/></td></tr>
<tr class="separator:ac0d4e1c65a3507a10cdcbf2ca3792a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a055d82e32c1fca84cd93fd4e8de09"><td class="memTemplParams" colspan="2">template&lt;class Alloc2 &gt; </td></tr>
<tr class="memitem:ae7a055d82e32c1fca84cd93fd4e8de09"><td class="memTemplItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ae7a055d82e32c1fca84cd93fd4e8de09">operator&gt;=</a> (const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>, Alloc2 &gt; &amp;other) const </td></tr>
<tr class="memdesc:ae7a055d82e32c1fca84cd93fd4e8de09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two matrices lexicographically.  <a href="#ae7a055d82e32c1fca84cd93fd4e8de09">More...</a><br/></td></tr>
<tr class="separator:ae7a055d82e32c1fca84cd93fd4e8de09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a287fb563886422b317545f21e4340"><td class="memItemLeft" align="right" valign="top">DEVICE T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ae9a287fb563886422b317545f21e4340">at</a> (const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a> rowIndex, const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a> columnIndex)</td></tr>
<tr class="memdesc:ae9a287fb563886422b317545f21e4340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at the specified matrix location.  <a href="#ae9a287fb563886422b317545f21e4340">More...</a><br/></td></tr>
<tr class="separator:ae9a287fb563886422b317545f21e4340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b04bc2f78b1fb46d3448bbde176935a"><td class="memItemLeft" align="right" valign="top">DEVICE const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#a4b04bc2f78b1fb46d3448bbde176935a">at</a> (const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a> rowIndex, const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a> columnIndex) const </td></tr>
<tr class="memdesc:a4b04bc2f78b1fb46d3448bbde176935a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at the specified matrix location.  <a href="#a4b04bc2f78b1fb46d3448bbde176935a">More...</a><br/></td></tr>
<tr class="separator:a4b04bc2f78b1fb46d3448bbde176935a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e2ec8c9afa4171008c7f5cabace504"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:ae3e2ec8c9afa4171008c7f5cabace504"><td class="memTemplItemLeft" align="right" valign="top">HOST Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#ae3e2ec8c9afa4171008c7f5cabace504">operator&gt;&gt;</a> (Container &amp;dest) const </td></tr>
<tr class="memdesc:ae3e2ec8c9afa4171008c7f5cabace504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the contents of this device matrix to another container.  <a href="#ae3e2ec8c9afa4171008c7f5cabace504">More...</a><br/></td></tr>
<tr class="separator:ae3e2ec8c9afa4171008c7f5cabace504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa77e4908a3fed713f834ee26f48007"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:affa77e4908a3fed713f834ee26f48007"><td class="memTemplItemLeft" align="right" valign="top">HOST <a class="el" href="classecuda_1_1matrix.html">matrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html#affa77e4908a3fed713f834ee26f48007">operator&lt;&lt;</a> (const Container &amp;src)</td></tr>
<tr class="memdesc:affa77e4908a3fed713f834ee26f48007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the contents of another container to this device matrix.  <a href="#affa77e4908a3fed713f834ee26f48007">More...</a><br/></td></tr>
<tr class="separator:affa77e4908a3fed713f834ee26f48007"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt;<br/>
class ecuda::matrix&lt; T, Alloc &gt;</h3>

<p>A resizable matrix stored in device memory. </p>
<p>A matrix is defined as a 2D structure of dimensions rows*columns. The default implementation uses pitched memory where a 2D block of video memory is allocated with width=columns and height=rows. Pitched memory is aligned in a device-dependent manner so that calls to individual elements can be threaded more efficiently (i.e. minimizing the number of read operations required to supply data to multiple threads). Consult the CUDA API documentation for a more verbose explanation.</p>
<p>Methods are prefaced with appropriate keywords to declare them as host and/or device capable. In general: operations requiring memory allocation/deallocation are host only, operations to access the values of specific elements are device only, and copy operations on ranges of data and accessors of general information can be performed on both the host and device.</p>
<p>Memory use can be conceptualized as: </p>
<div class="fragment"><div class="line">     |- columns -|</div>
<div class="line">     |---- pitch -----|</div>
<div class="line">  _  +-----------+----+</div>
<div class="line"> |   |           |xxxx| x = allocated but not used, just padding to</div>
<div class="line"> |   |           |xxxx|     enforce an efficient memory alignment</div>
<div class="line">rows |           |xxxx|</div>
<div class="line"> |   |           |xxxx|</div>
<div class="line"> |_  +-----------+----+</div>
</div><!-- fragment --><p>As a result, it is highly desirable for threading to utilize a column-wise orientation. For example, a good kernel to perform an operation on the elements of a matrix might be:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; __global__ <span class="keywordtype">void</span> doMatrixOperation( <a class="code" href="classecuda_1_1matrix.html">ecuda::matrix&lt;T&gt;</a> <a class="code" href="classecuda_1_1matrix.html#a98e330a7d3ba8c03e7cfa21f18ab3d53">matrix</a> ) {</div>
<div class="line">   <span class="keyword">const</span> <span class="keywordtype">int</span> row = blockIdx.x;</div>
<div class="line">   <span class="keyword">const</span> <span class="keywordtype">int</span> col = blockDim.y*gridDim.y; <span class="comment">// each thread gets a different column value</span></div>
<div class="line">   <span class="keywordflow">if</span>( row &lt; matrix.<a class="code" href="classecuda_1_1matrix.html#a00cd78b7556febca832023c4d6ef3812">number_rows</a>() and col &lt; matrix.<a class="code" href="classecuda_1_1matrix.html#a54d63816227c0ab01aed53486fd9932f">number_columns</a>() ) {</div>
<div class="line">      T&amp; value = matrix[row][col];</div>
<div class="line">      <span class="comment">// ... do work on value</span></div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p>This could be called from host code like: </p>
<div class="fragment"><div class="line"><a class="code" href="classecuda_1_1matrix.html">ecuda::matrix&lt;double&gt;</a> <a class="code" href="classecuda_1_1matrix.html#a98e330a7d3ba8c03e7cfa21f18ab3d53">matrix</a>( 100, 1000 );</div>
<div class="line"><span class="comment">// ... fill matrix with data</span></div>
<div class="line">dim3 grid( 100, 1 ), block( 1, 1000 );</div>
<div class="line">doMatrixOperation&lt;&lt;&lt;grid,block&gt;&gt;&gt;( <a class="code" href="classecuda_1_1matrix.html#a98e330a7d3ba8c03e7cfa21f18ab3d53">matrix</a> );</div>
</div><!-- fragment --><p>Unfortunately, CUDA solutions are very problem specific, so there is no generally applicable example for specifying how thread blocks should be defined. The size of the matrix, hardware limitations, CUDA API limitations, etc. all play a part. For example, the above implementation won't work in earlier versions of CUDA since blockDim.y was limited to 512 (at the time of this writing it was 1024 in the newer versions of CUDA).</p>
<p>Just keep in mind that the column dimension lies in contiguous memory, and the row dimension is contiguous blocks of columns; thus, an implementation that aims to have concurrently running threads accessing column &gt;&gt;&gt;&gt; row will run much more efficiently.</p>
<p>Matrix iterators (via <a class="el" href="classecuda_1_1matrix.html#a1a6c98eb22a8c57990818eb045dab534" title="Returns an iterator to the first element of the container. ">begin()</a>,<a class="el" href="classecuda_1_1matrix.html#af795712961534a0667aa8b8b2e8afdd1" title="Returns an iterator to the element following the last element of the container. ">end()</a>,<a class="el" href="classecuda_1_1matrix.html#add9725d9654c4965e36084a8d903ddbe" title="Returns a reverse iterator to the first element of the reversed container. ">rbegin()</a>,<a class="el" href="classecuda_1_1matrix.html#aac3b8fc063697c9f046d024afea8dfe7" title="Returns a reverse iterator to the element following the last element of the reversed container...">rend()</a>) and lexicographical comparisons traverse the matrix linearly in row-major fashion (i.e. each column of the first row is traversed, then each column of the next row, and so on...). </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00122">122</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ac702fbaec24a5ad06a46171e4765dace"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Alloc <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1matrix.html#ac702fbaec24a5ad06a46171e4765dace">allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocator type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00126">126</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4c441c91751839576bf074dd053749ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1sequence__view.html">sequence_view</a>&lt; <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>, <a class="el" href="classecuda_1_1padded__ptr.html">padded_ptr</a>&lt;<a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>,<a class="el" href="classecuda_1_1striding__ptr.html">striding_ptr</a>&lt;<a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>&gt;,1&gt; &gt; <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1matrix.html#a4c441c91751839576bf074dd053749ee">column_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>matrix column container type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00135">135</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad62eb815d09942ed5b5ca0ee3c6e286c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classecuda_1_1sequence__view.html">sequence_view</a>&lt; const <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>, <a class="el" href="classecuda_1_1padded__ptr.html">padded_ptr</a>&lt;const <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>,<a class="el" href="classecuda_1_1striding__ptr.html">striding_ptr</a>&lt;const <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>&gt;,1&gt; &gt; <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1matrix.html#ad62eb815d09942ed5b5ca0ee3c6e286c">const_column_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>matrix const column container type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00137">137</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab6d1152caca5f9324834f71a57abda45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1device__iterator.html">device_iterator</a>&lt; const <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>, <a class="el" href="classecuda_1_1padded__ptr.html">padded_ptr</a>&lt;const <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>,<a class="el" href="classecuda_1_1matrix.html#a74c67ed23295f86d8f3aea74d6cc2e3c">const_pointer</a>,1&gt; &gt; <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1matrix.html#ab6d1152caca5f9324834f71a57abda45">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const iterator type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00140">140</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a74c67ed23295f86d8f3aea74d6cc2e3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>* <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1matrix.html#a74c67ed23295f86d8f3aea74d6cc2e3c">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell const pointer type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00132">132</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a66893e0729e39b8a851de853f4b9c60f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>&amp; <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1matrix.html#a66893e0729e39b8a851de853f4b9c60f">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell const reference type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00130">130</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac79611de33047f682840ac376e0ff196"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1reverse__device__iterator.html">reverse_device_iterator</a>&lt;<a class="el" href="classecuda_1_1matrix.html#ab6d1152caca5f9324834f71a57abda45">const_iterator</a>&gt; <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1matrix.html#ac79611de33047f682840ac376e0ff196">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const reverse iterator type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00142">142</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a125da39d087f5f7ce853a302aef95b99"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classecuda_1_1contiguous__sequence__view.html">contiguous_sequence_view</a>&lt;const <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>&gt; <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1matrix.html#a125da39d087f5f7ce853a302aef95b99">const_row_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>matrix const row container type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00136">136</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a54c8c2b07f0445a9b4d416dcd7bb56dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::ptrdiff_t <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1matrix.html#a54c8c2b07f0445a9b4d416dcd7bb56dd">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>signed integral type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00128">128</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1f79c587aeefa4b60c34a4188b34d850"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1device__iterator.html">device_iterator</a>&lt; <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>, <a class="el" href="classecuda_1_1padded__ptr.html">padded_ptr</a>&lt;<a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>,<a class="el" href="classecuda_1_1matrix.html#ae557b91e1336743625c2fd4634132672">pointer</a>,1&gt; &gt; <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1matrix.html#a1f79c587aeefa4b60c34a4188b34d850">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iterator type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00139">139</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae557b91e1336743625c2fd4634132672"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>* <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1matrix.html#ae557b91e1336743625c2fd4634132672">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell pointer type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00131">131</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afd6ded4470757fa619873ae792bde260"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>&amp; <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1matrix.html#afd6ded4470757fa619873ae792bde260">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell reference type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00129">129</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6569cc486b72a5a234fecdbe16ec122"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1reverse__device__iterator.html">reverse_device_iterator</a>&lt;<a class="el" href="classecuda_1_1matrix.html#a1f79c587aeefa4b60c34a4188b34d850">iterator</a>&gt; <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1matrix.html#af6569cc486b72a5a234fecdbe16ec122">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reverse iterator type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00141">141</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a259a05b61efca61de57617c6e2a4b42b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1contiguous__sequence__view.html">contiguous_sequence_view</a>&lt;<a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>&gt; <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1matrix.html#a259a05b61efca61de57617c6e2a4b42b">row_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>matrix row container type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00134">134</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aabf61a7885dcb1f6598873e7fff33af4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unsigned integral type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00127">127</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a98ff206805cd70f6b5a70cd6c1997826"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell data type </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00125">125</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a98e330a7d3ba8c03e7cfa21f18ab3d53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1matrix.html">matrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a>&#160;</td>
          <td class="paramname"><em>numberRows</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a>&#160;</td>
          <td class="paramname"><em>numberColumns</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code>T()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>Alloc()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a matrix with dimensions numberRows x numberColumns filled with copies of elements with value value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numberRows</td><td>number of rows (default: 0) </td></tr>
    <tr><td class="paramname">numberColumns</td><td>number of columns (default: 0) </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize elements of the matrix with (default: T()) </td></tr>
    <tr><td class="paramname">allocator</td><td>allocator to use for all memory allocations of this container (does not normally need to be specified, by default the internal ecuda pitched memory allocator) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00164">164</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aae68ab54ca2bc6a36c2aac3c58536ee4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1matrix.html">matrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a matrix with a shallow copy of each of the elements in src. </p>
<p>Be careful to note that a shallow copy means that only the pointer to the device memory that holds the elements is copied in the newly constructed container. This allows containers to be passed-by-value to kernel functions with minimal overhead. If a deep copy of the container is required in host code, use the &lt;&lt; or &gt;&gt; operators, or use iterators. For example:</p>
<div class="fragment"><div class="line"><a class="code" href="classecuda_1_1matrix.html">ecuda::matrix&lt;int&gt;</a> <a class="code" href="classecuda_1_1matrix.html#a98e330a7d3ba8c03e7cfa21f18ab3d53">matrix</a>( 5, 10, 99 ); <span class="comment">// create a matrix of dimensions 5x10 filled with 99</span></div>
<div class="line"><a class="code" href="classecuda_1_1matrix.html">ecuda::matrix&lt;int&gt;</a> newMatrix( matrix ); <span class="comment">// shallow copy (changes to newMatrix reflected in matrix)</span></div>
<div class="line"><a class="code" href="classecuda_1_1matrix.html">ecuda::matrix&lt;int&gt;</a> newMatrix( 5, 10 );</div>
<div class="line">newMatrix &lt;&lt; <a class="code" href="classecuda_1_1matrix.html#a98e330a7d3ba8c03e7cfa21f18ab3d53">matrix</a>; <span class="comment">// deep copy</span></div>
<div class="line">matrix &gt;&gt; newMatrix; <span class="comment">// deep copy</span></div>
<div class="line">newMatrix.assign( matrix.begin(), matrix.end() ); <span class="comment">// deep copy</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Another matrix object of the same type, whose contents are copied. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00192">192</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8ed9a22231910968b86daefd41a39b1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::<a class="el" href="classecuda_1_1matrix.html">matrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. Constructs the container with the contents of the other using move semantics. </p>
<p>This operator is only available if the compiler is configured to allow C++11.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00213">213</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5d92e326a0b1e784e9c431ba8b1eecd7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST void <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a>&#160;</td>
          <td class="paramname"><em>newNumberRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a>&#160;</td>
          <td class="paramname"><em>newNumberColumns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code><a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents of the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newNumberRows</td><td>new number of rows </td></tr>
    <tr><td class="paramname">newNumberColumns</td><td>new number of columns </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize elements of the container with </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00509">509</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac6812a1306edebd818d3c596c0c0c1b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE void <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents of the container with copies of those in the range [begin,end). </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if the number of elements in the range [begin,end) does not match the number of elements in this container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,last</td><td>the range to copy the elements from </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00532">532</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a529dac481c819f8d16afc1b1fcfa1ef2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST void <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents of the container with copies of those in the initializer list. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if the number of elements in the initializer list does not match the number of elements in this container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>initializer list to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00554">554</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae9a287fb563886422b317545f21e4340"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEVICE T&amp; <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a>&#160;</td>
          <td class="paramname"><em>rowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a>&#160;</td>
          <td class="paramname"><em>columnIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at the specified matrix location. </p>
<p>This method in STL containers like vector is differentiated from operator[] because it includes range checking. In this case, no range checking is performed, but if a thread only accesses a single element, this accessor may be slightly faster. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// host code</span></div>
<div class="line"><a class="code" href="classecuda_1_1matrix.html">ecuda::matrix&lt;double&gt;</a> deviceMatrix( 100, 100 );</div>
<div class="line"><span class="comment">// within kernel</span></div>
<div class="line"><span class="keywordtype">double</span>&amp; value = deviceMatrix.at( 10, 10 ); <span class="comment">// slightly faster</span></div>
<div class="line"><span class="keywordtype">double</span>&amp; value = deviceMatrix[10][10]; <span class="comment">// slightly slower</span></div>
</div><!-- fragment --><p>This is due to the operator[] first creating a row view, and then performing an additional access to a column within it. Modern compilers can be pretty crafty at seeing through these these types of situations, and it may resolve to an identical set of instructions, but the direct accessor method is included here for completeness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowIndex</td><td>index of the row to get an element reference from </td></tr>
    <tr><td class="paramname">columnIndex</td><td>index of the column to get an element reference from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the specified element </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00757">757</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4b04bc2f78b1fb46d3448bbde176935a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEVICE const T&amp; <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a>&#160;</td>
          <td class="paramname"><em>rowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a>&#160;</td>
          <td class="paramname"><em>columnIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at the specified matrix location. </p>
<p>This method in STL containers like vector is differentiated from operator[] because it includes range checking. In this case, no range checking is performed, but if a thread only accesses a single element, this accessor may be slightly faster. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// host code</span></div>
<div class="line"><a class="code" href="classecuda_1_1matrix.html">ecuda::matrix&lt;double&gt;</a> deviceMatrix( 100, 100 );</div>
<div class="line"><span class="comment">// within kernel</span></div>
<div class="line"><span class="keywordtype">double</span>&amp; value = deviceMatrix.at( 10, 10 ); <span class="comment">// slightly faster</span></div>
<div class="line"><span class="keywordtype">double</span>&amp; value = deviceMatrix[10][10]; <span class="comment">// slightly slower</span></div>
</div><!-- fragment --><p>This is due to the operator[] first creating a row view, and then performing an additional access to a column within it. Modern compilers can be pretty crafty at seeing through these these types of situations, and it may resolve to an identical set of instructions, but the direct accessor method is included here for completeness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowIndex</td><td>index of the row to get an element reference from </td></tr>
    <tr><td class="paramname">columnIndex</td><td>index of the column to get an element reference from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the specified element </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00785">785</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a96e47d6f4eeea044e4e9766d6baec2b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEVICE <a class="el" href="classecuda_1_1matrix.html#afd6ded4470757fa619873ae792bde260">reference</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the container. </p>
<p>This is effectively the element at position (numberRows-1,numberColumns-1). Calling back on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00463">463</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9fe4e08fc0013c81b9a184ab7c577b11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEVICE <a class="el" href="classecuda_1_1matrix.html#a66893e0729e39b8a851de853f4b9c60f">const_reference</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the container. </p>
<p>This is effectively the element at position (numberRows-1,numberColumns-1). Calling back on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00481">481</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1a6c98eb22a8c57990818eb045dab534"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#a1f79c587aeefa4b60c34a4188b34d850">iterator</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classecuda_1_1matrix.html#af795712961534a0667aa8b8b2e8afdd1" title="Returns an iterator to the element following the last element of the container. ">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00225">225</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5bf0046182fd3997e24fb087c55fcad8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#ab6d1152caca5f9324834f71a57abda45">const_iterator</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classecuda_1_1matrix.html#af795712961534a0667aa8b8b2e8afdd1" title="Returns an iterator to the element following the last element of the container. ">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00243">243</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abb9ac9fd37bf8d0304f07110d59ba40a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#ab6d1152caca5f9324834f71a57abda45">const_iterator</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00293">293</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a39991d6f8e9f8f27848ea5db5626e1a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#ab6d1152caca5f9324834f71a57abda45">const_iterator</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00294">294</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac0685a1bd34187372bf6527c852184ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#ac79611de33047f682840ac376e0ff196">const_reverse_iterator</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00295">295</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab5b01ff1a23591cd33f7fb76ade1575e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#ac79611de33047f682840ac376e0ff196">const_reverse_iterator</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00296">296</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab1cf710d0d9d50358a7820a7765f8fce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#ae557b91e1336743625c2fd4634132672">pointer</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying array serving as element storage. </p>
<p>The pointer is such that range [<a class="el" href="classecuda_1_1matrix.html#ab1cf710d0d9d50358a7820a7765f8fce" title="Returns pointer to the underlying array serving as element storage. ">data()</a>,<a class="el" href="classecuda_1_1matrix.html#ab1cf710d0d9d50358a7820a7765f8fce" title="Returns pointer to the underlying array serving as element storage. ">data()</a>+size()) is always a valid range, even if the container is empty.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00491">491</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac0922b7d2f8aa1c5e4198ef3bb9fd973"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#a74c67ed23295f86d8f3aea74d6cc2e3c">const_pointer</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying array serving as element storage. </p>
<p>The pointer is such that range [<a class="el" href="classecuda_1_1matrix.html#ab1cf710d0d9d50358a7820a7765f8fce" title="Returns pointer to the underlying array serving as element storage. ">data()</a>,<a class="el" href="classecuda_1_1matrix.html#ab1cf710d0d9d50358a7820a7765f8fce" title="Returns pointer to the underlying array serving as element storage. ">data()</a>+size()) is always a valid range, even if the container is empty.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00501">501</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d6a8e8d50cf742b488caccb0a2629e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container has no elements. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the container is empty, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00371">371</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af795712961534a0667aa8b8b2e8afdd1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#a1f79c587aeefa4b60c34a4188b34d850">iterator</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>
<p>The element acts as a placeholder; attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00234">234</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac0856ed91548f60f90dfd8028964c202"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#ab6d1152caca5f9324834f71a57abda45">const_iterator</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>
<p>The element acts as a placeholder; attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00252">252</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1d43f72d362ef12df6d3dfcc0be742cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE void <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a given value to all elements in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to assign to the elements </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00566">566</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ade446c8a8ee5feb45bc792284235fd68"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEVICE <a class="el" href="classecuda_1_1matrix.html#afd6ded4470757fa619873ae792bde260">reference</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the container. </p>
<p>This is effectively the element at position (0,0). Calling front on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00454">454</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa7ad537eb3eada60d1f687d850fe4e9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEVICE <a class="el" href="classecuda_1_1matrix.html#a66893e0729e39b8a851de853f4b9c60f">const_reference</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the container. </p>
<p>This is effectively the element at position (0,0). Calling front on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00472">472</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8a1957fea2d7c2fffca82baac04ad0f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST <a class="el" href="classecuda_1_1matrix.html#ac702fbaec24a5ad06a46171e4765dace">allocator_type</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator associated with the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The associated allocator. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00605">605</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a673e78abb3a630b5b98cb1a58906c9a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#a4c441c91751839576bf074dd053749ee">column_type</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::get_column </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a>&#160;</td>
          <td class="paramname"><em>columnIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a view object of a single column of the matrix. </p>
<p>The view object is guaranteed to perform no memory allocations or deallocation, and merely holds a pointer to the start of the row and provides methods to traverse, access, and alter the underlying data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">columnIndex</td><td>index of the column to isolate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>view object for the specified column </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00408">408</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80c7103d1745e744d42e04952d31e5a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#ad62eb815d09942ed5b5ca0ee3c6e286c">const_column_type</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::get_column </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a>&#160;</td>
          <td class="paramname"><em>columnIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a view object of a single column of the matrix. </p>
<p>The view object is guaranteed to perform no memory allocations or deallocation, and merely holds a pointer to the start of the row and provides methods to traverse and access the underlying data. In addition, the constness of this matrix is enforced so the view will not allow any alterations to the underlying data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">columnIndex</td><td>index of the column to isolate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>view object for the specified column </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00426">426</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a442651b85e74534c2100b43b41fb1fe2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::get_pitch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the pitch of the underlying 2D device memory. </p>
<dl class="section return"><dt>Returns</dt><dd>THe pitch of the underlying 2D device memory (in bytes). </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00333">333</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a92fec8d606dfb1084a92275c78e5159e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#a259a05b61efca61de57617c6e2a4b42b">row_type</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::get_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a>&#160;</td>
          <td class="paramname"><em>rowIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a view object of a single row of the matrix. </p>
<p>The view object is guaranteed to perform no memory allocations or deallocation, and merely holds a pointer to the start of the row and provides methods to traverse, access, and alter the underlying data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowIndex</td><td>of the row to isolate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>view object for the specified row </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00383">383</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a926b29dd74d04690320c98e17190e6bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#a125da39d087f5f7ce853a302aef95b99">const_row_type</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::get_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a>&#160;</td>
          <td class="paramname"><em>rowIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a view object of a single row of the matrix. </p>
<p>The view object is guaranteed to perform no memory allocations or deallocation, and merely holds a pointer to the start of the row and provides methods to traverse and access the underlying data. In addition, the constness of this matrix is enforced so the view will not allow any alterations to the underlying data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowIndex</td><td>of the row to isolate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>view object for the specified row </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00396">396</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a897e4a51a1815834d02090032bfd420b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE __CONSTEXPR__ <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements the container is able to hold due to system or library implementation limitations. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of elements. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00312">312</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a54d63816227c0ab01aed53486fd9932f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::number_columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of columns in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of columns in the container. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00326">326</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a00cd78b7556febca832023c4d6ef3812"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::number_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of rows in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of rows in the container. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00319">319</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a70c78744241d852094401c2d726d53ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the contents of two matrices are not equal. </p>
<p>That is, whether <a class="el" href="classecuda_1_1matrix.html#a00cd78b7556febca832023c4d6ef3812" title="Returns the number of rows in the container. ">number_rows()</a> != other.number_rows(), <a class="el" href="classecuda_1_1matrix.html#a54d63816227c0ab01aed53486fd9932f" title="Returns the number of columns in the container. ">number_columns()</a> != other.number_columns(), or whether any element in the this matrix does not compare equal to the element in the other matrix at the same position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents are not equal, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00651">651</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4b3b2d1f6ea70da095993e8b37d792ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two matrices lexicographically. </p>
<p>The order that elements are compared corresponds to their linearized layout (i.e. each column of the first row is compared, then each column of the next row, and so on...).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of this matrix are lexicographically less than the other matrix, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00663">663</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="affa77e4908a3fed713f834ee26f48007"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST <a class="el" href="classecuda_1_1matrix.html">matrix</a>&amp; <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the contents of another container to this device matrix. </p>
<p>The size of the container must match the number of elements in this matrix (<a class="el" href="classecuda_1_1matrix.html#a00cd78b7556febca832023c4d6ef3812" title="Returns the number of rows in the container. ">number_rows()</a>*number_columns()). The source container is assumed to be in row-major linear form (all columns of the first row, then all columns of the second row, ...).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>container to copy data from </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if number of elements in src does not match the size of this matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00871">871</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac0d4e1c65a3507a10cdcbf2ca3792a05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two matrices lexicographically. </p>
<p>The order that elements are compared corresponds to their linearized layout (i.e. each column of the first row is compared, then each column of the next row, and so on...).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of this matrix are lexicographically less than or equal to the other matrix, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00717">717</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9f2e804bac9e756054cd0560a2696e77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the contents of two matrices are equal. </p>
<p>That is, whether <a class="el" href="classecuda_1_1matrix.html#a00cd78b7556febca832023c4d6ef3812" title="Returns the number of rows in the container. ">number_rows()</a> == other.number_rows(), <a class="el" href="classecuda_1_1matrix.html#a54d63816227c0ab01aed53486fd9932f" title="Returns the number of columns in the container. ">number_columns()</a> == other.number_columns() and each element in the this matrix compares equal to the other matrix at the same position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents are equal, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00617">617</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca45f3dcf01cc1afc120234a092f5eff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two matrices lexicographically. </p>
<p>The order that elements are compared corresponds to their linearized layout (i.e. each column of the first row is compared, then each column of the next row, and so on...).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of this matrix are lexicographically greater than the other matrix, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00690">690</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae7a055d82e32c1fca84cd93fd4e8de09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Alloc2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two matrices lexicographically. </p>
<p>The order that elements are compared corresponds to their linearized layout (i.e. each column of the first row is compared, then each column of the next row, and so on...).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of this matrix are lexicographically greater than or equal to the other matrix, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00729">729</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae3e2ec8c9afa4171008c7f5cabace504"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST Container&amp; <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the contents of this device matrix to another container. </p>
<p>The matrix is converted into a row-major linearized form (all columns of the first row, then all columns of the second row, ...). </p>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00849">849</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac9c315c44a0a5f0a385612add3f4440d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#a259a05b61efca61de57617c6e2a4b42b">row_type</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a>&#160;</td>
          <td class="paramname"><em>rowIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator[](rowIndex) alias for get_row(rowIndex) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowIndex</td><td>index of the row to isolate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>view object for the specified row </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00438">438</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5e8756e9fdfed58a1ffd52482fcff4da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#a125da39d087f5f7ce853a302aef95b99">const_row_type</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a>&#160;</td>
          <td class="paramname"><em>rowIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator[](rowIndex) alias for get_row(rowIndex) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowIndex</td><td>index of the row to isolate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>view object for the specified row </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00445">445</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="add9725d9654c4965e36084a8d903ddbe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#af6569cc486b72a5a234fecdbe16ec122">reverse_iterator</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed container. </p>
<p>It corresponds to the last element of the non-reversed container.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00261">261</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afadcbdedfe526df5497970186b1dd09d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#ac79611de33047f682840ac376e0ff196">const_reverse_iterator</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed container. </p>
<p>It corresponds to the last element of the non-reversed container.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00280">280</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aac3b8fc063697c9f046d024afea8dfe7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#af6569cc486b72a5a234fecdbe16ec122">reverse_iterator</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed container. </p>
<p>It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00271">271</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a26c231293048a18afff7688a890138e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#ac79611de33047f682840ac376e0ff196">const_reverse_iterator</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed container. </p>
<p>It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00290">290</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a96278422bbfb42a3e82798ab6698a5b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST void <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a>&#160;</td>
          <td class="paramname"><em>newNumberRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a>&#160;</td>
          <td class="paramname"><em>newNumberColumns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code><a class="el" href="classecuda_1_1matrix.html#a98ff206805cd70f6b5a70cd6c1997826">value_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to have dimensions newNumberRows x newNumberColumns. </p>
<p>If the current size is greater in either or both dimensions, the existing elements are truncated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newNumberRows</td><td>new number of rows </td></tr>
    <tr><td class="paramname">newNumberColumns</td><td>new number of columns </td></tr>
    <tr><td class="paramname">value</td><td>the value to initialize the new elements with (default constructed if not specified) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00344">344</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae8a01ee901e90891187bb085066a2269"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1matrix.html#aabf61a7885dcb1f6598873e7fff33af4">size_type</a> <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the container (numberRows*numberColumns). </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container. </dd></dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00304">304</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7cc3cc204a820a9d45b7eb4d57bb7af0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Alloc = device_pitch_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE void <a class="el" href="classecuda_1_1matrix.html">ecuda::matrix</a>&lt; T, Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of the container with those of the other. </p>
<p>Does not invoke any move, copy, or swap operations on individual elements. All iterators and references remain valid. The past-the-end iterator is invalidated.</p>
<p>Although this can be called from both the host and device, a call from the device only swaps the contents of the containers in the calling thread only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to exchange the contents with </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00586">586</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/ecuda/<a class="el" href="matrix_8hpp_source.html">matrix.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 13 2015 17:40:41 for Extended CUDA Library (ecuda) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
