<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Extended CUDA Library (ecuda): ecuda::array&lt; T, N &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Extended CUDA Library (ecuda)
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceecuda.html">ecuda</a></li><li class="navelem"><a class="el" href="classecuda_1_1array.html">array</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classecuda_1_1array-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ecuda::array&lt; T, N &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A fixed-size array stored in device memory.  
 <a href="classecuda_1_1array.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="array_8hpp_source.html">array.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6db76ea045aa49863d0d0e16149634d6"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a6db76ea045aa49863d0d0e16149634d6">value_type</a></td></tr>
<tr class="memdesc:a6db76ea045aa49863d0d0e16149634d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell data type  <a href="#a6db76ea045aa49863d0d0e16149634d6">More...</a><br/></td></tr>
<tr class="separator:a6db76ea045aa49863d0d0e16149634d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35afa780d8864e4f952a88a950bc9ed"><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#ab35afa780d8864e4f952a88a950bc9ed">size_type</a></td></tr>
<tr class="memdesc:ab35afa780d8864e4f952a88a950bc9ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned integral type  <a href="#ab35afa780d8864e4f952a88a950bc9ed">More...</a><br/></td></tr>
<tr class="separator:ab35afa780d8864e4f952a88a950bc9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1981ba45c02851d696d277d344d319af"><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a1981ba45c02851d696d277d344d319af">difference_type</a></td></tr>
<tr class="memdesc:a1981ba45c02851d696d277d344d319af"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed integral type  <a href="#a1981ba45c02851d696d277d344d319af">More...</a><br/></td></tr>
<tr class="separator:a1981ba45c02851d696d277d344d319af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3dcd9290fe2c5c5966eddee944b5970"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classecuda_1_1array.html#a6db76ea045aa49863d0d0e16149634d6">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#af3dcd9290fe2c5c5966eddee944b5970">reference</a></td></tr>
<tr class="memdesc:af3dcd9290fe2c5c5966eddee944b5970"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell reference type  <a href="#af3dcd9290fe2c5c5966eddee944b5970">More...</a><br/></td></tr>
<tr class="separator:af3dcd9290fe2c5c5966eddee944b5970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd28c58daf536fd824d2a72d2a0f4d1"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classecuda_1_1array.html#a6db76ea045aa49863d0d0e16149634d6">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a7bd28c58daf536fd824d2a72d2a0f4d1">const_reference</a></td></tr>
<tr class="memdesc:a7bd28c58daf536fd824d2a72d2a0f4d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell const reference type  <a href="#a7bd28c58daf536fd824d2a72d2a0f4d1">More...</a><br/></td></tr>
<tr class="separator:a7bd28c58daf536fd824d2a72d2a0f4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afebc597e05eb6c56edff26bb154d1a22"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classecuda_1_1array.html#a6db76ea045aa49863d0d0e16149634d6">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#afebc597e05eb6c56edff26bb154d1a22">pointer</a></td></tr>
<tr class="memdesc:afebc597e05eb6c56edff26bb154d1a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell pointer type  <a href="#afebc597e05eb6c56edff26bb154d1a22">More...</a><br/></td></tr>
<tr class="separator:afebc597e05eb6c56edff26bb154d1a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f79470e20637354321abde03d3e4ea"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classecuda_1_1array.html#a6db76ea045aa49863d0d0e16149634d6">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#ac6f79470e20637354321abde03d3e4ea">const_pointer</a></td></tr>
<tr class="memdesc:ac6f79470e20637354321abde03d3e4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell const pointer type  <a href="#ac6f79470e20637354321abde03d3e4ea">More...</a><br/></td></tr>
<tr class="separator:ac6f79470e20637354321abde03d3e4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58117673c2e9df18daf047d8b35424b2"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classecuda_1_1contiguous__device__iterator.html">contiguous_device_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1array.html#a6db76ea045aa49863d0d0e16149634d6">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a58117673c2e9df18daf047d8b35424b2">iterator</a></td></tr>
<tr class="memdesc:a58117673c2e9df18daf047d8b35424b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator type  <a href="#a58117673c2e9df18daf047d8b35424b2">More...</a><br/></td></tr>
<tr class="separator:a58117673c2e9df18daf047d8b35424b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39b1e6e57d4ad7cc83f10e8081a57dc"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classecuda_1_1contiguous__device__iterator.html">contiguous_device_iterator</a><br class="typebreak"/>
&lt; const <a class="el" href="classecuda_1_1array.html#a6db76ea045aa49863d0d0e16149634d6">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#ac39b1e6e57d4ad7cc83f10e8081a57dc">const_iterator</a></td></tr>
<tr class="memdesc:ac39b1e6e57d4ad7cc83f10e8081a57dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">const iterator type  <a href="#ac39b1e6e57d4ad7cc83f10e8081a57dc">More...</a><br/></td></tr>
<tr class="separator:ac39b1e6e57d4ad7cc83f10e8081a57dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64666377d45b5dfd74c9a4e75b339276"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classecuda_1_1reverse__device__iterator.html">reverse_device_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1array.html#a58117673c2e9df18daf047d8b35424b2">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a64666377d45b5dfd74c9a4e75b339276">reverse_iterator</a></td></tr>
<tr class="memdesc:a64666377d45b5dfd74c9a4e75b339276"><td class="mdescLeft">&#160;</td><td class="mdescRight">reverse iterator type  <a href="#a64666377d45b5dfd74c9a4e75b339276">More...</a><br/></td></tr>
<tr class="separator:a64666377d45b5dfd74c9a4e75b339276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130a6db9264aa5ddc64185ac1d5586c2"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classecuda_1_1reverse__device__iterator.html">reverse_device_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1array.html#ac39b1e6e57d4ad7cc83f10e8081a57dc">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a130a6db9264aa5ddc64185ac1d5586c2">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a130a6db9264aa5ddc64185ac1d5586c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">const reverse iterator type  <a href="#a130a6db9264aa5ddc64185ac1d5586c2">More...</a><br/></td></tr>
<tr class="separator:a130a6db9264aa5ddc64185ac1d5586c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad81c59b29b2ae9ba3aea18fd416b8f95"><td class="memItemLeft" align="right" valign="top">HOST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#ad81c59b29b2ae9ba3aea18fd416b8f95">array</a> ()</td></tr>
<tr class="memdesc:ad81c59b29b2ae9ba3aea18fd416b8f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a fixed-size array with N elements.  <a href="#ad81c59b29b2ae9ba3aea18fd416b8f95">More...</a><br/></td></tr>
<tr class="separator:ad81c59b29b2ae9ba3aea18fd416b8f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa852eea25814abe5341df7943a08289e"><td class="memItemLeft" align="right" valign="top">HOST DEVICE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#aa852eea25814abe5341df7943a08289e">array</a> (const <a class="el" href="classecuda_1_1array.html">array</a> &amp;src)</td></tr>
<tr class="memdesc:aa852eea25814abe5341df7943a08289e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an array with a shallow copy of each of the elements in src.  <a href="#aa852eea25814abe5341df7943a08289e">More...</a><br/></td></tr>
<tr class="separator:aa852eea25814abe5341df7943a08289e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf974ba26670c303adad4fb900d9a091"><td class="memItemLeft" align="right" valign="top">HOST&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#acf974ba26670c303adad4fb900d9a091">array</a> (<a class="el" href="classecuda_1_1array.html">array</a>&lt; T, N &gt; &amp;&amp;src)</td></tr>
<tr class="memdesc:acf974ba26670c303adad4fb900d9a091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. Constructs the container with the contents of the other using move semantics.  <a href="#acf974ba26670c303adad4fb900d9a091">More...</a><br/></td></tr>
<tr class="separator:acf974ba26670c303adad4fb900d9a091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a6983a0dd6b48ae6c0548c31045c2b"><td class="memItemLeft" align="right" valign="top">DEVICE <a class="el" href="classecuda_1_1array.html#af3dcd9290fe2c5c5966eddee944b5970">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#ac5a6983a0dd6b48ae6c0548c31045c2b">operator[]</a> (<a class="el" href="classecuda_1_1array.html#ab35afa780d8864e4f952a88a950bc9ed">size_type</a> index)</td></tr>
<tr class="memdesc:ac5a6983a0dd6b48ae6c0548c31045c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index. No bounds checking is performed.  <a href="#ac5a6983a0dd6b48ae6c0548c31045c2b">More...</a><br/></td></tr>
<tr class="separator:ac5a6983a0dd6b48ae6c0548c31045c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a3dfd67719a6253941d84bb2e2f7f1"><td class="memItemLeft" align="right" valign="top">DEVICE <a class="el" href="classecuda_1_1array.html#a7bd28c58daf536fd824d2a72d2a0f4d1">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#ae7a3dfd67719a6253941d84bb2e2f7f1">operator[]</a> (<a class="el" href="classecuda_1_1array.html#ab35afa780d8864e4f952a88a950bc9ed">size_type</a> index) const </td></tr>
<tr class="memdesc:ae7a3dfd67719a6253941d84bb2e2f7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index. No bounds checking is performed.  <a href="#ae7a3dfd67719a6253941d84bb2e2f7f1">More...</a><br/></td></tr>
<tr class="separator:ae7a3dfd67719a6253941d84bb2e2f7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8b8626f99c8ed38c1871affbc1b6ba"><td class="memItemLeft" align="right" valign="top">DEVICE <a class="el" href="classecuda_1_1array.html#af3dcd9290fe2c5c5966eddee944b5970">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a0c8b8626f99c8ed38c1871affbc1b6ba">front</a> ()</td></tr>
<tr class="memdesc:a0c8b8626f99c8ed38c1871affbc1b6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container.  <a href="#a0c8b8626f99c8ed38c1871affbc1b6ba">More...</a><br/></td></tr>
<tr class="separator:a0c8b8626f99c8ed38c1871affbc1b6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade46a3e33eca2b003694dd1adbcdddd6"><td class="memItemLeft" align="right" valign="top">DEVICE <a class="el" href="classecuda_1_1array.html#af3dcd9290fe2c5c5966eddee944b5970">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#ade46a3e33eca2b003694dd1adbcdddd6">back</a> ()</td></tr>
<tr class="memdesc:ade46a3e33eca2b003694dd1adbcdddd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container.  <a href="#ade46a3e33eca2b003694dd1adbcdddd6">More...</a><br/></td></tr>
<tr class="separator:ade46a3e33eca2b003694dd1adbcdddd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35fb88c97c1b0ddd1da52f3ec4ff3c81"><td class="memItemLeft" align="right" valign="top">DEVICE <a class="el" href="classecuda_1_1array.html#a7bd28c58daf536fd824d2a72d2a0f4d1">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a35fb88c97c1b0ddd1da52f3ec4ff3c81">front</a> () const </td></tr>
<tr class="memdesc:a35fb88c97c1b0ddd1da52f3ec4ff3c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container.  <a href="#a35fb88c97c1b0ddd1da52f3ec4ff3c81">More...</a><br/></td></tr>
<tr class="separator:a35fb88c97c1b0ddd1da52f3ec4ff3c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a370d3e26cdb106d3380ffb3ebca03"><td class="memItemLeft" align="right" valign="top">DEVICE <a class="el" href="classecuda_1_1array.html#a7bd28c58daf536fd824d2a72d2a0f4d1">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a58a370d3e26cdb106d3380ffb3ebca03">back</a> () const </td></tr>
<tr class="memdesc:a58a370d3e26cdb106d3380ffb3ebca03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container.  <a href="#a58a370d3e26cdb106d3380ffb3ebca03">More...</a><br/></td></tr>
<tr class="separator:a58a370d3e26cdb106d3380ffb3ebca03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d9bbd5d11bd95fc2063a6f673bad6c"><td class="memItemLeft" align="right" valign="top">HOST DEVICE __CONSTEXPR__ bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a60d9bbd5d11bd95fc2063a6f673bad6c">empty</a> () const </td></tr>
<tr class="memdesc:a60d9bbd5d11bd95fc2063a6f673bad6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container has no elements.  <a href="#a60d9bbd5d11bd95fc2063a6f673bad6c">More...</a><br/></td></tr>
<tr class="separator:a60d9bbd5d11bd95fc2063a6f673bad6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f5aa87cb3ea123fbe286d3cac1bea2"><td class="memItemLeft" align="right" valign="top">HOST DEVICE __CONSTEXPR__ <a class="el" href="classecuda_1_1array.html#ab35afa780d8864e4f952a88a950bc9ed">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a91f5aa87cb3ea123fbe286d3cac1bea2">size</a> () const </td></tr>
<tr class="memdesc:a91f5aa87cb3ea123fbe286d3cac1bea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container.  <a href="#a91f5aa87cb3ea123fbe286d3cac1bea2">More...</a><br/></td></tr>
<tr class="separator:a91f5aa87cb3ea123fbe286d3cac1bea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10f34d5d4945624a16a22e388caa864"><td class="memItemLeft" align="right" valign="top">HOST __CONSTEXPR__ <a class="el" href="classecuda_1_1array.html#ab35afa780d8864e4f952a88a950bc9ed">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#ab10f34d5d4945624a16a22e388caa864">max_size</a> () const </td></tr>
<tr class="memdesc:ab10f34d5d4945624a16a22e388caa864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the container is able to hold due to system or library implementation limitations.  <a href="#ab10f34d5d4945624a16a22e388caa864">More...</a><br/></td></tr>
<tr class="separator:ab10f34d5d4945624a16a22e388caa864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09ec2a4e6d979ffc27e610c28d07536"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1array.html#afebc597e05eb6c56edff26bb154d1a22">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#ae09ec2a4e6d979ffc27e610c28d07536">data</a> ()</td></tr>
<tr class="memdesc:ae09ec2a4e6d979ffc27e610c28d07536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage.  <a href="#ae09ec2a4e6d979ffc27e610c28d07536">More...</a><br/></td></tr>
<tr class="separator:ae09ec2a4e6d979ffc27e610c28d07536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0828ef5a813f436d12e3fb77dbbf0f37"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1array.html#ac6f79470e20637354321abde03d3e4ea">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a0828ef5a813f436d12e3fb77dbbf0f37">data</a> () const </td></tr>
<tr class="memdesc:a0828ef5a813f436d12e3fb77dbbf0f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage.  <a href="#a0828ef5a813f436d12e3fb77dbbf0f37">More...</a><br/></td></tr>
<tr class="separator:a0828ef5a813f436d12e3fb77dbbf0f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04ae9b4e0f193f783e039ee318293e0"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1array.html#a58117673c2e9df18daf047d8b35424b2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#af04ae9b4e0f193f783e039ee318293e0">begin</a> ()</td></tr>
<tr class="memdesc:af04ae9b4e0f193f783e039ee318293e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="#af04ae9b4e0f193f783e039ee318293e0">More...</a><br/></td></tr>
<tr class="separator:af04ae9b4e0f193f783e039ee318293e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c8f9290ec692d7b7a305967bfb6228"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1array.html#a58117673c2e9df18daf047d8b35424b2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a58c8f9290ec692d7b7a305967bfb6228">end</a> ()</td></tr>
<tr class="memdesc:a58c8f9290ec692d7b7a305967bfb6228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="#a58c8f9290ec692d7b7a305967bfb6228">More...</a><br/></td></tr>
<tr class="separator:a58c8f9290ec692d7b7a305967bfb6228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3ce779ecf16ad422540762214c9faf"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1array.html#ac39b1e6e57d4ad7cc83f10e8081a57dc">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a0d3ce779ecf16ad422540762214c9faf">begin</a> () const </td></tr>
<tr class="memdesc:a0d3ce779ecf16ad422540762214c9faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="#a0d3ce779ecf16ad422540762214c9faf">More...</a><br/></td></tr>
<tr class="separator:a0d3ce779ecf16ad422540762214c9faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dcfba2bdd5513d2833e147a9431d06f"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1array.html#ac39b1e6e57d4ad7cc83f10e8081a57dc">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a3dcfba2bdd5513d2833e147a9431d06f">end</a> () const </td></tr>
<tr class="memdesc:a3dcfba2bdd5513d2833e147a9431d06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="#a3dcfba2bdd5513d2833e147a9431d06f">More...</a><br/></td></tr>
<tr class="separator:a3dcfba2bdd5513d2833e147a9431d06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fc54843c78abf3db1233c9cbb35e3c"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1array.html#a64666377d45b5dfd74c9a4e75b339276">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a99fc54843c78abf3db1233c9cbb35e3c">rbegin</a> ()</td></tr>
<tr class="memdesc:a99fc54843c78abf3db1233c9cbb35e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed container.  <a href="#a99fc54843c78abf3db1233c9cbb35e3c">More...</a><br/></td></tr>
<tr class="separator:a99fc54843c78abf3db1233c9cbb35e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62992d91e185230205a6a342c58476e2"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1array.html#a64666377d45b5dfd74c9a4e75b339276">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a62992d91e185230205a6a342c58476e2">rend</a> ()</td></tr>
<tr class="memdesc:a62992d91e185230205a6a342c58476e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed container.  <a href="#a62992d91e185230205a6a342c58476e2">More...</a><br/></td></tr>
<tr class="separator:a62992d91e185230205a6a342c58476e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dae27e67b1105e366e4b44cf341252b"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1array.html#a130a6db9264aa5ddc64185ac1d5586c2">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a8dae27e67b1105e366e4b44cf341252b">rbegin</a> () const </td></tr>
<tr class="memdesc:a8dae27e67b1105e366e4b44cf341252b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed container.  <a href="#a8dae27e67b1105e366e4b44cf341252b">More...</a><br/></td></tr>
<tr class="separator:a8dae27e67b1105e366e4b44cf341252b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af190f6349fc64b3f47ded9d6222a12d8"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1array.html#a130a6db9264aa5ddc64185ac1d5586c2">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#af190f6349fc64b3f47ded9d6222a12d8">rend</a> () const </td></tr>
<tr class="memdesc:af190f6349fc64b3f47ded9d6222a12d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed container.  <a href="#af190f6349fc64b3f47ded9d6222a12d8">More...</a><br/></td></tr>
<tr class="separator:af190f6349fc64b3f47ded9d6222a12d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53ec06a59efd88329bef6dc97f0779e"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1array.html#ac39b1e6e57d4ad7cc83f10e8081a57dc">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#ad53ec06a59efd88329bef6dc97f0779e">cbegin</a> () const __NOEXCEPT__</td></tr>
<tr class="separator:ad53ec06a59efd88329bef6dc97f0779e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3461242555e3a5399f6c5829bf0a0ec"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1array.html#ac39b1e6e57d4ad7cc83f10e8081a57dc">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#ab3461242555e3a5399f6c5829bf0a0ec">cend</a> () const __NOEXCEPT__</td></tr>
<tr class="separator:ab3461242555e3a5399f6c5829bf0a0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1614f02307675274ddb2b63952529875"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1array.html#a130a6db9264aa5ddc64185ac1d5586c2">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a1614f02307675274ddb2b63952529875">crbegin</a> () __NOEXCEPT__</td></tr>
<tr class="separator:a1614f02307675274ddb2b63952529875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26898a7a6289eae081201b054e26bee1"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1array.html#a130a6db9264aa5ddc64185ac1d5586c2">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a26898a7a6289eae081201b054e26bee1">crend</a> () __NOEXCEPT__</td></tr>
<tr class="separator:a26898a7a6289eae081201b054e26bee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce14930b529dd0639d388b0317cee6b"><td class="memItemLeft" align="right" valign="top">HOST DEVICE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a8ce14930b529dd0639d388b0317cee6b">fill</a> (const <a class="el" href="classecuda_1_1array.html#a6db76ea045aa49863d0d0e16149634d6">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a8ce14930b529dd0639d388b0317cee6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a given value to all elements in the container.  <a href="#a8ce14930b529dd0639d388b0317cee6b">More...</a><br/></td></tr>
<tr class="separator:a8ce14930b529dd0639d388b0317cee6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66faaabf036959cc2e809bdf834dad9"><td class="memItemLeft" align="right" valign="top">HOST DEVICE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#aa66faaabf036959cc2e809bdf834dad9">swap</a> (<a class="el" href="classecuda_1_1array.html">array</a> &amp;other)</td></tr>
<tr class="memdesc:aa66faaabf036959cc2e809bdf834dad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the container with those of the other.  <a href="#aa66faaabf036959cc2e809bdf834dad9">More...</a><br/></td></tr>
<tr class="separator:aa66faaabf036959cc2e809bdf834dad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729156c847f51ca1ea119985f96dedcc"><td class="memItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a729156c847f51ca1ea119985f96dedcc">operator==</a> (const <a class="el" href="classecuda_1_1array.html">array</a>&lt; T, N &gt; &amp;other) const </td></tr>
<tr class="memdesc:a729156c847f51ca1ea119985f96dedcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of two arrays are equal.  <a href="#a729156c847f51ca1ea119985f96dedcc">More...</a><br/></td></tr>
<tr class="separator:a729156c847f51ca1ea119985f96dedcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a53bfef9db0b60c830fb6c88aad9517"><td class="memItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a9a53bfef9db0b60c830fb6c88aad9517">operator!=</a> (const <a class="el" href="classecuda_1_1array.html">array</a>&lt; T, N &gt; &amp;other) const </td></tr>
<tr class="memdesc:a9a53bfef9db0b60c830fb6c88aad9517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of two arrays are not equal.  <a href="#a9a53bfef9db0b60c830fb6c88aad9517">More...</a><br/></td></tr>
<tr class="separator:a9a53bfef9db0b60c830fb6c88aad9517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15591137e0374bb42d9eb2ebe6a3addc"><td class="memItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a15591137e0374bb42d9eb2ebe6a3addc">operator&lt;</a> (const <a class="el" href="classecuda_1_1array.html">array</a>&lt; T, N &gt; &amp;other) const </td></tr>
<tr class="memdesc:a15591137e0374bb42d9eb2ebe6a3addc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two arrays lexicographically.  <a href="#a15591137e0374bb42d9eb2ebe6a3addc">More...</a><br/></td></tr>
<tr class="separator:a15591137e0374bb42d9eb2ebe6a3addc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ec412f14af5044d5ea4f53e6619809"><td class="memItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a32ec412f14af5044d5ea4f53e6619809">operator&gt;</a> (const <a class="el" href="classecuda_1_1array.html">array</a>&lt; T, N &gt; &amp;other) const </td></tr>
<tr class="memdesc:a32ec412f14af5044d5ea4f53e6619809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two arrays lexicographically.  <a href="#a32ec412f14af5044d5ea4f53e6619809">More...</a><br/></td></tr>
<tr class="separator:a32ec412f14af5044d5ea4f53e6619809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a149a6e3211c4a5867fe719f7f4a14b"><td class="memItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a6a149a6e3211c4a5867fe719f7f4a14b">operator&lt;=</a> (const <a class="el" href="classecuda_1_1array.html">array</a>&lt; T, N &gt; &amp;other) const </td></tr>
<tr class="memdesc:a6a149a6e3211c4a5867fe719f7f4a14b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two arrays lexicographically.  <a href="#a6a149a6e3211c4a5867fe719f7f4a14b">More...</a><br/></td></tr>
<tr class="separator:a6a149a6e3211c4a5867fe719f7f4a14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fea7d7e9e9fc4686a9b20d8773369e0"><td class="memItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a8fea7d7e9e9fc4686a9b20d8773369e0">operator&gt;=</a> (const <a class="el" href="classecuda_1_1array.html">array</a>&lt; T, N &gt; &amp;other) const </td></tr>
<tr class="memdesc:a8fea7d7e9e9fc4686a9b20d8773369e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two arrays lexicographically.  <a href="#a8fea7d7e9e9fc4686a9b20d8773369e0">More...</a><br/></td></tr>
<tr class="separator:a8fea7d7e9e9fc4686a9b20d8773369e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b89ecb277f3208fd2769a88f76f479"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:ae5b89ecb277f3208fd2769a88f76f479"><td class="memTemplItemLeft" align="right" valign="top">HOST Container &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#ae5b89ecb277f3208fd2769a88f76f479">operator&gt;&gt;</a> (Container &amp;dest) const </td></tr>
<tr class="memdesc:ae5b89ecb277f3208fd2769a88f76f479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the contents of this device array to another container.  <a href="#ae5b89ecb277f3208fd2769a88f76f479">More...</a><br/></td></tr>
<tr class="separator:ae5b89ecb277f3208fd2769a88f76f479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fd69baa0a9e73a87fb24b8e21fe9ad"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a40fd69baa0a9e73a87fb24b8e21fe9ad"><td class="memTemplItemLeft" align="right" valign="top">HOST <a class="el" href="classecuda_1_1array.html">array</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a40fd69baa0a9e73a87fb24b8e21fe9ad">operator&lt;&lt;</a> (const Container &amp;src)</td></tr>
<tr class="memdesc:a40fd69baa0a9e73a87fb24b8e21fe9ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the contents of a container to this device array.  <a href="#a40fd69baa0a9e73a87fb24b8e21fe9ad">More...</a><br/></td></tr>
<tr class="separator:a40fd69baa0a9e73a87fb24b8e21fe9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, std::size_t N&gt;<br/>
class ecuda::array&lt; T, N &gt;</h3>

<p>A fixed-size array stored in device memory. </p>
<p>Creates a fixed size array in GPU memory. Redeclares most of the STL methods on the equivalent C++11 std::array (although this implementation works with C98 compilers).</p>
<p>Methods are prefaced with appropriate keywords to declare them as host and/or device capable. In general: operations requiring memory allocation/deallocation are host only, operations to access the values of specific elements are device only, and copy operations on ranges of data and accessors of general information can be performed on both the host and device. </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00072">72</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ac39b1e6e57d4ad7cc83f10e8081a57dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1contiguous__device__iterator.html">contiguous_device_iterator</a>&lt;const <a class="el" href="classecuda_1_1array.html#a6db76ea045aa49863d0d0e16149634d6">value_type</a>&gt; <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::<a class="el" href="classecuda_1_1array.html#ac39b1e6e57d4ad7cc83f10e8081a57dc">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const iterator type </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00084">84</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac6f79470e20637354321abde03d3e4ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classecuda_1_1array.html#a6db76ea045aa49863d0d0e16149634d6">value_type</a>* <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::<a class="el" href="classecuda_1_1array.html#ac6f79470e20637354321abde03d3e4ea">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell const pointer type </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00081">81</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7bd28c58daf536fd824d2a72d2a0f4d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classecuda_1_1array.html#a6db76ea045aa49863d0d0e16149634d6">value_type</a>&amp; <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::<a class="el" href="classecuda_1_1array.html#a7bd28c58daf536fd824d2a72d2a0f4d1">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell const reference type </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00079">79</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a130a6db9264aa5ddc64185ac1d5586c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1reverse__device__iterator.html">reverse_device_iterator</a>&lt;<a class="el" href="classecuda_1_1array.html#ac39b1e6e57d4ad7cc83f10e8081a57dc">const_iterator</a>&gt; <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::<a class="el" href="classecuda_1_1array.html#a130a6db9264aa5ddc64185ac1d5586c2">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const reverse iterator type </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00086">86</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1981ba45c02851d696d277d344d319af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::ptrdiff_t <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::<a class="el" href="classecuda_1_1array.html#a1981ba45c02851d696d277d344d319af">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>signed integral type </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00077">77</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a58117673c2e9df18daf047d8b35424b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1contiguous__device__iterator.html">contiguous_device_iterator</a>&lt;<a class="el" href="classecuda_1_1array.html#a6db76ea045aa49863d0d0e16149634d6">value_type</a>&gt; <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::<a class="el" href="classecuda_1_1array.html#a58117673c2e9df18daf047d8b35424b2">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iterator type </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00083">83</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afebc597e05eb6c56edff26bb154d1a22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1array.html#a6db76ea045aa49863d0d0e16149634d6">value_type</a>* <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::<a class="el" href="classecuda_1_1array.html#afebc597e05eb6c56edff26bb154d1a22">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell pointer type </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00080">80</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af3dcd9290fe2c5c5966eddee944b5970"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1array.html#a6db76ea045aa49863d0d0e16149634d6">value_type</a>&amp; <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::<a class="el" href="classecuda_1_1array.html#af3dcd9290fe2c5c5966eddee944b5970">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell reference type </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00078">78</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a64666377d45b5dfd74c9a4e75b339276"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classecuda_1_1reverse__device__iterator.html">reverse_device_iterator</a>&lt;<a class="el" href="classecuda_1_1array.html#a58117673c2e9df18daf047d8b35424b2">iterator</a>&gt; <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::<a class="el" href="classecuda_1_1array.html#a64666377d45b5dfd74c9a4e75b339276">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reverse iterator type </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00085">85</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab35afa780d8864e4f952a88a950bc9ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::<a class="el" href="classecuda_1_1array.html#ab35afa780d8864e4f952a88a950bc9ed">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unsigned integral type </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00076">76</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6db76ea045aa49863d0d0e16149634d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::<a class="el" href="classecuda_1_1array.html#a6db76ea045aa49863d0d0e16149634d6">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell data type </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00075">75</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad81c59b29b2ae9ba3aea18fd416b8f95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::<a class="el" href="classecuda_1_1array.html">array</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a fixed-size array with N elements. </p>
<p>Each element is a default-initialized value of T. </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00097">97</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa852eea25814abe5341df7943a08289e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::<a class="el" href="classecuda_1_1array.html">array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an array with a shallow copy of each of the elements in src. </p>
<p>Be careful to note that a shallow copy means that only the pointer to the device memory that holds the elements is copied in the newly constructed container. This allows containers to be passed-by-value to kernel functions with minimal overhead. If a copy of the container is required in host code, use the &lt;&lt; or &gt;&gt; operators. For example:</p>
<div class="fragment"><div class="line"><a class="code" href="classecuda_1_1array.html">ecuda::array&lt;int,10&gt;</a> arr;</div>
<div class="line">arr.<a class="code" href="classecuda_1_1array.html#a8ce14930b529dd0639d388b0317cee6b">fill</a>( 3 ); <span class="comment">// fill array with 3s</span></div>
<div class="line"><a class="code" href="classecuda_1_1array.html">ecuda::array&lt;int,10&gt;</a> newArr( arr ); <span class="comment">// shallow copy</span></div>
<div class="line"><a class="code" href="classecuda_1_1array.html">ecuda::array&lt;int,10&gt;</a> newArr;</div>
<div class="line">newArr &lt;&lt; arr; <span class="comment">// deep copy</span></div>
<div class="line">arr &gt;&gt; newArr; <span class="comment">// deep copy</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Another array object of the same type and size, whose contents are copied. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00121">121</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acf974ba26670c303adad4fb900d9a091"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::<a class="el" href="classecuda_1_1array.html">array</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1array.html">array</a>&lt; T, N &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. Constructs the container with the contents of the other using move semantics. </p>
<p>This constructor is only available if the compiler is configured to allow C++11.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>another container to be used as source to initialize the elements of the container with </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00149">149</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ade46a3e33eca2b003694dd1adbcdddd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEVICE <a class="el" href="classecuda_1_1array.html#af3dcd9290fe2c5c5966eddee944b5970">reference</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the container. </p>
<p>Calling back on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00191">191</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a58a370d3e26cdb106d3380ffb3ebca03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEVICE <a class="el" href="classecuda_1_1array.html#a7bd28c58daf536fd824d2a72d2a0f4d1">const_reference</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the container. </p>
<p>Calling back on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00208">208</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af04ae9b4e0f193f783e039ee318293e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1array.html#a58117673c2e9df18daf047d8b35424b2">iterator</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classecuda_1_1array.html#a58c8f9290ec692d7b7a305967bfb6228" title="Returns an iterator to the element following the last element of the container. ">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00259">259</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0d3ce779ecf16ad422540762214c9faf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1array.html#ac39b1e6e57d4ad7cc83f10e8081a57dc">const_iterator</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classecuda_1_1array.html#a58c8f9290ec692d7b7a305967bfb6228" title="Returns an iterator to the element following the last element of the container. ">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00276">276</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad53ec06a59efd88329bef6dc97f0779e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1array.html#ac39b1e6e57d4ad7cc83f10e8081a57dc">const_iterator</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00326">326</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab3461242555e3a5399f6c5829bf0a0ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1array.html#ac39b1e6e57d4ad7cc83f10e8081a57dc">const_iterator</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00327">327</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1614f02307675274ddb2b63952529875"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1array.html#a130a6db9264aa5ddc64185ac1d5586c2">const_reverse_iterator</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00328">328</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a26898a7a6289eae081201b054e26bee1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1array.html#a130a6db9264aa5ddc64185ac1d5586c2">const_reverse_iterator</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00329">329</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae09ec2a4e6d979ffc27e610c28d07536"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1array.html#afebc597e05eb6c56edff26bb154d1a22">pointer</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying array serving as element storage. </p>
<p>The pointer is such that range [<a class="el" href="classecuda_1_1array.html#ae09ec2a4e6d979ffc27e610c28d07536" title="Returns pointer to the underlying array serving as element storage. ">data()</a>; <a class="el" href="classecuda_1_1array.html#ae09ec2a4e6d979ffc27e610c28d07536" title="Returns pointer to the underlying array serving as element storage. ">data()</a>+size()) is always a valid range, even if the container is empty.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00240">240</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0828ef5a813f436d12e3fb77dbbf0f37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1array.html#ac6f79470e20637354321abde03d3e4ea">const_pointer</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying array serving as element storage. </p>
<p>The pointer is such that range [<a class="el" href="classecuda_1_1array.html#ae09ec2a4e6d979ffc27e610c28d07536" title="Returns pointer to the underlying array serving as element storage. ">data()</a>; <a class="el" href="classecuda_1_1array.html#ae09ec2a4e6d979ffc27e610c28d07536" title="Returns pointer to the underlying array serving as element storage. ">data()</a>+size()) is always a valid range, even if the container is empty.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00250">250</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a60d9bbd5d11bd95fc2063a6f673bad6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE __CONSTEXPR__ bool <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container has no elements. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the container is empty, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00215">215</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a58c8f9290ec692d7b7a305967bfb6228"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1array.html#a58117673c2e9df18daf047d8b35424b2">iterator</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>
<p>The element acts as a placeholder; attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00268">268</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3dcfba2bdd5513d2833e147a9431d06f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1array.html#ac39b1e6e57d4ad7cc83f10e8081a57dc">const_iterator</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>
<p>The element acts as a placeholder; attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00285">285</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8ce14930b529dd0639d388b0317cee6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE void <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1array.html#a6db76ea045aa49863d0d0e16149634d6">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a given value to all elements in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to assign to the elements </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00337">337</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0c8b8626f99c8ed38c1871affbc1b6ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEVICE <a class="el" href="classecuda_1_1array.html#af3dcd9290fe2c5c5966eddee944b5970">reference</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the container. </p>
<p>Calling front on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00182">182</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a35fb88c97c1b0ddd1da52f3ec4ff3c81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEVICE <a class="el" href="classecuda_1_1array.html#a7bd28c58daf536fd824d2a72d2a0f4d1">const_reference</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the container. </p>
<p>Calling front on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00199">199</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab10f34d5d4945624a16a22e388caa864"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST __CONSTEXPR__ <a class="el" href="classecuda_1_1array.html#ab35afa780d8864e4f952a88a950bc9ed">size_type</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements the container is able to hold due to system or library implementation limitations. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of elements. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00230">230</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9a53bfef9db0b60c830fb6c88aad9517"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the contents of two arrays are not equal. </p>
<p>That is, whether any element in the this array does not compare equal with the element in another array at the same position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents are not equal, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00403">403</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a15591137e0374bb42d9eb2ebe6a3addc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two arrays lexicographically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of this array are lexicographically less than the other array, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00411">411</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a40fd69baa0a9e73a87fb24b8e21fe9ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST <a class="el" href="classecuda_1_1array.html">array</a>&amp; <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the contents of a container to this device array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>container to copy the contents from </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>thrown if this array is not large enough to hold the given vector's contents </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00481">481</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6a149a6e3211c4a5867fe719f7f4a14b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two arrays lexicographically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of this array are lexicographically less than or equal to the other array, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00453">453</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a729156c847f51ca1ea119985f96dedcc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the contents of two arrays are equal. </p>
<p>That is, whether each element in the this array compares equal with the element in another array at the same position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents are equal, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00376">376</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a32ec412f14af5044d5ea4f53e6619809"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two arrays lexicographically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of this array are lexicographically greater than the other array, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00432">432</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8fea7d7e9e9fc4686a9b20d8773369e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two arrays lexicographically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of this array are lexicographically greater than or equal to the other array, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00461">461</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae5b89ecb277f3208fd2769a88f76f479"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST Container&amp; <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the contents of this device array to another container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>container to copy contents to </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00469">469</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac5a6983a0dd6b48ae6c0548c31045c2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEVICE <a class="el" href="classecuda_1_1array.html#af3dcd9290fe2c5c5966eddee944b5970">reference</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1array.html#ab35afa780d8864e4f952a88a950bc9ed">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location index. No bounds checking is performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>position of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00165">165</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae7a3dfd67719a6253941d84bb2e2f7f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEVICE <a class="el" href="classecuda_1_1array.html#a7bd28c58daf536fd824d2a72d2a0f4d1">const_reference</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1array.html#ab35afa780d8864e4f952a88a950bc9ed">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location index. No bounds checking is performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>position of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00173">173</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a99fc54843c78abf3db1233c9cbb35e3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1array.html#a64666377d45b5dfd74c9a4e75b339276">reverse_iterator</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed container. </p>
<p>It corresponds to the last element of the non-reversed container.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00294">294</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8dae27e67b1105e366e4b44cf341252b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1array.html#a130a6db9264aa5ddc64185ac1d5586c2">const_reverse_iterator</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed container. </p>
<p>It corresponds to the last element of the non-reversed container.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00313">313</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a62992d91e185230205a6a342c58476e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1array.html#a64666377d45b5dfd74c9a4e75b339276">reverse_iterator</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed container. </p>
<p>It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00304">304</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af190f6349fc64b3f47ded9d6222a12d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1array.html#a130a6db9264aa5ddc64185ac1d5586c2">const_reverse_iterator</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed container. </p>
<p>It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00323">323</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a91f5aa87cb3ea123fbe286d3cac1bea2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE __CONSTEXPR__ <a class="el" href="classecuda_1_1array.html#ab35afa780d8864e4f952a88a950bc9ed">size_type</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00222">222</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa66faaabf036959cc2e809bdf834dad9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE void <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of the container with those of the other. </p>
<p>Does not cause iterators and references to associate with the other container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to exchange the contents with </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00353">353</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/ecuda/<a class="el" href="array_8hpp_source.html">array.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 13 2015 13:56:44 for Extended CUDA Library (ecuda) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
