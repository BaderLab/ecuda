<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Extended CUDA Library (ecuda): ecuda::array&lt; T, N, P &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Extended CUDA Library (ecuda)
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceecuda.html">ecuda</a></li><li class="navelem"><a class="el" href="classecuda_1_1array.html">array</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classecuda_1_1array-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ecuda::array&lt; T, N, P &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A fixed-size array stored in device memory.  
 <a href="classecuda_1_1array.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="array_8hpp_source.html">array.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ecuda::array&lt; T, N, P &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classecuda_1_1array.png" usemap="#ecuda::array&lt; T, N, P &gt;_map" alt=""/>
  <map id="ecuda::array&lt; T, N, P &gt;_map" name="ecuda::array&lt; T, N, P &gt;_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:adf0f56127a85f4d18f1149ac7947269e"><td class="memItemLeft" align="right" valign="top">typedef base_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#adf0f56127a85f4d18f1149ac7947269e">value_type</a></td></tr>
<tr class="memdesc:adf0f56127a85f4d18f1149ac7947269e"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell data type  <a href="#adf0f56127a85f4d18f1149ac7947269e">More...</a><br/></td></tr>
<tr class="separator:adf0f56127a85f4d18f1149ac7947269e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d033e0224780208a9c9fb058dac896"><td class="memItemLeft" align="right" valign="top">typedef base_type::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a28d033e0224780208a9c9fb058dac896">size_type</a></td></tr>
<tr class="memdesc:a28d033e0224780208a9c9fb058dac896"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned integral type  <a href="#a28d033e0224780208a9c9fb058dac896">More...</a><br/></td></tr>
<tr class="separator:a28d033e0224780208a9c9fb058dac896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99789e4a05c47a1dae47ea902308bc2"><td class="memItemLeft" align="right" valign="top">typedef base_type::difference_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#ac99789e4a05c47a1dae47ea902308bc2">difference_type</a></td></tr>
<tr class="memdesc:ac99789e4a05c47a1dae47ea902308bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed integral type  <a href="#ac99789e4a05c47a1dae47ea902308bc2">More...</a><br/></td></tr>
<tr class="separator:ac99789e4a05c47a1dae47ea902308bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022ab88abce89947041699f5b8fe2743"><td class="memItemLeft" align="right" valign="top">typedef base_type::reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a022ab88abce89947041699f5b8fe2743">reference</a></td></tr>
<tr class="memdesc:a022ab88abce89947041699f5b8fe2743"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell reference type  <a href="#a022ab88abce89947041699f5b8fe2743">More...</a><br/></td></tr>
<tr class="separator:a022ab88abce89947041699f5b8fe2743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5f7be3f86f17de0cfaf4c2bd5197dd"><td class="memItemLeft" align="right" valign="top">typedef base_type::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a2f5f7be3f86f17de0cfaf4c2bd5197dd">const_reference</a></td></tr>
<tr class="memdesc:a2f5f7be3f86f17de0cfaf4c2bd5197dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell const reference type  <a href="#a2f5f7be3f86f17de0cfaf4c2bd5197dd">More...</a><br/></td></tr>
<tr class="separator:a2f5f7be3f86f17de0cfaf4c2bd5197dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427a54dfd16aa5755ec918ac2bbd45b9"><td class="memItemLeft" align="right" valign="top">typedef base_type::pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a427a54dfd16aa5755ec918ac2bbd45b9">pointer</a></td></tr>
<tr class="memdesc:a427a54dfd16aa5755ec918ac2bbd45b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell pointer type  <a href="#a427a54dfd16aa5755ec918ac2bbd45b9">More...</a><br/></td></tr>
<tr class="separator:a427a54dfd16aa5755ec918ac2bbd45b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae02af9bf30163da81b98f314e4e8b1"><td class="memItemLeft" align="right" valign="top">typedef make_const&lt; <a class="el" href="classecuda_1_1array.html#a427a54dfd16aa5755ec918ac2bbd45b9">pointer</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#acae02af9bf30163da81b98f314e4e8b1">const_pointer</a></td></tr>
<tr class="memdesc:acae02af9bf30163da81b98f314e4e8b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">cell const pointer type  <a href="#acae02af9bf30163da81b98f314e4e8b1">More...</a><br/></td></tr>
<tr class="separator:acae02af9bf30163da81b98f314e4e8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d1327715d3fa58ec77480fb523283a"><td class="memItemLeft" align="right" valign="top">typedef base_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#aa2d1327715d3fa58ec77480fb523283a">iterator</a></td></tr>
<tr class="memdesc:aa2d1327715d3fa58ec77480fb523283a"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator type  <a href="#aa2d1327715d3fa58ec77480fb523283a">More...</a><br/></td></tr>
<tr class="separator:aa2d1327715d3fa58ec77480fb523283a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cfc1f0c2f501e6c1b80923924164f7"><td class="memItemLeft" align="right" valign="top">typedef base_type::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#aa3cfc1f0c2f501e6c1b80923924164f7">const_iterator</a></td></tr>
<tr class="memdesc:aa3cfc1f0c2f501e6c1b80923924164f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">const iterator type  <a href="#aa3cfc1f0c2f501e6c1b80923924164f7">More...</a><br/></td></tr>
<tr class="separator:aa3cfc1f0c2f501e6c1b80923924164f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36873ccc096739891f6a7299cabd8191"><td class="memItemLeft" align="right" valign="top">typedef base_type::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a36873ccc096739891f6a7299cabd8191">reverse_iterator</a></td></tr>
<tr class="memdesc:a36873ccc096739891f6a7299cabd8191"><td class="mdescLeft">&#160;</td><td class="mdescRight">reverse iterator type  <a href="#a36873ccc096739891f6a7299cabd8191">More...</a><br/></td></tr>
<tr class="separator:a36873ccc096739891f6a7299cabd8191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8654dd80c0b3669f9389d84bb7c232"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
base_type::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#aba8654dd80c0b3669f9389d84bb7c232">const_reverse_iterator</a></td></tr>
<tr class="memdesc:aba8654dd80c0b3669f9389d84bb7c232"><td class="mdescLeft">&#160;</td><td class="mdescRight">const reverse iterator type  <a href="#aba8654dd80c0b3669f9389d84bb7c232">More...</a><br/></td></tr>
<tr class="separator:aba8654dd80c0b3669f9389d84bb7c232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3809f65553e4c7f3ec47bd2d5ba8ce5d"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
impl::array_kernel_argument&lt; T, <br class="typebreak"/>
N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a3809f65553e4c7f3ec47bd2d5ba8ce5d">kernel_argument</a></td></tr>
<tr class="memdesc:a3809f65553e4c7f3ec47bd2d5ba8ce5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">kernel argument type  <a href="#a3809f65553e4c7f3ec47bd2d5ba8ce5d">More...</a><br/></td></tr>
<tr class="separator:a3809f65553e4c7f3ec47bd2d5ba8ce5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc38fb3980f68dd13b5b6d28852d48e"><td class="memItemLeft" align="right" valign="top">typedef const <br class="typebreak"/>
impl::array_kernel_argument&lt; T, <br class="typebreak"/>
N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#aebc38fb3980f68dd13b5b6d28852d48e">const_kernel_argument</a></td></tr>
<tr class="memdesc:aebc38fb3980f68dd13b5b6d28852d48e"><td class="mdescLeft">&#160;</td><td class="mdescRight">const kernel argument type  <a href="#aebc38fb3980f68dd13b5b6d28852d48e">More...</a><br/></td></tr>
<tr class="separator:aebc38fb3980f68dd13b5b6d28852d48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a69495b7cd8b536b8d8db1ca75f72c3fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a69495b7cd8b536b8d8db1ca75f72c3fb">array</a> ()</td></tr>
<tr class="memdesc:a69495b7cd8b536b8d8db1ca75f72c3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a fixed-size array with N elements.  <a href="#a69495b7cd8b536b8d8db1ca75f72c3fb">More...</a><br/></td></tr>
<tr class="separator:a69495b7cd8b536b8d8db1ca75f72c3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb905f957c8cf410e16f9ad6fbef289"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a4bb905f957c8cf410e16f9ad6fbef289">array</a> (const <a class="el" href="classecuda_1_1array.html">array</a> &amp;src)</td></tr>
<tr class="memdesc:a4bb905f957c8cf410e16f9ad6fbef289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a4bb905f957c8cf410e16f9ad6fbef289">More...</a><br/></td></tr>
<tr class="separator:a4bb905f957c8cf410e16f9ad6fbef289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b115af5409c1d124365d347136bd657"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1array.html">array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a1b115af5409c1d124365d347136bd657">operator=</a> (const <a class="el" href="classecuda_1_1array.html">array</a> &amp;other)</td></tr>
<tr class="memdesc:a1b115af5409c1d124365d347136bd657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a1b115af5409c1d124365d347136bd657">More...</a><br/></td></tr>
<tr class="separator:a1b115af5409c1d124365d347136bd657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45271a0b1ff3333e1e91c7161d2fdec9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#a022ab88abce89947041699f5b8fe2743">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a45271a0b1ff3333e1e91c7161d2fdec9">at</a> (<a class="el" href="classecuda_1_1array.html#a28d033e0224780208a9c9fb058dac896">size_type</a> index)</td></tr>
<tr class="memdesc:a45271a0b1ff3333e1e91c7161d2fdec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index, with bounds checking.  <a href="#a45271a0b1ff3333e1e91c7161d2fdec9">More...</a><br/></td></tr>
<tr class="separator:a45271a0b1ff3333e1e91c7161d2fdec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd4c231cabd390cbdbb87d801b148a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#a2f5f7be3f86f17de0cfaf4c2bd5197dd">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#aedd4c231cabd390cbdbb87d801b148a1">at</a> (<a class="el" href="classecuda_1_1array.html#a28d033e0224780208a9c9fb058dac896">size_type</a> index) const </td></tr>
<tr class="memdesc:aedd4c231cabd390cbdbb87d801b148a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index, with bounds checking.  <a href="#aedd4c231cabd390cbdbb87d801b148a1">More...</a><br/></td></tr>
<tr class="separator:aedd4c231cabd390cbdbb87d801b148a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5860314c0b54cacca9adaef1cc9d36a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#a022ab88abce89947041699f5b8fe2743">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a5860314c0b54cacca9adaef1cc9d36a4">operator[]</a> (<a class="el" href="classecuda_1_1array.html#a28d033e0224780208a9c9fb058dac896">size_type</a> index)</td></tr>
<tr class="memdesc:a5860314c0b54cacca9adaef1cc9d36a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index. No bounds checking is performed.  <a href="#a5860314c0b54cacca9adaef1cc9d36a4">More...</a><br/></td></tr>
<tr class="separator:a5860314c0b54cacca9adaef1cc9d36a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef656f037c06aa5977d58091fcc3fb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#a2f5f7be3f86f17de0cfaf4c2bd5197dd">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a6ef656f037c06aa5977d58091fcc3fb0">operator[]</a> (<a class="el" href="classecuda_1_1array.html#a28d033e0224780208a9c9fb058dac896">size_type</a> index) const </td></tr>
<tr class="memdesc:a6ef656f037c06aa5977d58091fcc3fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index. No bounds checking is performed.  <a href="#a6ef656f037c06aa5977d58091fcc3fb0">More...</a><br/></td></tr>
<tr class="separator:a6ef656f037c06aa5977d58091fcc3fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a6bf33cc56c5f598ce8e55b051cb74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#a022ab88abce89947041699f5b8fe2743">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a77a6bf33cc56c5f598ce8e55b051cb74">operator()</a> (const <a class="el" href="classecuda_1_1array.html#a28d033e0224780208a9c9fb058dac896">size_type</a> index)</td></tr>
<tr class="memdesc:a77a6bf33cc56c5f598ce8e55b051cb74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index. No bounds checking is performed.  <a href="#a77a6bf33cc56c5f598ce8e55b051cb74">More...</a><br/></td></tr>
<tr class="separator:a77a6bf33cc56c5f598ce8e55b051cb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24861081ebecd346f50d17c0ab1700ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#a2f5f7be3f86f17de0cfaf4c2bd5197dd">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a24861081ebecd346f50d17c0ab1700ce">operator()</a> (const <a class="el" href="classecuda_1_1array.html#a28d033e0224780208a9c9fb058dac896">size_type</a> index) const </td></tr>
<tr class="memdesc:a24861081ebecd346f50d17c0ab1700ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at specified location index. No bounds checking is performed.  <a href="#a24861081ebecd346f50d17c0ab1700ce">More...</a><br/></td></tr>
<tr class="separator:a24861081ebecd346f50d17c0ab1700ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0efbed1f1994244bd0d7d480bcf4ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#a022ab88abce89947041699f5b8fe2743">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#aca0efbed1f1994244bd0d7d480bcf4ca">front</a> ()</td></tr>
<tr class="memdesc:aca0efbed1f1994244bd0d7d480bcf4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container.  <a href="#aca0efbed1f1994244bd0d7d480bcf4ca">More...</a><br/></td></tr>
<tr class="separator:aca0efbed1f1994244bd0d7d480bcf4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1c0e9c1a5033f0fd81e8a37f6e1381"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#a022ab88abce89947041699f5b8fe2743">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a8e1c0e9c1a5033f0fd81e8a37f6e1381">back</a> ()</td></tr>
<tr class="memdesc:a8e1c0e9c1a5033f0fd81e8a37f6e1381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container.  <a href="#a8e1c0e9c1a5033f0fd81e8a37f6e1381">More...</a><br/></td></tr>
<tr class="separator:a8e1c0e9c1a5033f0fd81e8a37f6e1381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7e94afd4c90642369e4c1f4056ece8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#a2f5f7be3f86f17de0cfaf4c2bd5197dd">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a6c7e94afd4c90642369e4c1f4056ece8">front</a> () const </td></tr>
<tr class="memdesc:a6c7e94afd4c90642369e4c1f4056ece8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the container.  <a href="#a6c7e94afd4c90642369e4c1f4056ece8">More...</a><br/></td></tr>
<tr class="separator:a6c7e94afd4c90642369e4c1f4056ece8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdae13e06a35f578f10872f7aad7a83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#a2f5f7be3f86f17de0cfaf4c2bd5197dd">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a9bdae13e06a35f578f10872f7aad7a83">back</a> () const </td></tr>
<tr class="memdesc:a9bdae13e06a35f578f10872f7aad7a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the container.  <a href="#a9bdae13e06a35f578f10872f7aad7a83">More...</a><br/></td></tr>
<tr class="separator:a9bdae13e06a35f578f10872f7aad7a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dab1b10b4d7689ffa53db4be96b1ae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#a427a54dfd16aa5755ec918ac2bbd45b9">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a2dab1b10b4d7689ffa53db4be96b1ae3">data</a> () <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:a2dab1b10b4d7689ffa53db4be96b1ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage.  <a href="#a2dab1b10b4d7689ffa53db4be96b1ae3">More...</a><br/></td></tr>
<tr class="separator:a2dab1b10b4d7689ffa53db4be96b1ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc47a0428908309d9ca8615a3f0fba29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#acae02af9bf30163da81b98f314e4e8b1">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#abc47a0428908309d9ca8615a3f0fba29">data</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:abc47a0428908309d9ca8615a3f0fba29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the underlying array serving as element storage.  <a href="#abc47a0428908309d9ca8615a3f0fba29">More...</a><br/></td></tr>
<tr class="separator:abc47a0428908309d9ca8615a3f0fba29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9511488943e44fb5b6e344b1e89d0ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#aa2d1327715d3fa58ec77480fb523283a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#ab9511488943e44fb5b6e344b1e89d0ec">begin</a> () <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:ab9511488943e44fb5b6e344b1e89d0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the container.  <a href="#ab9511488943e44fb5b6e344b1e89d0ec">More...</a><br/></td></tr>
<tr class="separator:ab9511488943e44fb5b6e344b1e89d0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7a69116e73fac8114f404bd940716f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#aa2d1327715d3fa58ec77480fb523283a">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#aad7a69116e73fac8114f404bd940716f">end</a> () <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:aad7a69116e73fac8114f404bd940716f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the container.  <a href="#aad7a69116e73fac8114f404bd940716f">More...</a><br/></td></tr>
<tr class="separator:aad7a69116e73fac8114f404bd940716f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc06f49e929052cec3801aa0f0324a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#aa3cfc1f0c2f501e6c1b80923924164f7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#abcc06f49e929052cec3801aa0f0324a8">begin</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:abcc06f49e929052cec3801aa0f0324a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_iterator to the first element of the container.  <a href="#abcc06f49e929052cec3801aa0f0324a8">More...</a><br/></td></tr>
<tr class="separator:abcc06f49e929052cec3801aa0f0324a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5246c1cd4a0e7a601a1b45de0ab79f5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#aa3cfc1f0c2f501e6c1b80923924164f7">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a5246c1cd4a0e7a601a1b45de0ab79f5d">end</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:a5246c1cd4a0e7a601a1b45de0ab79f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_iterator to the element following the last element of the container.  <a href="#a5246c1cd4a0e7a601a1b45de0ab79f5d">More...</a><br/></td></tr>
<tr class="separator:a5246c1cd4a0e7a601a1b45de0ab79f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d84f64cdc88c4a2025f13b8d8cbef03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <br class="typebreak"/>
<a class="el" href="classecuda_1_1array.html#a36873ccc096739891f6a7299cabd8191">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a4d84f64cdc88c4a2025f13b8d8cbef03">rbegin</a> () <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:a4d84f64cdc88c4a2025f13b8d8cbef03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed container.  <a href="#a4d84f64cdc88c4a2025f13b8d8cbef03">More...</a><br/></td></tr>
<tr class="separator:a4d84f64cdc88c4a2025f13b8d8cbef03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c31f579639df66f61cffe5dde81892b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <br class="typebreak"/>
<a class="el" href="classecuda_1_1array.html#a36873ccc096739891f6a7299cabd8191">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a9c31f579639df66f61cffe5dde81892b">rend</a> () <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:a9c31f579639df66f61cffe5dde81892b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed container.  <a href="#a9c31f579639df66f61cffe5dde81892b">More...</a><br/></td></tr>
<tr class="separator:a9c31f579639df66f61cffe5dde81892b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64c980fa377de62da491aa19b80b8c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <br class="typebreak"/>
<a class="el" href="classecuda_1_1array.html#aba8654dd80c0b3669f9389d84bb7c232">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#ab64c980fa377de62da491aa19b80b8c2">rbegin</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:ab64c980fa377de62da491aa19b80b8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_reverse_iterator to the first element of the reversed container.  <a href="#ab64c980fa377de62da491aa19b80b8c2">More...</a><br/></td></tr>
<tr class="separator:ab64c980fa377de62da491aa19b80b8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f48bf00712417f6a83cade391e253b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <br class="typebreak"/>
<a class="el" href="classecuda_1_1array.html#aba8654dd80c0b3669f9389d84bb7c232">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a0f48bf00712417f6a83cade391e253b6">rend</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:a0f48bf00712417f6a83cade391e253b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const_reverse_iterator to the element following the last element of the reversed container.  <a href="#a0f48bf00712417f6a83cade391e253b6">More...</a><br/></td></tr>
<tr class="separator:a0f48bf00712417f6a83cade391e253b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c44c726837de4317c3fb09e7238bbde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <br class="typebreak"/>
<a class="el" href="global_8hpp.html#a9fec271a456e22bc9d8927abb3b8250d">__CONSTEXPR__</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a7c44c726837de4317c3fb09e7238bbde">empty</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:a7c44c726837de4317c3fb09e7238bbde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the container has no elements.  <a href="#a7c44c726837de4317c3fb09e7238bbde">More...</a><br/></td></tr>
<tr class="separator:a7c44c726837de4317c3fb09e7238bbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff59268df5ef067404c45403e3b15c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <br class="typebreak"/>
<a class="el" href="global_8hpp.html#a9fec271a456e22bc9d8927abb3b8250d">__CONSTEXPR__</a> <a class="el" href="classecuda_1_1array.html#a28d033e0224780208a9c9fb058dac896">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a2ff59268df5ef067404c45403e3b15c2">size</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:a2ff59268df5ef067404c45403e3b15c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the container.  <a href="#a2ff59268df5ef067404c45403e3b15c2">More...</a><br/></td></tr>
<tr class="separator:a2ff59268df5ef067404c45403e3b15c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdcf701f0f0be10775de96357e2c4da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a9fec271a456e22bc9d8927abb3b8250d">__CONSTEXPR__</a> <a class="el" href="classecuda_1_1array.html#a28d033e0224780208a9c9fb058dac896">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a7cdcf701f0f0be10775de96357e2c4da">max_size</a> () const <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="memdesc:a7cdcf701f0f0be10775de96357e2c4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of elements the container is able to hold.  <a href="#a7cdcf701f0f0be10775de96357e2c4da">More...</a><br/></td></tr>
<tr class="separator:a7cdcf701f0f0be10775de96357e2c4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f89eb4f23e68e2febad5231bc774a85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a8f89eb4f23e68e2febad5231bc774a85">fill</a> (const <a class="el" href="classecuda_1_1array.html#adf0f56127a85f4d18f1149ac7947269e">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a8f89eb4f23e68e2febad5231bc774a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a given value to all elements in the container.  <a href="#a8f89eb4f23e68e2febad5231bc774a85">More...</a><br/></td></tr>
<tr class="separator:a8f89eb4f23e68e2febad5231bc774a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32c05f06c75da57f0cada48f47a56e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#aa32c05f06c75da57f0cada48f47a56e9">swap</a> (<a class="el" href="classecuda_1_1array.html">array</a> &amp;other)</td></tr>
<tr class="memdesc:aa32c05f06c75da57f0cada48f47a56e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of the container with those of the other.  <a href="#aa32c05f06c75da57f0cada48f47a56e9">More...</a><br/></td></tr>
<tr class="separator:aa32c05f06c75da57f0cada48f47a56e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b619af926befdf496d42e0c7da41e35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a3b619af926befdf496d42e0c7da41e35">operator==</a> (const <a class="el" href="classecuda_1_1array.html">array</a> &amp;other) const </td></tr>
<tr class="memdesc:a3b619af926befdf496d42e0c7da41e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of two arrays are equal.  <a href="#a3b619af926befdf496d42e0c7da41e35">More...</a><br/></td></tr>
<tr class="separator:a3b619af926befdf496d42e0c7da41e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b2271519c6839e2765fc32f2abaa84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a30b2271519c6839e2765fc32f2abaa84">operator!=</a> (const <a class="el" href="classecuda_1_1array.html">array</a> &amp;other) const </td></tr>
<tr class="memdesc:a30b2271519c6839e2765fc32f2abaa84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the contents of two arrays are not equal.  <a href="#a30b2271519c6839e2765fc32f2abaa84">More...</a><br/></td></tr>
<tr class="separator:a30b2271519c6839e2765fc32f2abaa84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5512c13363edf039b2aa53e8c226f6b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a5512c13363edf039b2aa53e8c226f6b9">operator&lt;</a> (const <a class="el" href="classecuda_1_1array.html">array</a> &amp;other) const </td></tr>
<tr class="memdesc:a5512c13363edf039b2aa53e8c226f6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two arrays lexicographically.  <a href="#a5512c13363edf039b2aa53e8c226f6b9">More...</a><br/></td></tr>
<tr class="separator:a5512c13363edf039b2aa53e8c226f6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e644f087be07ddee48f77e6a5c26f07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a0e644f087be07ddee48f77e6a5c26f07">operator&gt;</a> (const <a class="el" href="classecuda_1_1array.html">array</a> &amp;other) const </td></tr>
<tr class="memdesc:a0e644f087be07ddee48f77e6a5c26f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two arrays lexicographically.  <a href="#a0e644f087be07ddee48f77e6a5c26f07">More...</a><br/></td></tr>
<tr class="separator:a0e644f087be07ddee48f77e6a5c26f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72748101d4efd0a3fd3c23057590a2e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a72748101d4efd0a3fd3c23057590a2e2">operator&lt;=</a> (const <a class="el" href="classecuda_1_1array.html">array</a> &amp;other) const </td></tr>
<tr class="memdesc:a72748101d4efd0a3fd3c23057590a2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two arrays lexicographically.  <a href="#a72748101d4efd0a3fd3c23057590a2e2">More...</a><br/></td></tr>
<tr class="separator:a72748101d4efd0a3fd3c23057590a2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eaed4dc415c42d6e29884d8be0dc4e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#a9eaed4dc415c42d6e29884d8be0dc4e8">operator&gt;=</a> (const <a class="el" href="classecuda_1_1array.html">array</a> &amp;other) const </td></tr>
<tr class="memdesc:a9eaed4dc415c42d6e29884d8be0dc4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the contents of two arrays lexicographically.  <a href="#a9eaed4dc415c42d6e29884d8be0dc4e8">More...</a><br/></td></tr>
<tr class="separator:a9eaed4dc415c42d6e29884d8be0dc4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:acfae043bc5f28ec14b522ade8faa8f0c"><td class="memTemplParams" colspan="2">template&lt;typename U , std::size_t M, class Q &gt; </td></tr>
<tr class="memitem:acfae043bc5f28ec14b522ade8faa8f0c"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html#acfae043bc5f28ec14b522ade8faa8f0c">array</a></td></tr>
<tr class="separator:acfae043bc5f28ec14b522ade8faa8f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt;<br/>
class ecuda::array&lt; T, N, P &gt;</h3>

<p>A fixed-size array stored in device memory. </p>
<p>Creates a fixed size array in GPU memory. Redeclares most of the STL methods on the equivalent C++11 std::array (although this implementation works with C98 compilers).</p>
<p>Methods are prefaced with appropriate keywords to declare them as host and/or device capable. In general: operations requiring memory allocation/deallocation are host only, operations to access the values of specific elements are device only, and copy operations on ranges of data and accessors of general information can be performed on both the host and device. </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00080">80</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="aa3cfc1f0c2f501e6c1b80923924164f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::const_iterator <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::<a class="el" href="classecuda_1_1array.html#aa3cfc1f0c2f501e6c1b80923924164f7">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const iterator type </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00095">95</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aebc38fb3980f68dd13b5b6d28852d48e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const impl::array_kernel_argument&lt;T,N&gt; <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::<a class="el" href="classecuda_1_1array.html#aebc38fb3980f68dd13b5b6d28852d48e">const_kernel_argument</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const kernel argument type </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00100">100</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acae02af9bf30163da81b98f314e4e8b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef make_const&lt;<a class="el" href="classecuda_1_1array.html#a427a54dfd16aa5755ec918ac2bbd45b9">pointer</a>&gt;::type <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::<a class="el" href="classecuda_1_1array.html#acae02af9bf30163da81b98f314e4e8b1">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell const pointer type </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00092">92</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2f5f7be3f86f17de0cfaf4c2bd5197dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::const_reference <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::<a class="el" href="classecuda_1_1array.html#a2f5f7be3f86f17de0cfaf4c2bd5197dd">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell const reference type </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00090">90</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aba8654dd80c0b3669f9389d84bb7c232"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::const_reverse_iterator <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::<a class="el" href="classecuda_1_1array.html#aba8654dd80c0b3669f9389d84bb7c232">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const reverse iterator type </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00097">97</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac99789e4a05c47a1dae47ea902308bc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::difference_type <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::<a class="el" href="classecuda_1_1array.html#ac99789e4a05c47a1dae47ea902308bc2">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>signed integral type </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00088">88</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa2d1327715d3fa58ec77480fb523283a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::iterator <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::<a class="el" href="classecuda_1_1array.html#aa2d1327715d3fa58ec77480fb523283a">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iterator type </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00094">94</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3809f65553e4c7f3ec47bd2d5ba8ce5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef impl::array_kernel_argument&lt;T,N&gt; <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::<a class="el" href="classecuda_1_1array.html#a3809f65553e4c7f3ec47bd2d5ba8ce5d">kernel_argument</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>kernel argument type </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00099">99</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a427a54dfd16aa5755ec918ac2bbd45b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::pointer <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::<a class="el" href="classecuda_1_1array.html#a427a54dfd16aa5755ec918ac2bbd45b9">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell pointer type </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00091">91</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a022ab88abce89947041699f5b8fe2743"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::reference <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::<a class="el" href="classecuda_1_1array.html#a022ab88abce89947041699f5b8fe2743">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell reference type </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00089">89</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a36873ccc096739891f6a7299cabd8191"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::reverse_iterator <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::<a class="el" href="classecuda_1_1array.html#a36873ccc096739891f6a7299cabd8191">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reverse iterator type </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00096">96</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a28d033e0224780208a9c9fb058dac896"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::size_type <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::<a class="el" href="classecuda_1_1array.html#a28d033e0224780208a9c9fb058dac896">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unsigned integral type </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00087">87</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adf0f56127a85f4d18f1149ac7947269e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_type::value_type <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::<a class="el" href="classecuda_1_1array.html#adf0f56127a85f4d18f1149ac7947269e">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cell data type </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00086">86</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a69495b7cd8b536b8d8db1ca75f72c3fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::<a class="el" href="classecuda_1_1array.html">array</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a fixed-size array with N elements. </p>
<p>Each element is a default-initialized value of T. </p>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00126">126</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4bb905f957c8cf410e16f9ad6fbef289"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::<a class="el" href="classecuda_1_1array.html">array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1array.html">array</a>&lt; T, N, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Constructs an array with a copy of the contents of src.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>another array object of the same type and size, whose contents are copied. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00138">138</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a45271a0b1ff3333e1e91c7161d2fdec9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#a022ab88abce89947041699f5b8fe2743">reference</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1array.html#a28d033e0224780208a9c9fb058dac896">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location index, with bounds checking. </p>
<p>If index is not within the range of the container, the current kernel will exit and cudaGetLastError will return cudaErrorUnknown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>position of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00202">202</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aedd4c231cabd390cbdbb87d801b148a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#a2f5f7be3f86f17de0cfaf4c2bd5197dd">const_reference</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1array.html#a28d033e0224780208a9c9fb058dac896">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location index, with bounds checking. </p>
<p>If index is not within the range of the container, the current kernel will exit and cudaGetLastError will return cudaErrorUnknown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>position of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00227">227</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8e1c0e9c1a5033f0fd81e8a37f6e1381"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#a022ab88abce89947041699f5b8fe2743">reference</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the container. </p>
<p>Calling back on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00295">295</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9bdae13e06a35f578f10872f7aad7a83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#a2f5f7be3f86f17de0cfaf4c2bd5197dd">const_reference</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the container. </p>
<p>Calling back on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00312">312</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab9511488943e44fb5b6e344b1e89d0ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#aa2d1327715d3fa58ec77480fb523283a">iterator</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the container. </p>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classecuda_1_1array.html#aad7a69116e73fac8114f404bd940716f" title="Returns an iterator to the element following the last element of the container. ">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00341">341</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abcc06f49e929052cec3801aa0f0324a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#aa3cfc1f0c2f501e6c1b80923924164f7">const_iterator</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_iterator to the first element of the container. </p>
<p>If the container is empty, the returned iterator will be equal to <a class="el" href="classecuda_1_1array.html#aad7a69116e73fac8114f404bd940716f" title="Returns an iterator to the element following the last element of the container. ">end()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00359">359</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2dab1b10b4d7689ffa53db4be96b1ae3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#a427a54dfd16aa5755ec918ac2bbd45b9">pointer</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying array serving as element storage. </p>
<p>The pointer is such that range [<a class="el" href="classecuda_1_1array.html#a2dab1b10b4d7689ffa53db4be96b1ae3" title="Returns pointer to the underlying array serving as element storage. ">data()</a>; <a class="el" href="classecuda_1_1array.html#a2dab1b10b4d7689ffa53db4be96b1ae3" title="Returns pointer to the underlying array serving as element storage. ">data()</a>+size()) is always a valid range, even if the container is empty.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00322">322</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc47a0428908309d9ca8615a3f0fba29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#acae02af9bf30163da81b98f314e4e8b1">const_pointer</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to the underlying array serving as element storage. </p>
<p>The pointer is such that range [<a class="el" href="classecuda_1_1array.html#a2dab1b10b4d7689ffa53db4be96b1ae3" title="Returns pointer to the underlying array serving as element storage. ">data()</a>; <a class="el" href="classecuda_1_1array.html#a2dab1b10b4d7689ffa53db4be96b1ae3" title="Returns pointer to the underlying array serving as element storage. ">data()</a>+size()) is always a valid range, even if the container is empty.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the underlying element storage. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00332">332</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7c44c726837de4317c3fb09e7238bbde"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="global_8hpp.html#a9fec271a456e22bc9d8927abb3b8250d">__CONSTEXPR__</a> bool <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the container has no elements. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the container is empty, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00454">454</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aad7a69116e73fac8114f404bd940716f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#aa2d1327715d3fa58ec77480fb523283a">iterator</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the container. </p>
<p>The element acts as a placeholder; attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00350">350</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5246c1cd4a0e7a601a1b45de0ab79f5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#aa3cfc1f0c2f501e6c1b80923924164f7">const_iterator</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_iterator to the element following the last element of the container. </p>
<p>The element acts as a placeholder; attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00368">368</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8f89eb4f23e68e2febad5231bc774a85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1array.html#adf0f56127a85f4d18f1149ac7947269e">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a given value to all elements in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to assign to the elements </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00478">478</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca0efbed1f1994244bd0d7d480bcf4ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#a022ab88abce89947041699f5b8fe2743">reference</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the container. </p>
<p>Calling front on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00286">286</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6c7e94afd4c90642369e4c1f4056ece8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#a2f5f7be3f86f17de0cfaf4c2bd5197dd">const_reference</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the container. </p>
<p>Calling front on an empty container is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00303">303</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7cdcf701f0f0be10775de96357e2c4da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a9fec271a456e22bc9d8927abb3b8250d">__CONSTEXPR__</a> <a class="el" href="classecuda_1_1array.html#a28d033e0224780208a9c9fb058dac896">size_type</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of elements the container is able to hold. </p>
<p>The value can be defined according to system or library implementation limitations.</p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of elements. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00470">470</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a30b2271519c6839e2765fc32f2abaa84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1array.html">array</a>&lt; T, N, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the contents of two arrays are not equal. </p>
<p>That is, whether any element in the this array does not compare equal with the element in another array at the same position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents are not equal, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00515">515</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a77a6bf33cc56c5f598ce8e55b051cb74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#a022ab88abce89947041699f5b8fe2743">reference</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1array.html#a28d033e0224780208a9c9fb058dac896">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location index. No bounds checking is performed. </p>
<p>This is identical to operator[] but is present for consistency with higher-dimensional containers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>position of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00267">267</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a24861081ebecd346f50d17c0ab1700ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#a2f5f7be3f86f17de0cfaf4c2bd5197dd">const_reference</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1array.html#a28d033e0224780208a9c9fb058dac896">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location index. No bounds checking is performed. </p>
<p>This is identical to operator[] but is present for consistency with higher-dimensional containers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>position of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00277">277</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5512c13363edf039b2aa53e8c226f6b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1array.html">array</a>&lt; T, N, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two arrays lexicographically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of this array are lexicographically less than the other array, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00523">523</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a72748101d4efd0a3fd3c23057590a2e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1array.html">array</a>&lt; T, N, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two arrays lexicographically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of this array are lexicographically less than or equal to the other array, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00539">539</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1b115af5409c1d124365d347136bd657"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="classecuda_1_1array.html">array</a>&amp; <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1array.html">array</a>&lt; T, N, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>Assigns new contents to the array, replacing its current contents.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>another array object of the same type and size, whose contents are assigned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00163">163</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3b619af926befdf496d42e0c7da41e35"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1array.html">array</a>&lt; T, N, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the contents of two arrays are equal. </p>
<p>That is, whether each element in the this array compares equal with the element in another array at the same position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents are equal, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00504">504</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0e644f087be07ddee48f77e6a5c26f07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1array.html">array</a>&lt; T, N, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two arrays lexicographically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of this array are lexicographically greater than the other array, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00531">531</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9eaed4dc415c42d6e29884d8be0dc4e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1array.html">array</a>&lt; T, N, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the contents of two arrays lexicographically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to compare contents with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the contents of this array are lexicographically greater than or equal to the other array, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00547">547</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5860314c0b54cacca9adaef1cc9d36a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#a022ab88abce89947041699f5b8fe2743">reference</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1array.html#a28d033e0224780208a9c9fb058dac896">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location index. No bounds checking is performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>position of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00249">249</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6ef656f037c06aa5977d58091fcc3fb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#a2f5f7be3f86f17de0cfaf4c2bd5197dd">const_reference</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1array.html#a28d033e0224780208a9c9fb058dac896">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at specified location index. No bounds checking is performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>position of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00257">257</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d84f64cdc88c4a2025f13b8d8cbef03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#a36873ccc096739891f6a7299cabd8191">reverse_iterator</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the first element of the reversed container. </p>
<p>It corresponds to the last element of the non-reversed container.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00377">377</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab64c980fa377de62da491aa19b80b8c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#aba8654dd80c0b3669f9389d84bb7c232">const_reverse_iterator</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_reverse_iterator to the first element of the reversed container. </p>
<p>It corresponds to the last element of the non-reversed container.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the first element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00396">396</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9c31f579639df66f61cffe5dde81892b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#a36873ccc096739891f6a7299cabd8191">reverse_iterator</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed container. </p>
<p>It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00387">387</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0f48bf00712417f6a83cade391e253b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1array.html#aba8654dd80c0b3669f9389d84bb7c232">const_reverse_iterator</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const_reverse_iterator to the element following the last element of the reversed container. </p>
<p>It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behaviour.</p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator to the element following the last element. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00406">406</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2ff59268df5ef067404c45403e3b15c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="global_8hpp.html#a9fec271a456e22bc9d8927abb3b8250d">__CONSTEXPR__</a> <a class="el" href="classecuda_1_1array.html#a28d033e0224780208a9c9fb058dac896">size_type</a> <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container. </dd></dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00461">461</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa32c05f06c75da57f0cada48f47a56e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void <a class="el" href="classecuda_1_1array.html">ecuda::array</a>&lt; T, N, P &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1array.html">array</a>&lt; T, N, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of the container with those of the other. </p>
<p>Does not cause iterators and references to associate with the other container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>container to exchange the contents with </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00487">487</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="acfae043bc5f28ec14b522ade8faa8f0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class P = shared_ptr&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U , std::size_t M, class Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classecuda_1_1array.html">array</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="array_8hpp_source.html#l00102">102</a> of file <a class="el" href="array_8hpp_source.html">array.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/ecuda/<a class="el" href="array_8hpp_source.html">array.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 28 2016 14:05:58 for Extended CUDA Library (ecuda) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
