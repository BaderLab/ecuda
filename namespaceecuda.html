<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Extended CUDA Library (ecuda): ecuda Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Extended CUDA Library (ecuda)
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ecuda Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1host__allocator.html">host_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator for page-locked host memory.  <a href="classecuda_1_1host__allocator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__allocator.html">device_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator for device memory.  <a href="classecuda_1_1device__allocator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__pitch__allocator.html">device_pitch_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator for hardware aligned device memory.  <a href="classecuda_1_1device__pitch__allocator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fixed-size array stored in device memory.  <a href="classecuda_1_1array.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html">cube</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A resizable cube stored in device memory.  <a href="classecuda_1_1cube.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cuda__error.html">cuda_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for CUDA API cudaError_t errors.  <a href="classecuda_1_1cuda__error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device.html">device</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates CUDA API device information functions.  <a href="classecuda_1_1device.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1event.html">event</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates CUDA API event objects and functions.  <a href="classecuda_1_1event.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1padded__ptr.html">padded_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialized pointer to padded memory.  <a href="classecuda_1_1padded__ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structecuda_1_1device__iterator__tag.html">device_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator category denoting device memory.  <a href="structecuda_1_1device__iterator__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structecuda_1_1device__contiguous__iterator__tag.html">device_contiguous_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator category denoting contiguous device memory.  <a href="structecuda_1_1device__contiguous__iterator__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structecuda_1_1device__contiguous__block__iterator__tag.html">device_contiguous_block_iterator_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator category denoting device memory that is made of contiguous blocks (but the blocks themselves are non-contiguous).  <a href="structecuda_1_1device__contiguous__block__iterator__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__iterator.html">device_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__contiguous__iterator.html">device_contiguous_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__contiguous__block__iterator.html">device_contiguous_block_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1reverse__device__iterator.html">reverse_device_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1iterator__traits.html">iterator_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1iterator__traits_3_01device__iterator_3_01T_00_01PointerType_00_01Category_01_4_01_4.html">iterator_traits&lt; device_iterator&lt; T, PointerType, Category &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1iterator__traits_3_01device__contiguous__iterator_3_01T_01_4_01_4.html">iterator_traits&lt; device_contiguous_iterator&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1iterator__traits_3_01device__contiguous__block__iterator_3_01T_00_01P_01_4_01_4.html">iterator_traits&lt; device_contiguous_block_iterator&lt; T, P &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1iterator__traits_3_01reverse__device__iterator_3_01Iterator_01_4_01_4.html">iterator_traits&lt; reverse_device_iterator&lt; Iterator &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1iterator__traits_3_01T_01_5_01_4.html">iterator_traits&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html">matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A resizable matrix stored in device memory.  <a href="classecuda_1_1matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structecuda_1_1owner__less.html">owner_less</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structecuda_1_1owner__less_3_01shared__ptr_3_01T_01_4_01_4.html">owner_less&lt; shared_ptr&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structecuda_1_1default__device__delete.html">default_device_delete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default destruction policy used by smart pointers to device memory.  <a href="structecuda_1_1default__device__delete.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structecuda_1_1default__host__delete.html">default_host_delete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default destruction policy used by smart pointers to page-locked host memory.  <a href="structecuda_1_1default__host__delete.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1shared__ptr.html">shared_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A smart pointer that retains shared ownership of an object in device memory.  <a href="classecuda_1_1shared__ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1striding__padded__ptr.html">striding_padded_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialized pointer to striding memory.  <a href="classecuda_1_1striding__padded__ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1striding__ptr.html">striding_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialized pointer to striding memory.  <a href="classecuda_1_1striding__ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1unique__ptr.html">unique_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A smart pointer that retains sole ownership of an object.  <a href="classecuda_1_1unique__ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structecuda_1_1pair.html">pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Couples together a pair of values.  <a href="structecuda_1_1pair.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html">vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A resizable vector stored in device memory.  <a href="classecuda_1_1vector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad79c20b551be33bea5f0b62fba14434d"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:ad79c20b551be33bea5f0b62fba14434d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#ad79c20b551be33bea5f0b62fba14434d">copy</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr class="memdesc:ad79c20b551be33bea5f0b62fba14434d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replacement for std::copy.  <a href="#ad79c20b551be33bea5f0b62fba14434d">More...</a><br/></td></tr>
<tr class="separator:ad79c20b551be33bea5f0b62fba14434d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595acf3358160a89231e322260427baf"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:a595acf3358160a89231e322260427baf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <br class="typebreak"/>
<a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <br class="typebreak"/>
OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a595acf3358160a89231e322260427baf">copy</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr class="memdesc:a595acf3358160a89231e322260427baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replacement for std::copy.  <a href="#a595acf3358160a89231e322260427baf">More...</a><br/></td></tr>
<tr class="separator:a595acf3358160a89231e322260427baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902187585c1ae9933b4289ebbeef4d21"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , typename T &gt; </td></tr>
<tr class="memitem:a902187585c1ae9933b4289ebbeef4d21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <br class="typebreak"/>
<a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <br class="typebreak"/>
<a class="el" href="classecuda_1_1iterator__traits.html">ecuda::iterator_traits</a><br class="typebreak"/>
&lt; InputIterator &gt;<br class="typebreak"/>
::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a902187585c1ae9933b4289ebbeef4d21">count</a> (InputIterator first, InputIterator last, const T &amp;value)</td></tr>
<tr class="separator:a902187585c1ae9933b4289ebbeef4d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98d9362143be45ee0d1b6264b5ac3fc"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:aa98d9362143be45ee0d1b6264b5ac3fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <br class="typebreak"/>
<a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <br class="typebreak"/>
<a class="el" href="classecuda_1_1iterator__traits.html">ecuda::iterator_traits</a><br class="typebreak"/>
&lt; InputIterator &gt;<br class="typebreak"/>
::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#aa98d9362143be45ee0d1b6264b5ac3fc">count_if</a> (InputIterator first, InputIterator last, UnaryPredicate p)</td></tr>
<tr class="separator:aa98d9362143be45ee0d1b6264b5ac3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568367d26ff7d59115ae8958b8ddf6eb"><td class="memTemplParams" colspan="2">template&lt;class InputIterator1 , class InputIterator2 &gt; </td></tr>
<tr class="memitem:a568367d26ff7d59115ae8958b8ddf6eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a568367d26ff7d59115ae8958b8ddf6eb">equal</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)</td></tr>
<tr class="memdesc:a568367d26ff7d59115ae8958b8ddf6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replacement for std::equal.  <a href="#a568367d26ff7d59115ae8958b8ddf6eb">More...</a><br/></td></tr>
<tr class="separator:a568367d26ff7d59115ae8958b8ddf6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd08c374f6dff0cc18e6cc45adbdd23"><td class="memTemplParams" colspan="2">template&lt;class InputIterator1 , class InputIterator2 &gt; </td></tr>
<tr class="memitem:a1fd08c374f6dff0cc18e6cc45adbdd23"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <br class="typebreak"/>
<a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a1fd08c374f6dff0cc18e6cc45adbdd23">equal</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)</td></tr>
<tr class="memdesc:a1fd08c374f6dff0cc18e6cc45adbdd23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replacement for std::equal.  <a href="#a1fd08c374f6dff0cc18e6cc45adbdd23">More...</a><br/></td></tr>
<tr class="separator:a1fd08c374f6dff0cc18e6cc45adbdd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2f18d3c3f7a7d723decd0192b56076"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , typename T &gt; </td></tr>
<tr class="memitem:a4a2f18d3c3f7a7d723decd0192b56076"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a4a2f18d3c3f7a7d723decd0192b56076">fill</a> (ForwardIterator first, ForwardIterator last, const T &amp;val)</td></tr>
<tr class="separator:a4a2f18d3c3f7a7d723decd0192b56076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59747f2869c079dbeeb00e69ced5781"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , typename T &gt; </td></tr>
<tr class="memitem:ac59747f2869c079dbeeb00e69ced5781"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <br class="typebreak"/>
<a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#ac59747f2869c079dbeeb00e69ced5781">fill</a> (ForwardIterator first, ForwardIterator last, const T &amp;val)</td></tr>
<tr class="separator:ac59747f2869c079dbeeb00e69ced5781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482b487ad8d99e85a03ce72b5e5f7c70"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , typename T &gt; </td></tr>
<tr class="memitem:a482b487ad8d99e85a03ce72b5e5f7c70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <br class="typebreak"/>
<a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <br class="typebreak"/>
InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a482b487ad8d99e85a03ce72b5e5f7c70">find</a> (InputIterator first, InputIterator last, const T &amp;value)</td></tr>
<tr class="separator:a482b487ad8d99e85a03ce72b5e5f7c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c49d41166264fc71c73ab64b622d9a"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a95c49d41166264fc71c73ab64b622d9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <br class="typebreak"/>
<a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <br class="typebreak"/>
InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a95c49d41166264fc71c73ab64b622d9a">find_if</a> (InputIterator first, InputIterator last, UnaryPredicate p)</td></tr>
<tr class="separator:a95c49d41166264fc71c73ab64b622d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3f7b57ddfe569a22a8fad7207cf8d7"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class UnaryFunction &gt; </td></tr>
<tr class="memitem:adc3f7b57ddfe569a22a8fad7207cf8d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <br class="typebreak"/>
<a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <br class="typebreak"/>
UnaryFunction&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#adc3f7b57ddfe569a22a8fad7207cf8d7">for_each</a> (InputIterator first, InputIterator last, UnaryFunction f)</td></tr>
<tr class="separator:adc3f7b57ddfe569a22a8fad7207cf8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d3b756a58da139b956df94d957316b"><td class="memTemplParams" colspan="2">template&lt;class InputIterator1 , class InputIterator2 &gt; </td></tr>
<tr class="memitem:a73d3b756a58da139b956df94d957316b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a73d3b756a58da139b956df94d957316b">lexicographical_compare</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2)</td></tr>
<tr class="separator:a73d3b756a58da139b956df94d957316b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a44dbc3f6bd18127acd4e226984bbcd"><td class="memTemplParams" colspan="2">template&lt;class InputIterator1 , class InputIterator2 &gt; </td></tr>
<tr class="memitem:a2a44dbc3f6bd18127acd4e226984bbcd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <br class="typebreak"/>
<a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a2a44dbc3f6bd18127acd4e226984bbcd">lexicographical_compare</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2)</td></tr>
<tr class="separator:a2a44dbc3f6bd18127acd4e226984bbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d98980c03fd58b47623cef24f5670b5"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a4d98980c03fd58b47623cef24f5670b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a4d98980c03fd58b47623cef24f5670b5">max_element</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="separator:a4d98980c03fd58b47623cef24f5670b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08780bb9cf2a866eae21588eb0a93440"><td class="memTemplParams" colspan="2">template&lt;class InputIterator1 , class InputIterator2 &gt; </td></tr>
<tr class="memitem:a08780bb9cf2a866eae21588eb0a93440"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <br class="typebreak"/>
<a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <br class="typebreak"/>
<a class="el" href="structecuda_1_1pair.html">ecuda::pair</a>&lt; InputIterator1, <br class="typebreak"/>
InputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a08780bb9cf2a866eae21588eb0a93440">mismatch</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)</td></tr>
<tr class="separator:a08780bb9cf2a866eae21588eb0a93440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e8e184cc6bfca5de6010459b2504a2"><td class="memTemplParams" colspan="2">template&lt;class BidirectionalIterator &gt; </td></tr>
<tr class="memitem:a60e8e184cc6bfca5de6010459b2504a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a60e8e184cc6bfca5de6010459b2504a2">reverse</a> (BidirectionalIterator first, BidirectionalIterator last)</td></tr>
<tr class="separator:a60e8e184cc6bfca5de6010459b2504a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88da887b8ac2129df8ce4fdf62defda"><td class="memTemplParams" colspan="2">template&lt;class BidirectionalIterator &gt; </td></tr>
<tr class="memitem:ab88da887b8ac2129df8ce4fdf62defda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <br class="typebreak"/>
<a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#ab88da887b8ac2129df8ce4fdf62defda">reverse</a> (BidirectionalIterator first, BidirectionalIterator last)</td></tr>
<tr class="separator:ab88da887b8ac2129df8ce4fdf62defda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465833740bdd33baea8b71771599079f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a465833740bdd33baea8b71771599079f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a465833740bdd33baea8b71771599079f">min</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a465833740bdd33baea8b71771599079f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2141ad90b1907878f8b7c4f4382ef92c"><td class="memTemplParams" colspan="2">template&lt;typename T , class Compare &gt; </td></tr>
<tr class="memitem:a2141ad90b1907878f8b7c4f4382ef92c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a2141ad90b1907878f8b7c4f4382ef92c">min</a> (const T &amp;a, const T &amp;b, Compare cmp)</td></tr>
<tr class="separator:a2141ad90b1907878f8b7c4f4382ef92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba4df69edbf067b8c2f22fd26545ed5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4ba4df69edbf067b8c2f22fd26545ed5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a4ba4df69edbf067b8c2f22fd26545ed5">max</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a4ba4df69edbf067b8c2f22fd26545ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1013e77b0f188878cdec3096b58076f4"><td class="memTemplParams" colspan="2">template&lt;typename T , class Compare &gt; </td></tr>
<tr class="memitem:a1013e77b0f188878cdec3096b58076f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a1013e77b0f188878cdec3096b58076f4">max</a> (const T &amp;a, const T &amp;b, Compare cmp)</td></tr>
<tr class="separator:a1013e77b0f188878cdec3096b58076f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2b93d379cadb08c39f2ae420afcf11"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abc2b93d379cadb08c39f2ae420afcf11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#abc2b93d379cadb08c39f2ae420afcf11">swap</a> (T &amp;a, T &amp;b) <a class="el" href="global_8hpp.html#ac357af947bf0fb6c15fe2ac07aea5382">__NOEXCEPT__</a></td></tr>
<tr class="separator:abc2b93d379cadb08c39f2ae420afcf11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d5425545b1ea966a9d23e3d2321b6b"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a32d5425545b1ea966a9d23e3d2321b6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <br class="typebreak"/>
<a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a32d5425545b1ea966a9d23e3d2321b6b">any_of</a> (InputIterator first, InputIterator last, UnaryPredicate p)</td></tr>
<tr class="separator:a32d5425545b1ea966a9d23e3d2321b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719c3ee38cf70b471ceb7b529e1f9384"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a719c3ee38cf70b471ceb7b529e1f9384"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <br class="typebreak"/>
<a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a719c3ee38cf70b471ceb7b529e1f9384">none_of</a> (InputIterator first, InputIterator last, UnaryPredicate p)</td></tr>
<tr class="separator:a719c3ee38cf70b471ceb7b529e1f9384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9bd1e585fb42fdb1c4dfb0548529b3a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa9bd1e585fb42fdb1c4dfb0548529b3a"><td class="memTemplItemLeft" align="right" valign="top">cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#aa9bd1e585fb42fdb1c4dfb0548529b3a">cudaMemcpy</a> (T *dest, const T *src, const size_t <a class="el" href="namespaceecuda.html#a902187585c1ae9933b4289ebbeef4d21">count</a>, cudaMemcpyKind kind)</td></tr>
<tr class="memdesc:aa9bd1e585fb42fdb1c4dfb0548529b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around CUDA API function cudaMemcpy.  <a href="#aa9bd1e585fb42fdb1c4dfb0548529b3a">More...</a><br/></td></tr>
<tr class="separator:aa9bd1e585fb42fdb1c4dfb0548529b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e659446682da379a4424c59a87d4956"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7e659446682da379a4424c59a87d4956"><td class="memTemplItemLeft" align="right" valign="top">cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a7e659446682da379a4424c59a87d4956">cudaMemcpy2D</a> (T *dest, const size_t dpitch, const T *src, const size_t spitch, const size_t width, const size_t height, cudaMemcpyKind kind)</td></tr>
<tr class="memdesc:a7e659446682da379a4424c59a87d4956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around CUDA API function cudaMemcpy2D.  <a href="#a7e659446682da379a4424c59a87d4956">More...</a><br/></td></tr>
<tr class="separator:a7e659446682da379a4424c59a87d4956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad434d4d608702c94e707a00c84eef984"><td class="memItemLeft" align="right" valign="top">cudaError_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#ad434d4d608702c94e707a00c84eef984">cudaMemset</a> (char *devPtr, const char &amp;value, const size_t <a class="el" href="namespaceecuda.html#a902187585c1ae9933b4289ebbeef4d21">count</a>)</td></tr>
<tr class="memdesc:ad434d4d608702c94e707a00c84eef984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-implementation of CUDA API function cudaMemset that enforces a single-byte value.  <a href="#ad434d4d608702c94e707a00c84eef984">More...</a><br/></td></tr>
<tr class="separator:ad434d4d608702c94e707a00c84eef984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ae274259bfd1683e70148e21b25681"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a28ae274259bfd1683e70148e21b25681"><td class="memTemplItemLeft" align="right" valign="top">cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a28ae274259bfd1683e70148e21b25681">cudaMemset</a> (T *devPtr, const T &amp;value, const size_t <a class="el" href="namespaceecuda.html#a902187585c1ae9933b4289ebbeef4d21">count</a>)</td></tr>
<tr class="memdesc:a28ae274259bfd1683e70148e21b25681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-implementation of CUDA API function cudaMemset that allows for any data type.  <a href="#a28ae274259bfd1683e70148e21b25681">More...</a><br/></td></tr>
<tr class="separator:a28ae274259bfd1683e70148e21b25681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cefd65379eeb181746c749d665e2289"><td class="memItemLeft" align="right" valign="top">cudaError_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a3cefd65379eeb181746c749d665e2289">cudaMemset2D</a> (char *devPtr, const size_t pitch, const char &amp;value, const size_t width, const size_t height)</td></tr>
<tr class="memdesc:a3cefd65379eeb181746c749d665e2289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-implementation of CUDA API function cudaMemset2D that enforces a single-byte value.  <a href="#a3cefd65379eeb181746c749d665e2289">More...</a><br/></td></tr>
<tr class="separator:a3cefd65379eeb181746c749d665e2289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab103e9d8b086f7d23a0a28861c571072"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab103e9d8b086f7d23a0a28861c571072"><td class="memTemplItemLeft" align="right" valign="top">cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#ab103e9d8b086f7d23a0a28861c571072">cudaMemset2D</a> (T *devPtr, const size_t pitch, const T &amp;value, const size_t width, const size_t height)</td></tr>
<tr class="memdesc:ab103e9d8b086f7d23a0a28861c571072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-implementation of CUDA API function cudaMemset2D that allows for any data type.  <a href="#ab103e9d8b086f7d23a0a28861c571072">More...</a><br/></td></tr>
<tr class="separator:ab103e9d8b086f7d23a0a28861c571072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea59a07fa63a11bdf5a5d2442972dfea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aea59a07fa63a11bdf5a5d2442972dfea"><td class="memTemplItemLeft" align="right" valign="top">cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#aea59a07fa63a11bdf5a5d2442972dfea">cudaMemcpyToSymbol</a> (T *dest, const T *src, size_t <a class="el" href="namespaceecuda.html#a902187585c1ae9933b4289ebbeef4d21">count</a>=1, size_t offset=0, enum cudaMemcpyKind kind=cudaMemcpyHostToDevice)</td></tr>
<tr class="separator:aea59a07fa63a11bdf5a5d2442972dfea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f04181a584d9069d901ec8a4f0e9054"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7f04181a584d9069d901ec8a4f0e9054"><td class="memTemplItemLeft" align="right" valign="top">cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a7f04181a584d9069d901ec8a4f0e9054">cudaMemcpyToSymbol</a> (T &amp;dest, const T &amp;src, enum cudaMemcpyKind kind=cudaMemcpyHostToDevice)</td></tr>
<tr class="separator:a7f04181a584d9069d901ec8a4f0e9054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985c26070efac911941cd9e6408b93c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a985c26070efac911941cd9e6408b93c8">threadfence</a> ()</td></tr>
<tr class="separator:a985c26070efac911941cd9e6408b93c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87a64599df7690ced971a45e4bc41f5"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , typename Distance &gt; </td></tr>
<tr class="memitem:aa87a64599df7690ced971a45e4bc41f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <br class="typebreak"/>
<a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#aa87a64599df7690ced971a45e4bc41f5">advance</a> (InputIterator &amp;iterator, Distance n)</td></tr>
<tr class="memdesc:aa87a64599df7690ced971a45e4bc41f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments given iterator by n elements.  <a href="#aa87a64599df7690ced971a45e4bc41f5">More...</a><br/></td></tr>
<tr class="separator:aa87a64599df7690ced971a45e4bc41f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f81131c5e7831c8b22351ba2ce99096"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:a1f81131c5e7831c8b22351ba2ce99096"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <br class="typebreak"/>
<a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <br class="typebreak"/>
std::iterator_traits&lt; Iterator &gt;<br class="typebreak"/>
::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a1f81131c5e7831c8b22351ba2ce99096">distance</a> (const Iterator &amp;first, const Iterator &amp;last)</td></tr>
<tr class="separator:a1f81131c5e7831c8b22351ba2ce99096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470e314a419a5a2ced0a2f134e0b57f1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P &gt; </td></tr>
<tr class="memitem:a470e314a419a5a2ced0a2f134e0b57f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <br class="typebreak"/>
std::iterator_traits<br class="typebreak"/>
&lt; <a class="el" href="classecuda_1_1device__contiguous__block__iterator.html">device_contiguous_block_iterator</a><br class="typebreak"/>
&lt; T, P &gt; &gt;::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a470e314a419a5a2ced0a2f134e0b57f1">distance</a> (const <a class="el" href="classecuda_1_1device__contiguous__block__iterator.html">device_contiguous_block_iterator</a>&lt; T, P &gt; &amp;first, const <a class="el" href="classecuda_1_1device__contiguous__block__iterator.html">device_contiguous_block_iterator</a>&lt; T, P &gt; &amp;last)</td></tr>
<tr class="separator:a470e314a419a5a2ced0a2f134e0b57f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c015146fc14b398e67605109b8396c"><td class="memTemplParams" colspan="2">template&lt;typename T , class Alloc1 , class Alloc2 &gt; </td></tr>
<tr class="memitem:a16c015146fc14b398e67605109b8396c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a16c015146fc14b398e67605109b8396c">matrix_copy</a> (<a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc1 &gt; &amp;dest, const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc2 &gt; &amp;src, typename <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc2 &gt;::size_type offsetRow=0, typename <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc2 &gt;::size_type offsetColumn=0)</td></tr>
<tr class="memdesc:a16c015146fc14b398e67605109b8396c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies some or all of a source matrix to a destination matrix.  <a href="#a16c015146fc14b398e67605109b8396c">More...</a><br/></td></tr>
<tr class="separator:a16c015146fc14b398e67605109b8396c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363fad3b23be97d929aba4cca2b08c3e"><td class="memTemplParams" colspan="2">template&lt;typename T , class Alloc1 , class Alloc2 &gt; </td></tr>
<tr class="memitem:a363fad3b23be97d929aba4cca2b08c3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a363fad3b23be97d929aba4cca2b08c3e">matrix_swap</a> (<a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc1 &gt; &amp;mat1, <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc2 &gt; &amp;mat2, typename <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc1 &gt;::size_type numberRows=0, typename <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc1 &gt;::size_type numberColumns=0, typename <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc1 &gt;::size_type offsetRow1=0, typename <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc1 &gt;::size_type offsetColumn1=0, typename <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc2 &gt;::size_type offsetRow2=0, typename <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc2 &gt;::size_type offsetColumn2=0)</td></tr>
<tr class="memdesc:a363fad3b23be97d929aba4cca2b08c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps some or all of a source matrix with a destination matrix.  <a href="#a363fad3b23be97d929aba4cca2b08c3e">More...</a><br/></td></tr>
<tr class="separator:a363fad3b23be97d929aba4cca2b08c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c01f1d13fa9b6dab1c44af4a011d577"><td class="memTemplParams" colspan="2">template&lt;typename T , class Alloc &gt; </td></tr>
<tr class="memitem:a9c01f1d13fa9b6dab1c44af4a011d577"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a9c01f1d13fa9b6dab1c44af4a011d577">matrix_transpose</a> (<a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc &gt; &amp;src)</td></tr>
<tr class="separator:a9c01f1d13fa9b6dab1c44af4a011d577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1165795685483cef9b23bb33bd48c829"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , typename T &gt; </td></tr>
<tr class="memitem:a1165795685483cef9b23bb33bd48c829"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a1165795685483cef9b23bb33bd48c829">accumulate</a> (InputIterator first, InputIterator last, T init)</td></tr>
<tr class="memdesc:a1165795685483cef9b23bb33bd48c829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of a sequence of elements.  <a href="#a1165795685483cef9b23bb33bd48c829">More...</a><br/></td></tr>
<tr class="separator:a1165795685483cef9b23bb33bd48c829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3457888d9c15a5013e7f8fdf9df1b2f9"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , typename T , class BinaryOperation &gt; </td></tr>
<tr class="memitem:a3457888d9c15a5013e7f8fdf9df1b2f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a3457888d9c15a5013e7f8fdf9df1b2f9">accumulate</a> (InputIterator first, InputIterator last, T init, BinaryOperation op)</td></tr>
<tr class="memdesc:a3457888d9c15a5013e7f8fdf9df1b2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of a sequence of elements.  <a href="#a3457888d9c15a5013e7f8fdf9df1b2f9">More...</a><br/></td></tr>
<tr class="separator:a3457888d9c15a5013e7f8fdf9df1b2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a1165795685483cef9b23bb33bd48c829"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> T ecuda::accumulate </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sum of a sequence of elements. </p>
<p>Computes the sum of the given value init and the elements in the range [first,last).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,last</td><td>the range of elements to sum </td></tr>
    <tr><td class="paramname">init</td><td>initial value of the sum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of the given value and elements in the given range </dd></dl>

<p>Definition at line <a class="el" href="numeric_8hpp_source.html#l00122">122</a> of file <a class="el" href="numeric_8hpp_source.html">numeric.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3457888d9c15a5013e7f8fdf9df1b2f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , typename T , class BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> T ecuda::accumulate </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sum of a sequence of elements. </p>
<p>Computes the sum of the given value init and the elements in the range [first,last). The sum is calculated using the binary operation function op that should have a signature equivalent to: </p>
<div class="fragment"><div class="line">Ret fun( <span class="keyword">const</span> Type1&amp; a, <span class="keyword">const</span> Type2&amp; b );</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,last</td><td>the range of elements to sum </td></tr>
    <tr><td class="paramname">init</td><td>initial value of the sum </td></tr>
    <tr><td class="paramname">op</td><td>binary operation function object that will be applied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of the given value and elements in the given range </dd></dl>

<p>Definition at line <a class="el" href="numeric_8hpp_source.html#l00143">143</a> of file <a class="el" href="numeric_8hpp_source.html">numeric.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa87a64599df7690ced971a45e4bc41f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , typename Distance &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void ecuda::advance </td>
          <td>(</td>
          <td class="paramtype">InputIterator &amp;&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Distance&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments given iterator by n elements. </p>
<p>If n is negative, the iterator is decremented. This function will work on both iterators of host and device memory. However, if the iterator refers to non-contiguous device memory and this function is called from host code an assertion will fail at compile-time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>iterator to be advanced </td></tr>
    <tr><td class="paramname">n</td><td>number of elements iterator should be advanced </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iterator_8hpp_source.html#l00574">574</a> of file <a class="el" href="iterator_8hpp_source.html">iterator.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a32d5425545b1ea966a9d23e3d2321b6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool ecuda::any_of </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="algorithm_8hpp_source.html#l00080">80</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad79c20b551be33bea5f0b62fba14434d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> OutputIterator ecuda::copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replacement for std::copy. </p>
<p><a class="el" href="namespaceecuda.html#ad79c20b551be33bea5f0b62fba14434d" title="Replacement for std::copy. ">ecuda::copy</a> is identical to std::copy, but can be a) called from device code, and b) supports device memory when called from host code.</p>
<p>Compile-time checks are performed to determine which action should be taken. If called from device code, then it must be true that both the input and output refer to device memory (otherwise nvcc will fail before evaluating the <a class="el" href="namespaceecuda.html#ad79c20b551be33bea5f0b62fba14434d" title="Replacement for std::copy. ">ecuda::copy</a> call) and the copying is done on-device. If the called from host code and both the input and output refer to host memory, the evaluation is delegated to std::copy. If called from host code, and one or both of the input and output refers to device memory, there is a compile-time assertion that fails if the device memory is non-contiguous. Otherwise, a call to cudaMemcpy is performed with parameters depending on the input and output memory types (e.g. if input is host and if output is device, then cudaMemcpy is called with cudaMemcpyHostToDevice used as the cudaMemcpyKind parameter). In addition, when one or both of the input and output iterators refers to device memory, a call to <a class="el" href="namespaceecuda.html#ad79c20b551be33bea5f0b62fba14434d" title="Replacement for std::copy. ">ecuda::copy</a> from host code results in a compile-time check to determine if the value_type of the input and output iterator are the same. If not, and the call is on host code, host staging memory is allocated to perform the type conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,last</td><td>the range of elements to copy </td></tr>
    <tr><td class="paramname">result</td><td>the beginning of the destination range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output iterator to the element in the destination range, one past the last element copied. </dd></dl>

<p>Definition at line <a class="el" href="copy_8hpp_source.html#l00801">801</a> of file <a class="el" href="copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a595acf3358160a89231e322260427baf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> OutputIterator ecuda::copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replacement for std::copy. </p>
<p><a class="el" href="namespaceecuda.html#ad79c20b551be33bea5f0b62fba14434d" title="Replacement for std::copy. ">ecuda::copy</a> is identical to std::copy, but can be a) called from device code, and b) supports device memory when called from host code.</p>
<p>Compile-time checks are performed to determine which action should be taken. If called from device code, then it must be true that both the input and output refer to device memory (otherwise nvcc will fail before evaluating the <a class="el" href="namespaceecuda.html#ad79c20b551be33bea5f0b62fba14434d" title="Replacement for std::copy. ">ecuda::copy</a> call) and the copying is done on-device. If the called from host code and both the input and output refer to host memory, the evaluation is delegated to std::copy. If called from host code, and one or both of the input and output refers to device memory, there is a compile-time assertion that fails if the device memory is non-contiguous. Otherwise, a call to cudaMemcpy is performed with parameters depending on the input and output memory types (e.g. if input is host and if output is device, then cudaMemcpy is called with cudaMemcpyHostToDevice used as the cudaMemcpyKind parameter). In addition, when one or both of the input and output iterators refers to device memory, a call to <a class="el" href="namespaceecuda.html#ad79c20b551be33bea5f0b62fba14434d" title="Replacement for std::copy. ">ecuda::copy</a> from host code results in a compile-time check to determine if the value_type of the input and output iterator are the same. If not, and the call is on host code, host staging memory is allocated to perform the type conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,last</td><td>the range of elements to copy </td></tr>
    <tr><td class="paramname">result</td><td>the beginning of the destination range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output iterator to the element in the destination range, one past the last element copied. </dd></dl>

<p>Definition at line <a class="el" href="copy_8hpp_source.html#l00801">801</a> of file <a class="el" href="copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a902187585c1ae9933b4289ebbeef4d21"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1iterator__traits.html">ecuda::iterator_traits</a>&lt;InputIterator&gt;::difference_type ecuda::count </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="count_8hpp_source.html#l00092">92</a> of file <a class="el" href="count_8hpp_source.html">count.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa98d9362143be45ee0d1b6264b5ac3fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="classecuda_1_1iterator__traits.html">ecuda::iterator_traits</a>&lt;InputIterator&gt;::difference_type ecuda::count_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="count__if_8hpp_source.html#l00091">91</a> of file <a class="el" href="count__if_8hpp_source.html">count_if.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa9bd1e585fb42fdb1c4dfb0548529b3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cudaError_t ecuda::cudaMemcpy </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaMemcpyKind&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper around CUDA API function cudaMemcpy. </p>
<p>Copies a contiguous block of memory holding count elements of type T to another contiguous block of memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to destination memory. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to source memory. </td></tr>
    <tr><td class="paramname">count</td><td>Number of elements to copy. </td></tr>
    <tr><td class="paramname">kind</td><td>Type of transfer (cudaMemcpyDeviceToHost, cudaMemcpyDeviceToDevice, cudaMemcpyHostToDevice) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer, cudaErrorInvalidMemcpyDirection </dd></dl>

<p>Definition at line <a class="el" href="apiwrappers_8hpp_source.html#l00062">62</a> of file <a class="el" href="apiwrappers_8hpp_source.html">apiwrappers.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7e659446682da379a4424c59a87d4956"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cudaError_t ecuda::cudaMemcpy2D </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dpitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>spitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaMemcpyKind&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper around CUDA API function cudaMemcpy2D. </p>
<p>Copies a matrix of width*height elements of type T from a contiguous memory block with a given pitch (in bytes) to another contiguous memory block with a given pitch (in bytes).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to destination memory. </td></tr>
    <tr><td class="paramname">dpitch</td><td>Pitch (in bytes) of destination memory. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to source memory. </td></tr>
    <tr><td class="paramname">spitch</td><td>Pitch (in bytes) of source memory. </td></tr>
    <tr><td class="paramname">width</td><td>Width of matrix. </td></tr>
    <tr><td class="paramname">height</td><td>Height of matrix. </td></tr>
    <tr><td class="paramname">kind</td><td>Type of transfer (cudaMemcpyDeviceToHost, cudaMemcpyDeviceToDevice, cudaMemcpyHostToDevice) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidPitchValue, cudaErrorInvalidDevicePointer, cudaErrorInvalidMemcpyDirection </dd></dl>

<p>Definition at line <a class="el" href="apiwrappers_8hpp_source.html#l00084">84</a> of file <a class="el" href="apiwrappers_8hpp_source.html">apiwrappers.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aea59a07fa63a11bdf5a5d2442972dfea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cudaError_t ecuda::cudaMemcpyToSymbol </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum cudaMemcpyKind&#160;</td>
          <td class="paramname"><em>kind</em> = <code>cudaMemcpyHostToDevice</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="apiwrappers_8hpp_source.html#l00210">210</a> of file <a class="el" href="apiwrappers_8hpp_source.html">apiwrappers.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7f04181a584d9069d901ec8a4f0e9054"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cudaError_t ecuda::cudaMemcpyToSymbol </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum cudaMemcpyKind&#160;</td>
          <td class="paramname"><em>kind</em> = <code>cudaMemcpyHostToDevice</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="apiwrappers_8hpp_source.html#l00216">216</a> of file <a class="el" href="apiwrappers_8hpp_source.html">apiwrappers.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad434d4d608702c94e707a00c84eef984"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cudaError_t ecuda::cudaMemset </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>devPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-implementation of CUDA API function cudaMemset that enforces a single-byte value. </p>
<p>This implementation simply calls the CUDA API cudaMemset function since the value argument is explicitly stated as single byte.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devPtr</td><td>Pointer to device memory. </td></tr>
    <tr><td class="paramname">value</td><td>Value to set for each element. </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer, cudaErrorInvalidMemcpyDirection </dd></dl>

<p>Definition at line <a class="el" href="apiwrappers_8hpp_source.html#l00124">124</a> of file <a class="el" href="apiwrappers_8hpp_source.html">apiwrappers.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a28ae274259bfd1683e70148e21b25681"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cudaError_t ecuda::cudaMemset </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>devPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-implementation of CUDA API function cudaMemset that allows for any data type. </p>
<p>The CUDA API cudaMemset function allows only a single-byte value to be specified. This implementation allows any arbitrary data type and value to be specified. The function checks if value is represented by a single byte or, if multibyte, that each byte in the value is the same. If this true, the CUDA API cudaMemset function can be used. If not, then a staging block of host memory is first filled with the value and then copied to the device memory. Thus, this function is more general but keep in mind that there will be a performance hit if the provided value is not represented by a concatentation of the same single byte.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devPtr</td><td>Pointer to device memory. </td></tr>
    <tr><td class="paramname">value</td><td>Value to set for each element. </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer, cudaErrorInvalidMemcpyDirection </dd></dl>

<p>Definition at line <a class="el" href="apiwrappers_8hpp_source.html#l00147">147</a> of file <a class="el" href="apiwrappers_8hpp_source.html">apiwrappers.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3cefd65379eeb181746c749d665e2289"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cudaError_t ecuda::cudaMemset2D </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>devPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-implementation of CUDA API function cudaMemset2D that enforces a single-byte value. </p>
<p>This implementation simply calls the CUDA API cudaMemset2D function since the value argument is explicitly stated as single byte.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devPtr</td><td>Pointer to 2D device memory. </td></tr>
    <tr><td class="paramname">pitch</td><td>Pitch in bytes of 2D device memory. </td></tr>
    <tr><td class="paramname">value</td><td>Value to set for each element. </td></tr>
    <tr><td class="paramname">width</td><td>Width of matrix. </td></tr>
    <tr><td class="paramname">height</td><td>Height of matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer, cudaErrorInvalidMemcpyDirection </dd></dl>

<p>Definition at line <a class="el" href="apiwrappers_8hpp_source.html#l00170">170</a> of file <a class="el" href="apiwrappers_8hpp_source.html">apiwrappers.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab103e9d8b086f7d23a0a28861c571072"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cudaError_t ecuda::cudaMemset2D </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>devPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-implementation of CUDA API function cudaMemset2D that allows for any data type. </p>
<p>The CUDA API cudaMemset2D function allows only a single-byte value to be specified. This implementation allows any arbitrary data type and value to be specified. The function checks if value is represented by a single byte or, if multibyte, that each byte in the value is the same. If this true, the CUDA API cudaMemset2D function can be used. If not, then a staging block of host memory is first filled with the value and then copied to the device memory. Thus, this function is more general but keep in mind that there will be a performance hit if the provided value is not represented by a concatentation of the same single byte.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devPtr</td><td>Pointer to 2D device memory. </td></tr>
    <tr><td class="paramname">pitch</td><td>Pitch in bytes of 2D device memory. </td></tr>
    <tr><td class="paramname">value</td><td>Value to set for each element. </td></tr>
    <tr><td class="paramname">width</td><td>Width of matrix. </td></tr>
    <tr><td class="paramname">height</td><td>Height of matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer, cudaErrorInvalidMemcpyDirection </dd></dl>

<p>Definition at line <a class="el" href="apiwrappers_8hpp_source.html#l00195">195</a> of file <a class="el" href="apiwrappers_8hpp_source.html">apiwrappers.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1f81131c5e7831c8b22351ba2ce99096"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> std::iterator_traits&lt;Iterator&gt;::difference_type ecuda::distance </td>
          <td>(</td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="iterator_8hpp_source.html#l00627">627</a> of file <a class="el" href="iterator_8hpp_source.html">iterator.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a470e314a419a5a2ced0a2f134e0b57f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> std::iterator_traits&lt; <a class="el" href="classecuda_1_1device__contiguous__block__iterator.html">device_contiguous_block_iterator</a>&lt;T,P&gt; &gt;::difference_type ecuda::distance </td>
          <td>(</td>
          <td class="paramtype">const device_contiguous_block_iterator&lt; T, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const device_contiguous_block_iterator&lt; T, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="iterator_8hpp_source.html#l00636">636</a> of file <a class="el" href="iterator_8hpp_source.html">iterator.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a568367d26ff7d59115ae8958b8ddf6eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator1 , class InputIterator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool ecuda::equal </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replacement for std::equal. </p>
<p><a class="el" href="namespaceecuda.html#a568367d26ff7d59115ae8958b8ddf6eb" title="Replacement for std::equal. ">ecuda::equal</a> is identical to std::equal, but can be a) called from device code, and b) supports device memory when called from host code.</p>
<p>Compile-time checks are performed to determine which action should be taken. If called from device code, then it must be true that both ranges refer to device memory (otherwise nvcc will fail before evaluating the <a class="el" href="namespaceecuda.html#a568367d26ff7d59115ae8958b8ddf6eb" title="Replacement for std::equal. ">ecuda::equal</a> call) and the comparison between ranges is done on-device. If the called from host code and both ranges refer to host memory, the evaluation is delegated to std::equal. If called from host code, and one or both ranges refer to device memory, the range(s) are copied to temporary host memory before delegating to std::equal.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the range [first1,last1) is equal to the range [first2,first2+(last1-first1)), and false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="equal_8hpp_source.html#l00173">173</a> of file <a class="el" href="equal_8hpp_source.html">equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1fd08c374f6dff0cc18e6cc45adbdd23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator1 , class InputIterator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool ecuda::equal </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replacement for std::equal. </p>
<p><a class="el" href="namespaceecuda.html#a568367d26ff7d59115ae8958b8ddf6eb" title="Replacement for std::equal. ">ecuda::equal</a> is identical to std::equal, but can be a) called from device code, and b) supports device memory when called from host code.</p>
<p>Compile-time checks are performed to determine which action should be taken. If called from device code, then it must be true that both ranges refer to device memory (otherwise nvcc will fail before evaluating the <a class="el" href="namespaceecuda.html#a568367d26ff7d59115ae8958b8ddf6eb" title="Replacement for std::equal. ">ecuda::equal</a> call) and the comparison between ranges is done on-device. If the called from host code and both ranges refer to host memory, the evaluation is delegated to std::equal. If called from host code, and one or both ranges refer to device memory, the range(s) are copied to temporary host memory before delegating to std::equal.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the range [first1,last1) is equal to the range [first2,first2+(last1-first1)), and false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="equal_8hpp_source.html#l00173">173</a> of file <a class="el" href="equal_8hpp_source.html">equal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4a2f18d3c3f7a7d723decd0192b56076"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void ecuda::fill </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fill_8hpp_source.html#l00156">156</a> of file <a class="el" href="fill_8hpp_source.html">fill.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac59747f2869c079dbeeb00e69ced5781"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void ecuda::fill </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="fill_8hpp_source.html#l00156">156</a> of file <a class="el" href="fill_8hpp_source.html">fill.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a482b487ad8d99e85a03ce72b5e5f7c70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> InputIterator ecuda::find </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="find_8hpp_source.html#l00094">94</a> of file <a class="el" href="find_8hpp_source.html">find.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a95c49d41166264fc71c73ab64b622d9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> InputIterator ecuda::find_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="find__if_8hpp_source.html#l00094">94</a> of file <a class="el" href="find__if_8hpp_source.html">find_if.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adc3f7b57ddfe569a22a8fad7207cf8d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class UnaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> UnaryFunction ecuda::for_each </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="for__each_8hpp_source.html#l00089">89</a> of file <a class="el" href="for__each_8hpp_source.html">for_each.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a73d3b756a58da139b956df94d957316b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator1 , class InputIterator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool ecuda::lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lexicographical__compare_8hpp_source.html#l00143">143</a> of file <a class="el" href="lexicographical__compare_8hpp_source.html">lexicographical_compare.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2a44dbc3f6bd18127acd4e226984bbcd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator1 , class InputIterator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool ecuda::lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lexicographical__compare_8hpp_source.html#l00143">143</a> of file <a class="el" href="lexicographical__compare_8hpp_source.html">lexicographical_compare.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a16c015146fc14b398e67605109b8396c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Alloc1 , class Alloc2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> void ecuda::matrix_copy </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T, Alloc1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; T, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename matrix&lt; T, Alloc2 &gt;::size_type&#160;</td>
          <td class="paramname"><em>offsetRow</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename matrix&lt; T, Alloc2 &gt;::size_type&#160;</td>
          <td class="paramname"><em>offsetColumn</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies some or all of a source matrix to a destination matrix. </p>
<p>The subset of the source matrix can be specified by the offsetRow and offsetColumn parameters as well as the size of the destination matrix. If the destination matrix is larger than needed in either dimension the extra elements remain unaltered.</p>
<p>For example, to copy a subset of a matrix: </p>
<div class="fragment"><div class="line"><a class="code" href="classecuda_1_1matrix.html">ecuda::matrix&lt;int&gt;</a> src( 100, 100, 99 ); <span class="comment">// fill 100x100 matrix with the number 99</span></div>
<div class="line"><a class="code" href="classecuda_1_1matrix.html">ecuda::matrix&lt;int&gt;</a> dest( 20, 10 ); <span class="comment">// fill 20x10 matrix with zeros</span></div>
<div class="line"><span class="comment">// copies the elements of the src matrix lying within the top-left coordinate (30,30)</span></div>
<div class="line"><span class="comment">// and bottom-right coordinate (50,40) to the dest matrix</span></div>
<div class="line"><a class="code" href="namespaceecuda.html#a16c015146fc14b398e67605109b8396c">ecuda::matrix_copy</a>( dest, src, 30, 30 );</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the destination matrix </td></tr>
    <tr><td class="paramname">src</td><td>the source matrix </td></tr>
    <tr><td class="paramname">offsetRow</td><td>offset in the starting row of the source matrix (default: 0) </td></tr>
    <tr><td class="paramname">offsetColumn</td><td>offset in the starting column of the destination matrix (default: 0) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00783">783</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a363fad3b23be97d929aba4cca2b08c3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Alloc1 , class Alloc2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> void ecuda::matrix_swap </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T, Alloc1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; T, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename matrix&lt; T, Alloc1 &gt;::size_type&#160;</td>
          <td class="paramname"><em>numberRows</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename matrix&lt; T, Alloc1 &gt;::size_type&#160;</td>
          <td class="paramname"><em>numberColumns</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename matrix&lt; T, Alloc1 &gt;::size_type&#160;</td>
          <td class="paramname"><em>offsetRow1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename matrix&lt; T, Alloc1 &gt;::size_type&#160;</td>
          <td class="paramname"><em>offsetColumn1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename matrix&lt; T, Alloc2 &gt;::size_type&#160;</td>
          <td class="paramname"><em>offsetRow2</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename matrix&lt; T, Alloc2 &gt;::size_type&#160;</td>
          <td class="paramname"><em>offsetColumn2</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps some or all of a source matrix with a destination matrix. </p>
<p>The subset of the two matrices can be specified with the offsetRow1, offsetColumn1, offsetRow2, offsetColumn2 parameters along with the numberRows and numberColumns parameters which are applied to both of the matrices.</p>
<p>If either of the subsets exceed the bounds of their matrix in either dimension a std::out_of_range exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat1</td><td>a matrix whose contents are to be swapped </td></tr>
    <tr><td class="paramname">mat2</td><td>the other matrix whose contents are to be swapped </td></tr>
    <tr><td class="paramname">numberRows</td><td>the number of rows to swap </td></tr>
    <tr><td class="paramname">numberColumns</td><td>the number of columns to swap </td></tr>
    <tr><td class="paramname">offsetRow1</td><td>the starting row in mat1 that will be swapped (default:0) </td></tr>
    <tr><td class="paramname">offsetColumn1</td><td>the starting column in mat1 that will be swapped (default:0) </td></tr>
    <tr><td class="paramname">offsetRow2</td><td>the starting row in mat2 that will be swapped (default:0) </td></tr>
    <tr><td class="paramname">offsetColumn2</td><td>the starting column in mat2 that will be swapped (default:0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>thrown if the specified bounds of either matrix exceeds its actual dimensions </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00815">815</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9c01f1d13fa9b6dab1c44af4a011d577"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> void ecuda::matrix_transpose </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00839">839</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4ba4df69edbf067b8c2f22fd26545ed5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> const T&amp; ecuda::max </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="algorithm_8hpp_source.html#l00051">51</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1013e77b0f188878cdec3096b58076f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> const T&amp; ecuda::max </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="algorithm_8hpp_source.html#l00052">52</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d98980c03fd58b47623cef24f5670b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> ForwardIterator ecuda::max_element </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="max__element_8hpp_source.html#l00094">94</a> of file <a class="el" href="max__element_8hpp_source.html">max_element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a465833740bdd33baea8b71771599079f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> const T&amp; ecuda::min </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="algorithm_8hpp_source.html#l00048">48</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2141ad90b1907878f8b7c4f4382ef92c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> const T&amp; ecuda::min </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="algorithm_8hpp_source.html#l00049">49</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a08780bb9cf2a866eae21588eb0a93440"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator1 , class InputIterator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> <a class="el" href="structecuda_1_1pair.html">ecuda::pair</a>&lt;InputIterator1,InputIterator2&gt; ecuda::mismatch </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="mismatch_8hpp_source.html#l00132">132</a> of file <a class="el" href="mismatch_8hpp_source.html">mismatch.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a719c3ee38cf70b471ceb7b529e1f9384"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> bool ecuda::none_of </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="algorithm_8hpp_source.html#l00088">88</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a60e8e184cc6bfca5de6010459b2504a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BidirectionalIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void ecuda::reverse </td>
          <td>(</td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reverse_8hpp_source.html#l00104">104</a> of file <a class="el" href="reverse_8hpp_source.html">reverse.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab88da887b8ac2129df8ce4fdf62defda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BidirectionalIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a67322a2b321e8da302bb530b9194fc1a">ECUDA_SUPPRESS_HD_WARNINGS</a> <a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void ecuda::reverse </td>
          <td>(</td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="reverse_8hpp_source.html#l00104">104</a> of file <a class="el" href="reverse_8hpp_source.html">reverse.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc2b93d379cadb08c39f2ae420afcf11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#adf86e078e23f9420bb4ad628d2854ebd">__HOST__</a> <a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void ecuda::swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="algorithm_8hpp_source.html#l00054">54</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a985c26070efac911941cd9e6408b93c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global_8hpp.html#a717730334071fc822cf698f433ca9205">__DEVICE__</a> void ecuda::threadfence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="apiwrappers_8hpp_source.html#l00231">231</a> of file <a class="el" href="apiwrappers_8hpp_source.html">apiwrappers.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 28 2016 14:05:58 for Extended CUDA Library (ecuda) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
