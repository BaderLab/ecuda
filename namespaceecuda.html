<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Extended CUDA Library (ecuda): ecuda Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Extended CUDA Library (ecuda)
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ecuda Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1host__allocator.html">host_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An STL allocator for page-locked host memory.  <a href="classecuda_1_1host__allocator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__allocator.html">device_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An STL allocator for device memory.  <a href="classecuda_1_1device__allocator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__pitch__allocator.html">device_pitch_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An STL allocator for hardware aligned device memory.  <a href="classecuda_1_1device__pitch__allocator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fixed-size array stored in device memory.  <a href="classecuda_1_1array.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cube.html">cube</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A resizable cube stored in device memory.  <a href="classecuda_1_1cube.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device.html">device</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates CUDA API device information functions.  <a href="classecuda_1_1device.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counting smart pointer for device memory.  <a href="classecuda_1_1device__ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1event.html">event</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates CUDA API event objects and functions.  <a href="classecuda_1_1event.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1cuda__error.html">cuda_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for CUDA API cudaError_t errors.  <a href="classecuda_1_1cuda__error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structecuda_1_1device__iterator__tag.html">device_iterator_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structecuda_1_1contiguous__device__iterator__tag.html">contiguous_device_iterator_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1contiguous__device__iterator.html">contiguous_device_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator template for use with naked pointers to contiguous device memory.  <a href="classecuda_1_1contiguous__device__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__iterator.html">device_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator template compatible with pointers to device memory.  <a href="classecuda_1_1device__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1reverse__device__iterator.html">reverse_device_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator.  <a href="classecuda_1_1reverse__device__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1host__pointer__iterator.html">host_pointer_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility iterator for C-style arrays.  <a href="classecuda_1_1host__pointer__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix.html">matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A resizable matrix stored in device memory.  <a href="classecuda_1_1matrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1padded__ptr.html">padded_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialized pointer to memory with padding after a fixed-size sequence of data.  <a href="classecuda_1_1padded__ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1striding__ptr.html">striding_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialized pointer to memory holding a sequence of data with fixed-sized spacing between each value.  <a href="classecuda_1_1striding__ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1vector.html">vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A resizable vector stored in device memory.  <a href="classecuda_1_1vector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1sequence__view.html">sequence_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View of data sequence given a pointer and size.  <a href="classecuda_1_1sequence__view.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1contiguous__sequence__view.html">contiguous_sequence_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View of data sequence residing in contiguous memory given a pointer and size.  <a href="classecuda_1_1contiguous__sequence__view.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1matrix__view.html">matrix_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View of data matrix residing given a pointer and dimensions.  <a href="classecuda_1_1matrix__view.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1contiguous__matrix__view.html">contiguous_matrix_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View of data matrix residing in contiguous memory given a pointer and dimensions.  <a href="classecuda_1_1contiguous__matrix__view.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1host__array__proxy.html">host_array_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple utility container to make C-style arrays useable by ecuda containers.  <a href="classecuda_1_1host__array__proxy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af413274e8e981ae6dc8c473e71361afd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af413274e8e981ae6dc8c473e71361afd"><td class="memTemplItemLeft" align="right" valign="top">DEVICE void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#af413274e8e981ae6dc8c473e71361afd">swap</a> (T &amp;t1, T &amp;t2)</td></tr>
<tr class="memdesc:af413274e8e981ae6dc8c473e71361afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the given values.  <a href="#af413274e8e981ae6dc8c473e71361afd">More...</a><br/></td></tr>
<tr class="separator:af413274e8e981ae6dc8c473e71361afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57793d373240b182789c79b54a368fa"><td class="memTemplParams" colspan="2">template&lt;class InputIterator1 , class InputIterator2 &gt; </td></tr>
<tr class="memitem:ae57793d373240b182789c79b54a368fa"><td class="memTemplItemLeft" align="right" valign="top">DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#ae57793d373240b182789c79b54a368fa">lexicographical_compare</a> (InputIterator1 begin1, InputIterator1 end1, InputIterator2 begin2, InputIterator2 end2)</td></tr>
<tr class="memdesc:ae57793d373240b182789c79b54a368fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the first range [begin1,end1) is lexicographically less than the second range [begin2,end2).  <a href="#ae57793d373240b182789c79b54a368fa">More...</a><br/></td></tr>
<tr class="separator:ae57793d373240b182789c79b54a368fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9317b1641ee857cd8dd5a5e46d98e1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afd9317b1641ee857cd8dd5a5e46d98e1"><td class="memTemplItemLeft" align="right" valign="top">DEVICE const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#afd9317b1641ee857cd8dd5a5e46d98e1">min</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:afd9317b1641ee857cd8dd5a5e46d98e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6195a30534df8e0dbfe2365dd8b28fa9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6195a30534df8e0dbfe2365dd8b28fa9"><td class="memTemplItemLeft" align="right" valign="top">DEVICE const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a6195a30534df8e0dbfe2365dd8b28fa9">max</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a6195a30534df8e0dbfe2365dd8b28fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac779eec0742c00c176d10afba7f6e028"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:ac779eec0742c00c176d10afba7f6e028"><td class="memTemplItemLeft" align="right" valign="top">DEVICE ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#ac779eec0742c00c176d10afba7f6e028">max_element</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="separator:ac779eec0742c00c176d10afba7f6e028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d93ec43d889faab4877a64508c0083"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:ae0d93ec43d889faab4877a64508c0083"><td class="memTemplItemLeft" align="right" valign="top">DEVICE ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#ae0d93ec43d889faab4877a64508c0083">min_element</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="separator:ae0d93ec43d889faab4877a64508c0083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19534e773dcdaf729dd4cdde6330afa4"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , typename T &gt; </td></tr>
<tr class="memitem:a19534e773dcdaf729dd4cdde6330afa4"><td class="memTemplItemLeft" align="right" valign="top">DEVICE T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a19534e773dcdaf729dd4cdde6330afa4">accumulate</a> (InputIterator first, InputIterator last, T init=0)</td></tr>
<tr class="separator:a19534e773dcdaf729dd4cdde6330afa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a80e5f8f27e09d32181797366876fc1"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:a9a80e5f8f27e09d32181797366876fc1"><td class="memTemplItemLeft" align="right" valign="top">HOST OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a9a80e5f8f27e09d32181797366876fc1">copy</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr class="memdesc:a9a80e5f8f27e09d32181797366876fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy range of elements.  <a href="#a9a80e5f8f27e09d32181797366876fc1">More...</a><br/></td></tr>
<tr class="separator:a9a80e5f8f27e09d32181797366876fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759c78a1e4125b3f4f3a60f13770c9df"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a759c78a1e4125b3f4f3a60f13770c9df"><td class="memTemplItemLeft" align="right" valign="top">cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a759c78a1e4125b3f4f3a60f13770c9df">cudaMemcpy</a> (T *dest, const T *src, const std::size_t count, cudaMemcpyKind kind)</td></tr>
<tr class="memdesc:a759c78a1e4125b3f4f3a60f13770c9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around CUDA API function cudaMemcpy.  <a href="#a759c78a1e4125b3f4f3a60f13770c9df">More...</a><br/></td></tr>
<tr class="separator:a759c78a1e4125b3f4f3a60f13770c9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6443f3fc662e4015397a140d906662a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa6443f3fc662e4015397a140d906662a"><td class="memTemplItemLeft" align="right" valign="top">cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#aa6443f3fc662e4015397a140d906662a">cudaMemcpy2D</a> (T *dest, const std::size_t dpitch, const T *src, const std::size_t spitch, const std::size_t width, const std::size_t height, cudaMemcpyKind kind)</td></tr>
<tr class="memdesc:aa6443f3fc662e4015397a140d906662a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around CUDA API function cudaMemcpy2D.  <a href="#aa6443f3fc662e4015397a140d906662a">More...</a><br/></td></tr>
<tr class="separator:aa6443f3fc662e4015397a140d906662a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181bf4510a96777fcb4e32a35f309da3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a181bf4510a96777fcb4e32a35f309da3"><td class="memTemplItemLeft" align="right" valign="top">cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a181bf4510a96777fcb4e32a35f309da3">cudaMemset</a> (T *devPtr, const T &amp;value, const std::size_t count)</td></tr>
<tr class="memdesc:a181bf4510a96777fcb4e32a35f309da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-implementation of CUDA API function cudaMemset that allows for any data type.  <a href="#a181bf4510a96777fcb4e32a35f309da3">More...</a><br/></td></tr>
<tr class="separator:a181bf4510a96777fcb4e32a35f309da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2653ed7ec3a5a643b445754fe2085f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8e2653ed7ec3a5a643b445754fe2085f"><td class="memTemplItemLeft" align="right" valign="top">cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a8e2653ed7ec3a5a643b445754fe2085f">cudaMemset2D</a> (T *devPtr, const std::size_t pitch, const T &amp;value, const std::size_t width, const std::size_t height)</td></tr>
<tr class="memdesc:a8e2653ed7ec3a5a643b445754fe2085f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-implementation of CUDA API function cudaMemset2D that allows for any data type.  <a href="#a8e2653ed7ec3a5a643b445754fe2085f">More...</a><br/></td></tr>
<tr class="separator:a8e2653ed7ec3a5a643b445754fe2085f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca572276dd557132355a1cf1a349c22c"><td class="memTemplParams" colspan="2">template&lt;class Iterator , class Distance &gt; </td></tr>
<tr class="memitem:aca572276dd557132355a1cf1a349c22c"><td class="memTemplItemLeft" align="right" valign="top">HOST void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#aca572276dd557132355a1cf1a349c22c">advance</a> (Iterator &amp;iter, Distance n)</td></tr>
<tr class="memdesc:aca572276dd557132355a1cf1a349c22c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments given iterator by n elements.  <a href="#aca572276dd557132355a1cf1a349c22c">More...</a><br/></td></tr>
<tr class="separator:aca572276dd557132355a1cf1a349c22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca454746f328541c052ee8ed4976a1a9"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:aca454746f328541c052ee8ed4976a1a9"><td class="memTemplItemLeft" align="right" valign="top">HOST std::iterator_traits<br class="typebreak"/>
&lt; Iterator &gt;::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#aca454746f328541c052ee8ed4976a1a9">distance</a> (Iterator first, Iterator last)</td></tr>
<tr class="memdesc:aca454746f328541c052ee8ed4976a1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements between first and last.  <a href="#aca454746f328541c052ee8ed4976a1a9">More...</a><br/></td></tr>
<tr class="separator:aca454746f328541c052ee8ed4976a1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50623e27eaaced8cbae456582281dea1"><td class="memTemplParams" colspan="2">template&lt;typename T , class Alloc1 , class Alloc2 &gt; </td></tr>
<tr class="memitem:a50623e27eaaced8cbae456582281dea1"><td class="memTemplItemLeft" align="right" valign="top">HOST void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a50623e27eaaced8cbae456582281dea1">matrix_copy</a> (<a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc1 &gt; &amp;dest, const <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc2 &gt; &amp;src, typename <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc2 &gt;::size_type offsetRow=0, typename <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc2 &gt;::size_type offsetColumn=0)</td></tr>
<tr class="memdesc:a50623e27eaaced8cbae456582281dea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies some or all of a source matrix to a destination matrix.  <a href="#a50623e27eaaced8cbae456582281dea1">More...</a><br/></td></tr>
<tr class="separator:a50623e27eaaced8cbae456582281dea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc7fc3619b9edb814ce39160af80b4e"><td class="memTemplParams" colspan="2">template&lt;typename T , class Alloc1 , class Alloc2 &gt; </td></tr>
<tr class="memitem:a2fc7fc3619b9edb814ce39160af80b4e"><td class="memTemplItemLeft" align="right" valign="top">HOST void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceecuda.html#a2fc7fc3619b9edb814ce39160af80b4e">matrix_swap</a> (<a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc1 &gt; &amp;mat1, <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc2 &gt; &amp;mat2, typename <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc1 &gt;::size_type numberRows=0, typename <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc1 &gt;::size_type numberColumns=0, typename <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc1 &gt;::size_type offsetRow1=0, typename <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc1 &gt;::size_type offsetColumn1=0, typename <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc2 &gt;::size_type offsetRow2=0, typename <a class="el" href="classecuda_1_1matrix.html">matrix</a>&lt; T, Alloc2 &gt;::size_type offsetColumn2=0)</td></tr>
<tr class="memdesc:a2fc7fc3619b9edb814ce39160af80b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps some or all of a source matrix with a destination matrix.  <a href="#a2fc7fc3619b9edb814ce39160af80b4e">More...</a><br/></td></tr>
<tr class="separator:a2fc7fc3619b9edb814ce39160af80b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a19534e773dcdaf729dd4cdde6330afa4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DEVICE T ecuda::accumulate </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="algorithm_8hpp_source.html#l00101">101</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca572276dd557132355a1cf1a349c22c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator , class Distance &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">HOST void ecuda::advance </td>
          <td>(</td>
          <td class="paramtype">Iterator &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Distance&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments given iterator by n elements. </p>
<p>This is analagous to the STL std::advance function in the STL &lt;iterator&gt; header. In this case, the function supports <em>ecuda</em> device iterators. If the given iterator is not a device iterator, it resolves to std::advance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>iterator to be advance </td></tr>
    <tr><td class="paramname">n</td><td>number of elements it should be advanced </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="iterators_8hpp_source.html#l00579">579</a> of file <a class="el" href="iterators_8hpp_source.html">iterators.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9a80e5f8f27e09d32181797366876fc1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST OutputIterator ecuda::copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy range of elements. </p>
<p>This is analagous to the std::copy method in the STL &lt;algorithm&gt; header. In this case, the behaviour of the copy is determined at compile-time depending on whether the source and destination iterators are contiguous and whether they refer to device or host memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,last</td><td>input iterators to the initial and final positions in a sequence to be copied. The range used is [first,last), which contains all the elements between first and last, including the element pointed by first but the not the element pointed by last. </td></tr>
    <tr><td class="paramname">result</td><td>Output iterator to the initial position in the destination sequence. This shall not pointer to any element in the range [first,last). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the end of the destination range where elements have been copied. </dd></dl>

<p>Definition at line <a class="el" href="algorithm_8hpp_source.html#l00187">187</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a759c78a1e4125b3f4f3a60f13770c9df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cudaError_t ecuda::cudaMemcpy </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaMemcpyKind&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper around CUDA API function cudaMemcpy. </p>
<p>Copies a contiguous block of memory holding count elements of type T to another contiguous block of memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to destination memory. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to source memory. </td></tr>
    <tr><td class="paramname">count</td><td>Number of elements to copy. </td></tr>
    <tr><td class="paramname">kind</td><td>Type of transfer (cudaMemcpyDeviceToHost, cudaMemcpyDeviceToDevice, cudaMemcpyHostToDevice) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer, cudaErrorInvalidMemcpyDirection </dd></dl>

<p>Definition at line <a class="el" href="apiwrappers_8hpp_source.html#l00060">60</a> of file <a class="el" href="apiwrappers_8hpp_source.html">apiwrappers.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa6443f3fc662e4015397a140d906662a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cudaError_t ecuda::cudaMemcpy2D </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>dpitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>spitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaMemcpyKind&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper around CUDA API function cudaMemcpy2D. </p>
<p>Copies a matrix of width*height elements of type T from a contiguous memory block with a given pitch (in bytes) to another contiguous memory block with a given pitch (in bytes).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to destination memory. </td></tr>
    <tr><td class="paramname">dpitch</td><td>Pitch (in bytes) of destination memory. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to source memory. </td></tr>
    <tr><td class="paramname">spitch</td><td>Pitch (in bytes) of source memory. </td></tr>
    <tr><td class="paramname">width</td><td>Width of matrix. </td></tr>
    <tr><td class="paramname">height</td><td>Height of matrix. </td></tr>
    <tr><td class="paramname">kind</td><td>Type of transfer (cudaMemcpyDeviceToHost, cudaMemcpyDeviceToDevice, cudaMemcpyHostToDevice) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidPitchValue, cudaErrorInvalidDevicePointer, cudaErrorInvalidMemcpyDirection </dd></dl>

<p>Definition at line <a class="el" href="apiwrappers_8hpp_source.html#l00081">81</a> of file <a class="el" href="apiwrappers_8hpp_source.html">apiwrappers.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a181bf4510a96777fcb4e32a35f309da3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cudaError_t ecuda::cudaMemset </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>devPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-implementation of CUDA API function cudaMemset that allows for any data type. </p>
<p>The CUDA API cudaMemset function allows only a single-byte value to be specified. This implementation allows any arbitrary data type and value to be specified. However, the underlying call is to cudaMemcpy since a staging block of memory is first filled with the value and then transfered to the device. Thus, this function is more general but takes some unspecified performance hit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devPtr</td><td>Pointer to device memory. </td></tr>
    <tr><td class="paramname">value</td><td>Value to set for each element. </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer, cudaErrorInvalidMemcpyDirection </dd></dl>

<p>Definition at line <a class="el" href="apiwrappers_8hpp_source.html#l00101">101</a> of file <a class="el" href="apiwrappers_8hpp_source.html">apiwrappers.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8e2653ed7ec3a5a643b445754fe2085f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cudaError_t ecuda::cudaMemset2D </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>devPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-implementation of CUDA API function cudaMemset2D that allows for any data type. </p>
<p>The CUDA API cudaMemset2D function allows only a single-byte value to be specified. This implementation allows any arbitrary data type and value to be specified. However, the underlying call is to cudaMemcpy since a staging block of memory is first filled with the value and then transfered to the device. Thus, this function is more general but takes some unspecified performance hit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devPtr</td><td>Pointer to 2D device memory. </td></tr>
    <tr><td class="paramname">pitch</td><td>Pitch in bytes of 2D device memory. </td></tr>
    <tr><td class="paramname">value</td><td>Value to set for each element. </td></tr>
    <tr><td class="paramname">width</td><td>Width of matrix. </td></tr>
    <tr><td class="paramname">height</td><td>Height of matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cudaSuccess, cudaErrorInvalidValue, cudaErrorInvalidDevicePointer, cudaErrorInvalidMemcpyDirection </dd></dl>

<p>Definition at line <a class="el" href="apiwrappers_8hpp_source.html#l00124">124</a> of file <a class="el" href="apiwrappers_8hpp_source.html">apiwrappers.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca454746f328541c052ee8ed4976a1a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST std::iterator_traits&lt;Iterator&gt;::difference_type ecuda::distance </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements between first and last. </p>
<p>This is analagous to the STL std::distance function in the STL &lt;iterator&gt; header. In this case, the function supports <em>ecuda</em> device iterators. If the given iterator is not a device iterator, it resolves to std::distance.</p>
<p>Note that this function is far more efficient for contiguous device iterators, since the distance can be calculated through a simple (last-first), rather than incrementing the iterator step-by-step until last is reached. This is also the case with the STL method, where iterators from the RandomAccessIterator category are more efficient than other categories.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator pointing to the first element </td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing to the end of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements between first and last. </dd></dl>

<p>Definition at line <a class="el" href="iterators_8hpp_source.html#l00618">618</a> of file <a class="el" href="iterators_8hpp_source.html">iterators.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae57793d373240b182789c79b54a368fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator1 , class InputIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DEVICE bool ecuda::lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>end2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the first range [begin1,end1) is lexicographically less than the second range [begin2,end2). </p>
<dl class="section return"><dt>Returns</dt><dd>true if the first range is lexicographically less than the second. </dd></dl>

<p>Definition at line <a class="el" href="algorithm_8hpp_source.html#l00074">74</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a50623e27eaaced8cbae456582281dea1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Alloc1 , class Alloc2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">HOST void ecuda::matrix_copy </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T, Alloc1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; T, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename matrix&lt; T, Alloc2 &gt;::size_type&#160;</td>
          <td class="paramname"><em>offsetRow</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename matrix&lt; T, Alloc2 &gt;::size_type&#160;</td>
          <td class="paramname"><em>offsetColumn</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies some or all of a source matrix to a destination matrix. </p>
<p>The subset of the source matrix can be specified by the offsetRow and offsetColumn parameters as well as the size of the destination matrix. If the destination matrix is larger than needed in either dimension the extra elements remain unaltered.</p>
<p>For example, to copy a subset of a matrix: </p>
<div class="fragment"><div class="line"><a class="code" href="classecuda_1_1matrix.html">ecuda::matrix&lt;int&gt;</a> src( 100, 100, 99 ); <span class="comment">// fill 100x100 matrix with the number 99</span></div>
<div class="line"><a class="code" href="classecuda_1_1matrix.html">ecuda::matrix&lt;int&gt;</a> dest( 20, 10 ); <span class="comment">// fill 20x10 matrix with zeros</span></div>
<div class="line"><span class="comment">// copies the elements of the src matrix lying within the top-left coordinate (30,30)</span></div>
<div class="line"><span class="comment">// and bottom-right coordinate (50,40) to the dest matrix</span></div>
<div class="line"><a class="code" href="namespaceecuda.html#a50623e27eaaced8cbae456582281dea1">ecuda::matrix_copy</a>( dest, src, 30, 30 );</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the destination matrix </td></tr>
    <tr><td class="paramname">src</td><td>the source matrix </td></tr>
    <tr><td class="paramname">offsetRow</td><td>offset in the starting row of the source matrix (default: 0) </td></tr>
    <tr><td class="paramname">offsetColumn</td><td>offset in the starting column of the destination matrix (default: 0) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00910">910</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2fc7fc3619b9edb814ce39160af80b4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Alloc1 , class Alloc2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">HOST void ecuda::matrix_swap </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; T, Alloc1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; T, Alloc2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename matrix&lt; T, Alloc1 &gt;::size_type&#160;</td>
          <td class="paramname"><em>numberRows</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename matrix&lt; T, Alloc1 &gt;::size_type&#160;</td>
          <td class="paramname"><em>numberColumns</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename matrix&lt; T, Alloc1 &gt;::size_type&#160;</td>
          <td class="paramname"><em>offsetRow1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename matrix&lt; T, Alloc1 &gt;::size_type&#160;</td>
          <td class="paramname"><em>offsetColumn1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename matrix&lt; T, Alloc2 &gt;::size_type&#160;</td>
          <td class="paramname"><em>offsetRow2</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename matrix&lt; T, Alloc2 &gt;::size_type&#160;</td>
          <td class="paramname"><em>offsetColumn2</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps some or all of a source matrix with a destination matrix. </p>
<p>The subset of the two matrices can be specified with the offsetRow1, offsetColumn1, offsetRow2, offsetColumn2 parameters along with the numberRows and numberColumns parameters which are applied to both of the matrices.</p>
<p>If either of the subsets exceed the bounds of their matrix in either dimension a std::out_of_range exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat1</td><td>a matrix whose contents are to be swapped </td></tr>
    <tr><td class="paramname">mat2</td><td>the other matrix whose contents are to be swapped </td></tr>
    <tr><td class="paramname">numberRows</td><td>the number of rows to swap </td></tr>
    <tr><td class="paramname">numberColumns</td><td>the number of columns to swap </td></tr>
    <tr><td class="paramname">offsetRow1</td><td>the starting row in mat1 that will be swapped (default:0) </td></tr>
    <tr><td class="paramname">offsetColumn1</td><td>the starting column in mat1 that will be swapped (default:0) </td></tr>
    <tr><td class="paramname">offsetRow2</td><td>the starting row in mat2 that will be swapped (default:0) </td></tr>
    <tr><td class="paramname">offsetColumn2</td><td>the starting column in mat2 that will be swapped (default:0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>thrown if the specified bounds of either matrix exceeds its actual dimensions </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="matrix_8hpp_source.html#l00942">942</a> of file <a class="el" href="matrix_8hpp_source.html">matrix.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6195a30534df8e0dbfe2365dd8b28fa9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEVICE const T&amp; ecuda::max </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="algorithm_8hpp_source.html#l00084">84</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac779eec0742c00c176d10afba7f6e028"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DEVICE ForwardIterator ecuda::max_element </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="algorithm_8hpp_source.html#l00087">87</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afd9317b1641ee857cd8dd5a5e46d98e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEVICE const T&amp; ecuda::min </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="algorithm_8hpp_source.html#l00082">82</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae0d93ec43d889faab4877a64508c0083"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DEVICE ForwardIterator ecuda::min_element </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="algorithm_8hpp_source.html#l00094">94</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af413274e8e981ae6dc8c473e71361afd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEVICE void ecuda::swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the given values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1,t2</td><td>the values to be swapped </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="algorithm_8hpp_source.html#l00062">62</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 13 2015 17:40:41 for Extended CUDA Library (ecuda) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
