<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Extended CUDA Library (ecuda): ecuda::device_ptr&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Extended CUDA Library (ecuda)
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceecuda.html">ecuda</a></li><li class="navelem"><a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classecuda_1_1device__ptr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ecuda::device_ptr&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A reference-counting smart pointer for device memory.  
 <a href="classecuda_1_1device__ptr.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac64c3078ff59b0505e7dd9695debe34a"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#ac64c3078ff59b0505e7dd9695debe34a">element_type</a></td></tr>
<tr class="memdesc:ac64c3078ff59b0505e7dd9695debe34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">data type represented in allocated memory  <a href="#ac64c3078ff59b0505e7dd9695debe34a">More...</a><br/></td></tr>
<tr class="separator:ac64c3078ff59b0505e7dd9695debe34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69cf18c266ed439831b5a2227db79b0"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#af69cf18c266ed439831b5a2227db79b0">pointer</a></td></tr>
<tr class="memdesc:af69cf18c266ed439831b5a2227db79b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">data type pointer  <a href="#af69cf18c266ed439831b5a2227db79b0">More...</a><br/></td></tr>
<tr class="separator:af69cf18c266ed439831b5a2227db79b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb77bc7113e67ccb2809d72ec5fc467"><td class="memItemLeft" align="right" valign="top">typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#abdb77bc7113e67ccb2809d72ec5fc467">reference</a></td></tr>
<tr class="memdesc:abdb77bc7113e67ccb2809d72ec5fc467"><td class="mdescLeft">&#160;</td><td class="mdescRight">data type reference  <a href="#abdb77bc7113e67ccb2809d72ec5fc467">More...</a><br/></td></tr>
<tr class="separator:abdb77bc7113e67ccb2809d72ec5fc467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac017ed2e7598472dd8619b167c0d74e7"><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#ac017ed2e7598472dd8619b167c0d74e7">size_type</a></td></tr>
<tr class="memdesc:ac017ed2e7598472dd8619b167c0d74e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">size type for pointer arithmetic and reference counting  <a href="#ac017ed2e7598472dd8619b167c0d74e7">More...</a><br/></td></tr>
<tr class="separator:ac017ed2e7598472dd8619b167c0d74e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b84253bb68820eb4e02fd5d59a5bd97"><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#a1b84253bb68820eb4e02fd5d59a5bd97">difference_type</a></td></tr>
<tr class="memdesc:a1b84253bb68820eb4e02fd5d59a5bd97"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed integer type of the result of subtracting two pointers  <a href="#a1b84253bb68820eb4e02fd5d59a5bd97">More...</a><br/></td></tr>
<tr class="separator:a1b84253bb68820eb4e02fd5d59a5bd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a21531cd4a3a7f12781bc215996a605a8"><td class="memItemLeft" align="right" valign="top">HOST DEVICE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#a21531cd4a3a7f12781bc215996a605a8">device_ptr</a> (<a class="el" href="classecuda_1_1device__ptr.html#af69cf18c266ed439831b5a2227db79b0">pointer</a> ptr=<a class="el" href="classecuda_1_1device__ptr.html#af69cf18c266ed439831b5a2227db79b0">pointer</a>())</td></tr>
<tr class="memdesc:a21531cd4a3a7f12781bc215996a605a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a21531cd4a3a7f12781bc215996a605a8">More...</a><br/></td></tr>
<tr class="separator:a21531cd4a3a7f12781bc215996a605a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab60fb0e8975fa68bc5d4c54c020b8ca"><td class="memItemLeft" align="right" valign="top">HOST DEVICE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#aab60fb0e8975fa68bc5d4c54c020b8ca">device_ptr</a> (const <a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a>&lt; T &gt; &amp;src)</td></tr>
<tr class="memdesc:aab60fb0e8975fa68bc5d4c54c020b8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#aab60fb0e8975fa68bc5d4c54c020b8ca">More...</a><br/></td></tr>
<tr class="separator:aab60fb0e8975fa68bc5d4c54c020b8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51192357571dd5b420b01f2107b82309"><td class="memItemLeft" align="right" valign="top">HOST DEVICE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#a51192357571dd5b420b01f2107b82309">device_ptr</a> (<a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a>&lt; T &gt; &amp;&amp;src)</td></tr>
<tr class="memdesc:a51192357571dd5b420b01f2107b82309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#a51192357571dd5b420b01f2107b82309">More...</a><br/></td></tr>
<tr class="separator:a51192357571dd5b420b01f2107b82309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5a66b24db14c2563a8554ff4832c43"><td class="memItemLeft" align="right" valign="top">HOST DEVICE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#a1c5a66b24db14c2563a8554ff4832c43">~device_ptr</a> ()</td></tr>
<tr class="memdesc:a1c5a66b24db14c2563a8554ff4832c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a1c5a66b24db14c2563a8554ff4832c43">More...</a><br/></td></tr>
<tr class="separator:a1c5a66b24db14c2563a8554ff4832c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718b0e0b0bbe63113dd2b34c1cd60077"><td class="memItemLeft" align="right" valign="top">HOST DEVICE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#a718b0e0b0bbe63113dd2b34c1cd60077">swap</a> (<a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a> &amp;other) __NOEXCEPT__</td></tr>
<tr class="memdesc:a718b0e0b0bbe63113dd2b34c1cd60077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of *this and other.  <a href="#a718b0e0b0bbe63113dd2b34c1cd60077">More...</a><br/></td></tr>
<tr class="separator:a718b0e0b0bbe63113dd2b34c1cd60077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39961832f40e636741a70de127635c87"><td class="memItemLeft" align="right" valign="top">HOST DEVICE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#a39961832f40e636741a70de127635c87">reset</a> () __NOEXCEPT__</td></tr>
<tr class="memdesc:a39961832f40e636741a70de127635c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases ownership of the managed pointer to device memory.  <a href="#a39961832f40e636741a70de127635c87">More...</a><br/></td></tr>
<tr class="separator:a39961832f40e636741a70de127635c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2824d5affa84d3b502c0ee4bdb29f2b"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ae2824d5affa84d3b502c0ee4bdb29f2b"><td class="memTemplItemLeft" align="right" valign="top">HOST DEVICE void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#ae2824d5affa84d3b502c0ee4bdb29f2b">reset</a> (U *p) __NOEXCEPT__</td></tr>
<tr class="memdesc:ae2824d5affa84d3b502c0ee4bdb29f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the managed pointer to device memory with another.  <a href="#ae2824d5affa84d3b502c0ee4bdb29f2b">More...</a><br/></td></tr>
<tr class="separator:ae2824d5affa84d3b502c0ee4bdb29f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d118a84a9b21475c1ceda8ac6cb79a"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1device__ptr.html#af69cf18c266ed439831b5a2227db79b0">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#ab9d118a84a9b21475c1ceda8ac6cb79a">get</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:ab9d118a84a9b21475c1ceda8ac6cb79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the managed pointer to device memory.  <a href="#ab9d118a84a9b21475c1ceda8ac6cb79a">More...</a><br/></td></tr>
<tr class="separator:ab9d118a84a9b21475c1ceda8ac6cb79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ac6a47f1371a451a389c69b114c710"><td class="memItemLeft" align="right" valign="top">DEVICE <a class="el" href="classecuda_1_1device__ptr.html#abdb77bc7113e67ccb2809d72ec5fc467">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#a70ac6a47f1371a451a389c69b114c710">operator*</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:a70ac6a47f1371a451a389c69b114c710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereferences the managed pointer to device memory.  <a href="#a70ac6a47f1371a451a389c69b114c710">More...</a><br/></td></tr>
<tr class="separator:a70ac6a47f1371a451a389c69b114c710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2613ec8dda029ffc516c70f55a851c97"><td class="memItemLeft" align="right" valign="top">DEVICE <a class="el" href="classecuda_1_1device__ptr.html#af69cf18c266ed439831b5a2227db79b0">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#a2613ec8dda029ffc516c70f55a851c97">operator-&gt;</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:a2613ec8dda029ffc516c70f55a851c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereferences the managed pointer to device memory.  <a href="#a2613ec8dda029ffc516c70f55a851c97">More...</a><br/></td></tr>
<tr class="separator:a2613ec8dda029ffc516c70f55a851c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1d9d4d5cdf567bad83466937a53c30"><td class="memItemLeft" align="right" valign="top">HOST <a class="el" href="classecuda_1_1device__ptr.html#ac017ed2e7598472dd8619b167c0d74e7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#a2e1d9d4d5cdf567bad83466937a53c30">use_count</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:a2e1d9d4d5cdf567bad83466937a53c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of different host-bound <a class="el" href="classecuda_1_1device__ptr.html" title="A reference-counting smart pointer for device memory. ">device_ptr</a> instances managing the current pointer to device memory.  <a href="#a2e1d9d4d5cdf567bad83466937a53c30">More...</a><br/></td></tr>
<tr class="separator:a2e1d9d4d5cdf567bad83466937a53c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8f083d44daff89674cd0c69053bfaa"><td class="memItemLeft" align="right" valign="top">HOST bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#a3e8f083d44daff89674cd0c69053bfaa">unique</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:a3e8f083d44daff89674cd0c69053bfaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if *this is the only <a class="el" href="classecuda_1_1device__ptr.html" title="A reference-counting smart pointer for device memory. ">device_ptr</a> instance managing the current pointer to device memory.  <a href="#a3e8f083d44daff89674cd0c69053bfaa">More...</a><br/></td></tr>
<tr class="separator:a3e8f083d44daff89674cd0c69053bfaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b395137c61fb7b06b5836cb44b0cee2"><td class="memItemLeft" align="right" valign="top">HOST DEVICE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#a1b395137c61fb7b06b5836cb44b0cee2">operator bool</a> () const __NOEXCEPT__</td></tr>
<tr class="memdesc:a1b395137c61fb7b06b5836cb44b0cee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if *this stores a non-null pointer, i.e. whether <a class="el" href="classecuda_1_1device__ptr.html#ab9d118a84a9b21475c1ceda8ac6cb79a" title="Returns the managed pointer to device memory. ">get()</a> != nullptr.  <a href="#a1b395137c61fb7b06b5836cb44b0cee2">More...</a><br/></td></tr>
<tr class="separator:a1b395137c61fb7b06b5836cb44b0cee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec244033215d3c95e6fa28c4720bad8a"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:aec244033215d3c95e6fa28c4720bad8a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#aec244033215d3c95e6fa28c4720bad8a">owner_before</a> (const <a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a>&lt; U &gt; &amp;other) const </td></tr>
<tr class="memdesc:aec244033215d3c95e6fa28c4720bad8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether this <a class="el" href="classecuda_1_1device__ptr.html" title="A reference-counting smart pointer for device memory. ">device_ptr</a> precedes other in implementation defined owner-based (as opposed to value-based) order.  <a href="#aec244033215d3c95e6fa28c4720bad8a">More...</a><br/></td></tr>
<tr class="separator:aec244033215d3c95e6fa28c4720bad8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12720beaec4d8b5f73244bbe82ba9d44"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a12720beaec4d8b5f73244bbe82ba9d44"><td class="memTemplItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#a12720beaec4d8b5f73244bbe82ba9d44">operator==</a> (const <a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a>&lt; U &gt; &amp;other) const </td></tr>
<tr class="separator:a12720beaec4d8b5f73244bbe82ba9d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433a7687f902271a365f651b6d2cfe8b"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a433a7687f902271a365f651b6d2cfe8b"><td class="memTemplItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#a433a7687f902271a365f651b6d2cfe8b">operator!=</a> (const <a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a>&lt; U &gt; &amp;other) const </td></tr>
<tr class="separator:a433a7687f902271a365f651b6d2cfe8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a5a8d9dfda0b1625c4c050c269e147"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a89a5a8d9dfda0b1625c4c050c269e147"><td class="memTemplItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#a89a5a8d9dfda0b1625c4c050c269e147">operator&lt;</a> (const <a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a>&lt; U &gt; &amp;other) const </td></tr>
<tr class="separator:a89a5a8d9dfda0b1625c4c050c269e147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41109f8b49ea844b1d58fe2b9f444c06"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a41109f8b49ea844b1d58fe2b9f444c06"><td class="memTemplItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#a41109f8b49ea844b1d58fe2b9f444c06">operator&gt;</a> (const <a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a>&lt; U &gt; &amp;other) const </td></tr>
<tr class="separator:a41109f8b49ea844b1d58fe2b9f444c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b75f1d1ef0038143b2b8e2dcd098c6c"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a8b75f1d1ef0038143b2b8e2dcd098c6c"><td class="memTemplItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#a8b75f1d1ef0038143b2b8e2dcd098c6c">operator&lt;=</a> (const <a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a>&lt; U &gt; &amp;other) const </td></tr>
<tr class="separator:a8b75f1d1ef0038143b2b8e2dcd098c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924e4a22efeda675ffedbffa2660dc53"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a924e4a22efeda675ffedbffa2660dc53"><td class="memTemplItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#a924e4a22efeda675ffedbffa2660dc53">operator&gt;=</a> (const <a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a>&lt; U &gt; &amp;other) const </td></tr>
<tr class="separator:a924e4a22efeda675ffedbffa2660dc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402f524d01334d6ce8c2800ac0122775"><td class="memItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#a402f524d01334d6ce8c2800ac0122775">operator==</a> (std::nullptr_t other) const </td></tr>
<tr class="separator:a402f524d01334d6ce8c2800ac0122775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78800320ff35bd2779e91121d5f12e59"><td class="memItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#a78800320ff35bd2779e91121d5f12e59">operator!=</a> (std::nullptr_t other) const </td></tr>
<tr class="separator:a78800320ff35bd2779e91121d5f12e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a90da5d1c315308acfab412b257212e"><td class="memItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#a0a90da5d1c315308acfab412b257212e">operator&lt;</a> (std::nullptr_t other) const </td></tr>
<tr class="separator:a0a90da5d1c315308acfab412b257212e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325e0a20ac1c783bc2d245cba77592c8"><td class="memItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#a325e0a20ac1c783bc2d245cba77592c8">operator&gt;</a> (std::nullptr_t other) const </td></tr>
<tr class="separator:a325e0a20ac1c783bc2d245cba77592c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbee3600d70eee517ea536d08eee2962"><td class="memItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#abbee3600d70eee517ea536d08eee2962">operator&lt;=</a> (std::nullptr_t other) const </td></tr>
<tr class="separator:abbee3600d70eee517ea536d08eee2962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda038135185807f2321e856d701c566"><td class="memItemLeft" align="right" valign="top">HOST DEVICE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#adda038135185807f2321e856d701c566">operator&gt;=</a> (std::nullptr_t other) const </td></tr>
<tr class="separator:adda038135185807f2321e856d701c566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756c882f3097eede2d3c68348b6591c4"><td class="memItemLeft" align="right" valign="top">HOST <a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#a756c882f3097eede2d3c68348b6591c4">operator=</a> (<a class="el" href="classecuda_1_1device__ptr.html#af69cf18c266ed439831b5a2227db79b0">pointer</a> p)</td></tr>
<tr class="separator:a756c882f3097eede2d3c68348b6591c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01afdf678af7841b9abce535a8be4864"><td class="memItemLeft" align="right" valign="top">HOST DEVICE <a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#a01afdf678af7841b9abce535a8be4864">operator=</a> (const <a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="separator:a01afdf678af7841b9abce535a8be4864"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ad9955cdb1f856fc1a7c893f7fbe8a0d5"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V &gt; </td></tr>
<tr class="memitem:ad9955cdb1f856fc1a7c893f7fbe8a0d5"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; U, V &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classecuda_1_1device__ptr.html#ad9955cdb1f856fc1a7c893f7fbe8a0d5">operator&lt;&lt;</a> (std::basic_ostream&lt; U, V &gt; &amp;out, const <a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a> &amp;ptr)</td></tr>
<tr class="separator:ad9955cdb1f856fc1a7c893f7fbe8a0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br/>
class ecuda::device_ptr&lt; T &gt;</h3>

<p>A reference-counting smart pointer for device memory. </p>
<p>This class keeps a pointer to allocated device memory and automatically deallocates it when all references to it go out of scope. The workings are similar to a C++11 <code>std::shared_ptr</code>. Since deallocation can only be done from host code reference counting only occurs within host code. On the device the pointer is passed around freely without regards to reference counting and will never undergo deallocation.</p>
<p>Like a typical smart pointer, this class handles deallocation but allocation is performed elsewhere and the pointer to the allocated memory location is passed to the constructor. </p>

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00066">66</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a1b84253bb68820eb4e02fd5d59a5bd97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::ptrdiff_t <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::<a class="el" href="classecuda_1_1device__ptr.html#a1b84253bb68820eb4e02fd5d59a5bd97">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>signed integer type of the result of subtracting two pointers </p>

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00073">73</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac64c3078ff59b0505e7dd9695debe34a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::<a class="el" href="classecuda_1_1device__ptr.html#ac64c3078ff59b0505e7dd9695debe34a">element_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>data type represented in allocated memory </p>

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00069">69</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af69cf18c266ed439831b5a2227db79b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::<a class="el" href="classecuda_1_1device__ptr.html#af69cf18c266ed439831b5a2227db79b0">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>data type pointer </p>

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00070">70</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abdb77bc7113e67ccb2809d72ec5fc467"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T&amp; <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::<a class="el" href="classecuda_1_1device__ptr.html#abdb77bc7113e67ccb2809d72ec5fc467">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>data type reference </p>

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00071">71</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac017ed2e7598472dd8619b167c0d74e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::<a class="el" href="classecuda_1_1device__ptr.html#ac017ed2e7598472dd8619b167c0d74e7">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>size type for pointer arithmetic and reference counting </p>

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00072">72</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a21531cd4a3a7f12781bc215996a605a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::<a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1device__ptr.html#af69cf18c266ed439831b5a2227db79b0">pointer</a>&#160;</td>
          <td class="paramname"><em>ptr</em> = <code><a class="el" href="classecuda_1_1device__ptr.html#af69cf18c266ed439831b5a2227db79b0">pointer</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the allocated block of device memory. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00085">85</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aab60fb0e8975fa68bc5d4c54c020b8ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::<a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>If called from the host, the reference count is incremented. If called from the device, the underlying pointer is copied but no change to the reference count occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Another device pointer to be used as source to initialize with. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00102">102</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a51192357571dd5b420b01f2107b82309"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::<a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Constructs the device pointer using move semantics. This constructor is only available if the compiler is configured to allow C++11.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Another device pointer whose contents are to be moved. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00117">117</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1c5a66b24db14c2563a8554ff4832c43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::~<a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Destructs the device pointer. If called from host code, the reference count is decremented. If the reference count becomes zero, the device memory is freed. If called from the device the object is destroyed but nothing happens to the underlying pointer or reference count. </p>

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00135">135</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab9d118a84a9b21475c1ceda8ac6cb79a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1device__ptr.html#af69cf18c266ed439831b5a2227db79b0">pointer</a> <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the managed pointer to device memory. </p>
<p>If no pointer is being managed, this will return null.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to device memory. </dd></dl>

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00182">182</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1b395137c61fb7b06b5836cb44b0cee2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if *this stores a non-null pointer, i.e. whether <a class="el" href="classecuda_1_1device__ptr.html#ab9d118a84a9b21475c1ceda8ac6cb79a" title="Returns the managed pointer to device memory. ">get()</a> != nullptr. </p>
<dl class="section return"><dt>Returns</dt><dd>true if *this stores a pointer, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00219">219</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a433a7687f902271a365f651b6d2cfe8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00240">240</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a78800320ff35bd2779e91121d5f12e59"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This operator is only available if the compiler is configured to allow C++11. </p>

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00255">255</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a70ac6a47f1371a451a389c69b114c710"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEVICE <a class="el" href="classecuda_1_1device__ptr.html#abdb77bc7113e67ccb2809d72ec5fc467">reference</a> <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dereferences the managed pointer to device memory. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the object at the managed device memory location. </dd></dl>

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00189">189</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2613ec8dda029ffc516c70f55a851c97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DEVICE <a class="el" href="classecuda_1_1device__ptr.html#af69cf18c266ed439831b5a2227db79b0">pointer</a> <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dereferences the managed pointer to device memory. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the object at the managed device memory location. </dd></dl>

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00196">196</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a89a5a8d9dfda0b1625c4c050c269e147"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00241">241</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0a90da5d1c315308acfab412b257212e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This operator is only available if the compiler is configured to allow C++11. </p>

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00260">260</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8b75f1d1ef0038143b2b8e2dcd098c6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00243">243</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abbee3600d70eee517ea536d08eee2962"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This operator is only available if the compiler is configured to allow C++11. </p>

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00270">270</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a756c882f3097eede2d3c68348b6591c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST <a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a>&lt;T&gt;&amp; <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1device__ptr.html#af69cf18c266ed439831b5a2227db79b0">pointer</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00284">284</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a01afdf678af7841b9abce535a8be4864"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE <a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a>&lt;T&gt;&amp; <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00292">292</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a12720beaec4d8b5f73244bbe82ba9d44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00239">239</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a402f524d01334d6ce8c2800ac0122775"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This operator is only available if the compiler is configured to allow C++11. </p>

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00250">250</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a41109f8b49ea844b1d58fe2b9f444c06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00242">242</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a325e0a20ac1c783bc2d245cba77592c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This operator is only available if the compiler is configured to allow C++11. </p>

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00265">265</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a924e4a22efeda675ffedbffa2660dc53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00244">244</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adda038135185807f2321e856d701c566"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE bool <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This operator is only available if the compiler is configured to allow C++11. </p>

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00275">275</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aec244033215d3c95e6fa28c4720bad8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::owner_before </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether this <a class="el" href="classecuda_1_1device__ptr.html" title="A reference-counting smart pointer for device memory. ">device_ptr</a> precedes other in implementation defined owner-based (as opposed to value-based) order. </p>
<p>This method is included to make <a class="el" href="classecuda_1_1device__ptr.html" title="A reference-counting smart pointer for device memory. ">device_ptr</a> have as much as common with the STL C++11 shared_ptr specification, although it is not currently used for any internal ecuda purposes and hasn't been extensively tested. At present, it returns false if neither of the compared device_ptrs manage pointers, and true if this managed pointer's address is less than other (if one or the other manages no pointers, i.e. is null, the address is considered to be 0 for the purposes of comparison).</p>
<dl class="section return"><dt>Returns</dt><dd>true if *this precedes other, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00232">232</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a39961832f40e636741a70de127635c87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE void <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases ownership of the managed pointer to device memory. </p>
<p>After this call, *this manages no object. </p>

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00166">166</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae2824d5affa84d3b502c0ee4bdb29f2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE void <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the managed pointer to device memory with another. </p>
<p>U must be a complete type and implicitly convertible to T. </p>

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00173">173</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a718b0e0b0bbe63113dd2b34c1cd60077"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST DEVICE void <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of *this and other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>device pointer to exchange the contents with </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00151">151</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3e8f083d44daff89674cd0c69053bfaa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST bool <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::unique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if *this is the only <a class="el" href="classecuda_1_1device__ptr.html" title="A reference-counting smart pointer for device memory. ">device_ptr</a> instance managing the current pointer to device memory. </p>
<dl class="section return"><dt>Returns</dt><dd>true if *this is the only <a class="el" href="classecuda_1_1device__ptr.html" title="A reference-counting smart pointer for device memory. ">device_ptr</a> instance managing the current pointer to device memory, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00212">212</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2e1d9d4d5cdf567bad83466937a53c30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HOST <a class="el" href="classecuda_1_1device__ptr.html#ac017ed2e7598472dd8619b167c0d74e7">size_type</a> <a class="el" href="classecuda_1_1device__ptr.html">ecuda::device_ptr</a>&lt; T &gt;::use_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of different host-bound <a class="el" href="classecuda_1_1device__ptr.html" title="A reference-counting smart pointer for device memory. ">device_ptr</a> instances managing the current pointer to device memory. </p>
<p>If there is no managed pointer 0 is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of host-bound <a class="el" href="classecuda_1_1device__ptr.html" title="A reference-counting smart pointer for device memory. ">device_ptr</a> instances managing the current pointer to device memory. 0 if there is no managed pointer. </dd></dl>

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00205">205</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="ad9955cdb1f856fc1a7c893f7fbe8a0d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;U,V&gt;&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; U, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classecuda_1_1device__ptr.html">device_ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="device__ptr_8hpp_source.html#l00279">279</a> of file <a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/ecuda/<a class="el" href="device__ptr_8hpp_source.html">device_ptr.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 13 2015 17:40:41 for Extended CUDA Library (ecuda) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
